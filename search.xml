<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的多线程-01]]></title>
    <url>%2F2019%2F10%2F09%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-01%2F</url>
    <content type="text"><![CDATA[Java中的多线程-01前言前面我们学习了Java8中一些新的特性，不过那些基本上都是支线剧情。主线剧情我们已经走完了Java中IO，现在就要开始另一个主线剧情了——Java中的多线程。这也是非常重要的一个部分。下面就来简单的学习一下吧。 什么是多线程说到多线程，这又得说到我们说设计模式的时候说到的那个单例模式了。正常情况下，饿汉式单例模式是不会出现问题的，但是一旦进入了多线程的环境的时候，代码就会出现很大的问题。那么究竟是为什么会出问题呢？多线程到底又是什么呢？ 计算机中有很多的进程，比如说现在我的电脑中开着很多软件。qq是一个进程，微信也是一个进程。每一个程序都是一个进程。我们的计算机就是多进程的。每个进程都有多个线程。比如QQ中和不同的人聊天，每一个聊天窗口就可以看出是一个线程（其实聊天窗口也应该是多线程的）。如果QQ是单线程的，我们每次只能和一个人聊天，而不能同时和多个人聊天，这该多无聊。（不对啊，有人找我用QQ聊过天吗？笑cry） 把上面的例子类比到我们的Java程序中来。也就是说如果我们的Java程序一次只可以干一件事情，那么就是单线程的，如果同时干多件事情，那么就是多线程的。简单一点来说就是，如果我们可以只用一条线就可以将代码中所有的操作连接在一起，那么就是单线程，若是出现了分叉，那就是多线程的。不过众所周知，Java中程序运行的都是按照从上到下的顺序来执行的，怎么可以同时执行多个操作呢？ 我们当然是不可能通过之前是方式来创建多线程的操作的，所以Java提供了一个类java.lang.Thread，通过这个类，就可以实现多线程的操作。 java.lang.Thread上面我们说到了多线程的实现和这个类有关，那么我们就来学习一下这个类的有关的信息。 java.lang.Object java.lang.Thread public class Thread extends Object implements Runnable 线程是程序中执行的线程。Java虚拟机允许应用程序同时执行多个执行线程。 每个线程都有优先权。 具有较高优先级的线程优先于优先级较低的线程执行。 每个线程可能也可能不会被标记为守护程序。 当在某个线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。 当Java虚拟机启动时，通常有一个非守护进程线程（通常调用某些指定类的名为main的方法）。 Java虚拟机将继续执行线程，直到发生以下任一情况： 已经调用了Runtime类的exit方法，并且安全管理器已经允许进行退出操作。 所有不是守护进程线程的线程都已经死亡，无论是从调用返回到run方法还是抛出超出run方法的run 。 至于这个类的构战方法和实例方法现在暂且不看了。其实上面的东西也没有什么看的必要。不过官方文档下面给我们的信息是非常重要的。在jdk1.5之前，我们可以使用两种方式创建线程。一种方式是继承Thread类，另一种方式是实现Runnable接口。 创建一个线程继承Thread类现在我们想要使用多线程的方式输出0-100之中所有的偶数。首先是第一中方式，继承Thread类。 但我们需要创建一个线程的时候，需要一下的几个步骤。 写一个类继承Thread类 重写类中的run()方法。 创建这个类的实例 调用类中的start()方法。 public class Demo1 { public static void main(String[] args) { Thread thread = new Mythread(); thread.start(); System.out.println(&quot;Main Function End!&quot;); } } class Mythread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(i); } } } } 比如说上面的代码就是按照上面的步骤创建的一个多线程。那么如何证明这个是多线程呢？Java程序中原来就是一个单线程执行的，这个线程是主线程。主线程从main函数开始执行。执行到run之后，开启了一个新的新的线程。此时这个新的线程和主线程是同时开始运行的。所以此时我们执行这个代码，输出的结果可能就是Main Functin End先开始输出了。 不过为什么我们重写的run方法，要启动线程却要调用start方法呢？我们是否可以直接调用run方法？确实是可以直接调用run方法的，不过这个就不是多线程了，而就是一个普通的类的调用。此时Main Function End肯定是最后输出的。所谓的start方法其实是java.lang.Thread这个类的专门用来启动线程的方法，我们不通过这个start方法是没有办法启动一个线程的。至于run方法，在java.lang.Thread类中其实也是有实现的，不过按道理来说应该是一个抽象函数，为什么会有实现呢？这里可以以后再说。 现在我们要是两个线程去输出结果，现在应该怎么办呢？很简单，再次调用一下start方式不就可以了？不过很遗憾，这个方式是大错特错的。这样做会抛出一个java.lang.IllegalThreadStateException异常，一个线程只能够被启动一次。其实之后我们就会明白了，一个线程就像一个人，调用start就相当于出生了，run方法执行完毕就相当于死亡了。你想要一个线程起死回生这明显是不可能的事情。不过我们可以再生一个线程。（正如你的爸妈觉得你太笨了，是没办法把你塞会娘胎里重新生一次，不过他们可以选择再生一个，蛤蛤蛤）。 不过现在还是有问题，我们搞不清楚现在是谁输出的啊？其实我们可以通过getName()方法得到线程的名字。我们可以让主线程也参与到输出中来。不过如何获取主线程的名字？我们可以使用Thread.currentThread().getName()方法获取运行当前的代码的代码的线程名字。对于前面的Thread及其子类说，可以直接使用getName()方式。（相当于this.getName()) public class Demo1 { public static void main(String[] args) { Thread thread = new Mythread(); thread.start(); Thread thread2 = new Mythread(); thread2.start(); for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i); } } } } class Mythread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(getName()+&quot;: &quot;+i); } } } } 上面其实就是三线程的代码了。观察其中的一段输出结果。 main: 18 Thread-1: 38 Thread-0: 20 Thread-1: 40 main: 20 Thread-1: 42 Thread-0: 22 Thread-1: 44 Thread-0和Thread-1是自动给我们直接创建的线程的编号。当然我们也可以通过setName()方式给我们的线程起一个名字。不过这个操作我们必须要在这个线程调用start方法之前使用。给主线程起名字就和上面得到主线程的名字一样，可以使用Thread.currentThraed().setName()。不过除了上面的方法之外，我们还可以直接在构战函数中给定线程的名字。因为我发现Thread类有如下的构造函数。 Thread(String name) // 分配一个新的 Thread对象。 不过构造函数式无法继承的。我们需要在MyThread中写一个Mythread(String name)构造函数，不过空参构造函数也是必须的。 Mythread(String name) { super(name); } Mythread() { super(); } 上面是关于线程名字设置的一些bb，不过现在让我回到输出的内容中来。我们发现这三个线程的输出是有交互的。这足以说明这三个线程是并行的了，也就是这三个线程是同时进行的。 *注意： * 上面我说这三个线程的同时进行的。其实这是一个误解。其实同一个时间上其实还是只有一个线程被执行。因为我们的CPU同一个时间段只可以执行一个操作。那我们为什么说他们是并行的呢？那是因为CPU切换的速度非常快，他可能是执行这个线程一点点时间，然后去执行另外的线程，然后再次切回到这个线程。这个切换的时间非常的短。正是因为时间非常的短，我们才会说这个是可以看成是多线程的。正如我们看的电影，其实就是一张张图片连续切换。有的是一秒六十帧，有的是八十帧，还有的是一百二十帧。正是因为切换的速度非常的快，我们才感觉这个是连续的。如果每秒就放几张 。。。emm，这不是PPT吗？ 实现Runnable接口上面我们使用的方式是继承的方式来实现创建线程。不过这可能会带来一个比较大的问题。众所周知，Java中的类都是单继承了。如果我们继承了Thread这个类，那么我们就无法继承其他的类。比如上面我们的Mythread如果应该是MyTinythread的子类，但是因为继承Thread就无法继承MyTinythread了。所以说使用继承的方式来实现多线程倒是有点限制。不过Java中接口是没有个数限制的，你要是本事大，你实现一百个接口也没有人管你。所以现在我们需要使用接口的方式来实现多线程的操作。 因为说实在的，上面我们创建多线程的操作。除了写个run函数，其余的操作都是没有用的操作。我们甚至可以使用匿名内部类的方式来创建一个多线程，比如。 new Thread(){ @Override public void run() { System.out.println(&quot;Hello World&quot;); } }.start(); 经过我们之前的学习，匿名内部类这个玩意是和接口有点儿关系的。这个接口应该是只有一个void run()方法来需要我们实现的。这个接口就是Runnable接口。 public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); } } class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } 我们可以通过上面的方式来创建一个多线程。 要注意的是，虽然我们的MyThread类实现了Runnable接口并且实现了其中的run方法。我们是不可以使用myThread.start()方法来启动这个线程的。因为MyThread没有启动线程的能力。而接口也只是一个协议，这只是告诉别人，我实现了一个方法void run()。并没有其他的信息。我们想要启动线程，还是要借助java.lang.Thread类。 我们发现java.lang.Thread中还是有这样的构造函数。 Thread(Runnable target) // 分配一个新的 Thread对象。 Thread(Runnable target, String name) // 分配一个新的 Thread对象。 不过现在问题也来了，我们实现了这个接口，但是我们调用start方法启动的不应该是Thread中的run（上面我们推测应该是一个抽象方法的）吗？和接口中的run又有什么联系呢？我们来看一下源码就好了。 @Override public void run() { if (target != null) { target.run(); } } 可以看到如果我们没有传递Runnable接口的话，这个函数确实是什么都不会做。如果我们使用继承的方式的话，这个函数应该是被覆盖了的，当时我们猜测父类中的函数应该是抽象函数就是没有考虑到构造函数中还可以使用Runnable接口。如果使用Runnable接口的话，target就不会是null。然后就会调用接口中的run方法。 下面我们继续来探讨一下上面谈过的问题。 第一个设置线程的名字。可以通过上面的第二个构造函数来传递名字参数。（此时不需要我们写其他的构造函数了）。不过也可以通过在调用start方法前，使用thread.setName()的方式。 第二个获取线程的名字。依旧可以使用getName()的方式。不过需要注意的是，在MyThread中，我们不可以使用getName()的方式来获取线程的名字了。因为此时这个类已经不是Thread的子类，也不存在getName()这个方法了。如果在这个类中，我们需要使用像获取主线程的名字那样的形式Thread.currentThread().getName()的方式。 第三个就是如果我们此时还想要开始一个同样的线程应该如何？继续new一个MyThread??当然不是，我们说过线程有生有死，不能起死回生。但是MyThread并不是一个线程。我们想要重新创建一个线程的话，只需要new一个Thread，然后继续将MyThread作为一个Runnable参数传递出去就行了。 public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread); thread1.setName(&quot;线程一&quot;); thread1.start(); Thread thread2 = new Thread(myThread); thread2.setName(&quot;线程二&quot;); thread2.start(); Thread.currentThread().setName(&quot;主线程&quot;); for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } 总结上面只是简单的介绍了一下两种创建线程的方式，至于其他更加深入的就要等到下次再讲了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的StreamAPI]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%BC%BA%E5%A4%A7%E7%9A%84StreamAPI%2F</url>
    <content type="text"><![CDATA[强大的StreamAPI前言其实之前已经说了不少的有关Java8的新的特性的话题了，比如说最重要的lambda表达式，还有之前说的那个函数式接口与方法引用都是Java8中的一大更新。不过Java8中两大最重要的改变，第一个是lambda表达式，第二个就是我们接下来要说的强大的StreamAPI了。Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这 是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程 序员的生产力，让程序员写出高效率、干净、简洁的代码。 StreamAPI的基础知识那么StreamAPI到底是一个什么玩意呢？所谓的Stream就是流的意思，大抵就是处理数据用的玩意。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。这么说可能是有点儿懵逼的感觉，Stream是一种处理集合数据的算法或者说结构吗？不全是。那么？Stream到底是什么呢？ Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是数据，Stream讲的是计算！” 关于Stream有三大需要注意的地方。 Stream自己不会储存元素，他只是用来处理元素用的。 Stream不会改变源对象，他之后将源对象经过处理之后返回一个新的Stream Stream的操作是延迟执行的，他只会在需要结果的时候才去执行。 关于Stream的操作，主要分为一下的三个步骤： 创建一个Stream；从一个数据源中获取一个需要处理的流。这个数据源多半是集合。 中间操作；对这个流进行处理。 终止操作；结束对这个流的操作。 创建StreamStreamAPI这个玩意不像之前的东西，这个东西就是要按照规矩来一步一步的来学，毕竟他就是一个API而已。那么我们先从如何创建一个Stream开始说起。 前面说了，最常用与stream的就是Java中的集合。那么第一种方式就是。 从集合中创建一个Stream集合的最终父类是Collection，在Java8种这个接口被扩展了。增加了两个新的方法。 default Stream&lt;E&gt; stream() // 返回一个顺序流 default Stream&lt;E&gt; parallelStream() // 返回一个并行流 也就是说有了一个集合，我们就可以通过stream或者parallelStream方法返回一个stream对象。比如说。 public class Demo { public static List&lt;Student&gt; getList() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;sher1&quot;, 18, 88.3, 110)); list.add(new Student(&quot;sher2&quot;, 28, 188.3, 2110)); list.add(new Student(&quot;sher3&quot;, 38, 288.3, 3110)); list.add(new Student(&quot;sher4&quot;, 48, 388.3, 4110)); list.add(new Student(&quot;sher5&quot;, 58, 488.3, 5110)); list.add(new Student(&quot;sher6&quot;, 68, 588.3, 6110)); list.add(new Student(&quot;sher7&quot;, 78, 688.3, 7110)); list.add(new Student(&quot;sher8&quot;, 88, 788.3, 8110)); return list; } public static void main(String[] args) { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; studentStream = list.stream(); Stream&lt;Student&gt; parallelStream = list.parallelStream(); } } 通过上面的方式就可以创建出一个Stream。至于取得这个Stream之后的操作如何，这里不说。（没用使用官方文档的套路说，是因为官方文档中对Stream的说明都太高大上了，我都不知道Stream是啥，你给我整那么多代码干啥） 上面创建了两个流。第一个是顺序流，也是最常用的。第二个是并行流。 这里我们可以使用forEach方法来对流中的元素进行一次遍历。 studentStream.forEach(System.out::println); System.out.println(&quot;======================&quot;); parallelStream.forEach(s -&gt; System.out.println(s)); forEach函数需要的参数是一个Consumer。上面的第一种方式是使用方法引用，第二种方式是使用lambda表达式。这个算是对之前学习的内容的一个简单的复习。这里来看一下他们的输出。 Student{mName=&#39;sher1&#39;, mAge=18, mScore=88.3, phone=110} Student{mName=&#39;sher2&#39;, mAge=28, mScore=188.3, phone=2110} Student{mName=&#39;sher3&#39;, mAge=38, mScore=288.3, phone=3110} Student{mName=&#39;sher4&#39;, mAge=48, mScore=388.3, phone=4110} Student{mName=&#39;sher5&#39;, mAge=58, mScore=488.3, phone=5110} Student{mName=&#39;sher6&#39;, mAge=68, mScore=588.3, phone=6110} Student{mName=&#39;sher7&#39;, mAge=78, mScore=688.3, phone=7110} Student{mName=&#39;sher8&#39;, mAge=88, mScore=788.3, phone=8110} ========================================================= Student{mName=&#39;sher6&#39;, mAge=68, mScore=588.3, phone=6110} Student{mName=&#39;sher5&#39;, mAge=58, mScore=488.3, phone=5110} Student{mName=&#39;sher8&#39;, mAge=88, mScore=788.3, phone=8110} Student{mName=&#39;sher7&#39;, mAge=78, mScore=688.3, phone=7110} Student{mName=&#39;sher3&#39;, mAge=38, mScore=288.3, phone=3110} Student{mName=&#39;sher4&#39;, mAge=48, mScore=388.3, phone=4110} Student{mName=&#39;sher2&#39;, mAge=28, mScore=188.3, phone=2110} Student{mName=&#39;sher1&#39;, mAge=18, mScore=88.3, phone=110} 顺序流中的数据和原来集合中的元素的顺序是一致的，但是并行流我们运行了几次之后发现顺序都是会发生变化的。可见并行流中对于数据的处理是没有顺序的。更严谨的说，他对数据的处理是并行的。这里多线程还没有说，如果讲了多线程之后就是特别的容易理解的了。 从数组中创建一个流数组中似乎没有stream这个方法。不过Java8种更新了一个和数组的使用密切相关的类——Arrays。我们可以使用如下的方式从数组中获取一个流。 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) //返回一个流 代码测试如下 @Test public void test2() { int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9}; String[] strArr = {&quot;sher&quot;, &quot;hony&quot;, &quot;sherhony&quot;}; IntStream stream = Arrays.stream(arr); Stream&lt;String&gt; stringStream = Arrays.stream(strArr); stream.forEach(System.out::println); stringStream.forEach(System.out::println); } 其实上面的代码很容易发现一个奇怪的地方。为啥int数组返回的是IntStream而不是Stream&lt;Integer&gt;。我们上面的自定义的类型和String类型都是Stream&lt;T&gt;的形式。当我使用Stream&lt;Integer&gt;来代替IntStream的时候，发现报错了。我们发现，这个函数处理int的时候并没有涉及装箱拆箱的操作，而是这个方法对int[] short[] double[]这三个基本数据类型参数做了重载。如果是short[] float[] char[]这种数组的话，是没有办法直接使用Arrays.stream方法的。可以转为Short[]等才能够使用这个方法。 public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 通过Stream的of()方法上面是两种创建流的方式最常用的方式。下面再次来介绍一下通过Stream的of()方法来创建一个流。方法如下： public static&lt;T&gt; Stream&lt;T&gt; of(T... values) // 返回一个流 @Test public void test3() { Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7); integerStream.forEach(System.out::println); } 创建一个无限流上面的三个方法都是创建了一个有限流。我们也可以通过一下的两种方式创建一个无限流。 //迭代 public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) // 生成 public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) 先来说第一个方式迭代。所谓迭代就是通过一个递推的方式来产生一个无限流。比如说产生所有的奇数流就可以这样写。 @Test public void test4() { Stream&lt;Integer&gt; iterate = Stream.iterate(1, x -&gt; x + 2); iterate.limit(10).forEach(System.out::println); } 上面使用的limit(10)就是把流限制在10个，不然无限流就会无限运行下去。 也可以使用generate方法，比如说产生无限个随机数的流。 @Test public void test5() { Stream&lt;Double&gt; generate = Stream.generate(Math::random); generate.limit(10).forEach(System.out::println); } Stream的中间操作上面我们已经基本掌握了创建一个Stream的方式，现在要学的是Stream中最重要的一块——中间操作。 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全 部处理，称为“惰性求值” 那么上面我们只是使用了创建流的方式为什么我们可以看到流中的数据呢？那是因为我们确实使用了终止操作，forEach就是一个终止操作，安装流中的顺序来遍历流中的元素。其实上面无限流中说到的限制流中元素的个数的操作就是一种中间操作。中间操作也分为多种，下面来一种一种介绍。 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ，从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一 个空流。与 limit(n) 互补 下面来对上面的代码就以上面的那个List&lt;Student&gt;做代码演示 输出所有年龄大于40岁的 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.filter(x -&gt; x.getAge() &gt; 40).forEach(System.out::println); } 去掉重复的学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.distinct().forEach(System.out::println); } 注意：一个流在经过终止操作了就不能够再使用。 输出前五个学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.limit(5).forEach(System.out::println); } 跳过前五个学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.skip.forEach(System.out::println); } 上面的方法都比较简单，下面来看看下一个操作。 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流 所谓的map就是映射的意思。高中是都学过映射的概念，就是将一个值以某种法则变成另一个值。 @Test public void test7() { Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7); integerStream.map(x -&gt; { if (x % 2 == 0) { return 0; } else { return x; } }).forEach(System.out::println); } 上面的方法可以将流中的所有的偶数变成0。对于这个例子来说也可以写成mapToInt，mapToDouble，mapToLong这三种形式，只不过是返回值的类型不同罢了。 对于flatMap的使用就是比较复杂了的。他是将每个值都换成另一个流，然后将所有的流连接成为一个流。 比如如下的代码 @Test public void test8() { List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(1); list1.add(1); list1.add(2); List&lt;Integer&gt; list2= new ArrayList&lt;&gt;(); list2.add(2); list2.add(3); List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); list3.add(6); list.add(list1); list.add(list2); list.add(list3); Stream&lt;List&lt;Integer&gt;&gt; stream = list.stream(); stream.forEach(x -&gt;{ x.forEach(System.out::println); }); } 这个流中的元素都是List，如果我们想要取得所有的数据的话就需要对流中的元素再次使用forEach。这两个forEach是不一样的。一个forEach是流对象的，而另一个是集合对象的方法。 如果我们使用的是flatMap方法就可以将流中的数据转成一个流，然后将这些流合并成一个流，这样我们就可以只使用一个forEach就可以对这个流进行遍历了。 list.stream().flatMap(List::stream).forEach(System.out::println); 只需要使用这一行的代码，其中使用两个方法引用。List::stream是将一个List转为Stream用的。这也是对方法引用的一个复习了。 上面的映射的操作应该是StreamAPI的核心操作，特别是map方法就是最重要的一个操作。前面的filter方法也是一个非常重要的方法。 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排 如果要使用第一种方式，流中的数据的类型必要要实现Comparable接口（里面有个compareTo方法），不然是不可以使用第一种方式的。(这都应该是Java中的基础中的基础了吧) 如果是使用第二种方式的话，只要实现这个函数式接口就行了。 @Test public void test9() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.sorted(Comparator.comparing(Student::getAge)).forEach(System.out::println); } 如果需要得是降序的话，就只能写成这种形式了 stream.sorted((x, y) -&gt; -Integer.compare(x.getAge(), y.getAge())) .forEach(System.out::println); 上面基本上就是最常用的中间操作了，下面要来介绍的是终止操作。 终止操作上面的操作中我们使用的所有的终止操作都是forEach方法来遍历，其实Stream的终止操作也有很多，而且也分为不同的类型。下面就来一一介绍吧。 匹配和查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。相反，Stream API 使用内部迭 代——它帮你把迭代做了) 上面的值也都是很容易理解，不需要其他过多的说明。 归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一 个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一 个值。返回 Optional 这个操作一般情况下是和map操作结合起来用的，比如要求所有的学生的年龄之和。 @Test public void test11() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Optional&lt;Integer&gt; reduce = stream.map(Student::getAge).reduce(Integer::sum); reduce.ifPresent(System.out::println); } 至于第一个函数的第一个参数就是初始值。用法如下。 @Test public void test11() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); // Optional&lt;Integer&gt; reduce = stream.map(Student::getAge).reduce(Integer::sum); Integer reduce = stream.map(Student::getAge).reduce(a, (x, y) -&gt; x * y); System.out.println(reduce); } 这里返回的类型是T，不是Optional&lt;T&gt;。 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总 的方法 函数名 返回值 toList List&lt;T&gt; 把流中元素收集到List List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList()); toSet Set&lt;T&gt; 把流中元素收集到Set Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet()); toCollection Collection&lt;T&gt; 把流中元素收集到创建的集合 Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 int total=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平 均值 int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional&lt;T&gt; 根据比较器选择最大值 Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional&lt;T&gt; 根据比较器选择最小值 Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型从一个作为累加器的初始值开始， 利用BinaryOperator与流中元素逐 个结合，从而归约成单个值 int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转 换函数 int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&lt;T&gt;&gt; 根据某属性值对流分组，属性为K， 结果为V Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; 根据true或false进行分区 Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 上面是常用的一些方法。下面都有代码演示。 @Test public void test12() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); ArrayList&lt;Student&gt; collect = stream.filter(x -&gt; x.getAge() &gt; 40) .collect(Collectors.toCollection(ArrayList::new)); for (Student student : collect) { System.out.println(student); } } @Test public void test13() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Integer collect = stream.collect(Collectors.reducing(0, Student::getAge, Integer::sum)); System.out.println(collect); } @Test public void test14() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Integer collect = stream.collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); System.out.println(collect); } @Test public void test15() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Map&lt;Integer, List&lt;Student&gt;&gt; collect = stream.collect(Collectors.groupingBy(Student::getAge)); for (Integer i : collect.keySet()) { System.out.println(&quot;i = &quot; + i); System.out.println(collect.get(i).get(0)); } } @Test public void test16() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Map&lt;Boolean, List&lt;Student&gt;&gt; collect = stream.collect(Collectors.partitioningBy(x -&gt; x.getAge() &gt; 40)); for (Boolean b : collect.keySet()) { System.out.println(b); for (Student s : collect.get(b)) { System.out.println(s); } } } 总结StreamAPI是Java8种新增的非常顶的API，对于这种API式的东西就是多用多学习，其他也是没有什么好的捷径了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式接口与方法引用]]></title>
    <url>%2F2019%2F10%2F06%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[函数式接口与方法引用前言之前我们说到了Java8中的一个新的特性，就是lambda表达式的使用，不过当时只是简单的了解了一下，没有与Java8中其他的新的特性做一个全面的了解。这里我们要到的Java中的函数式接口和方法引用就是Java8种新增加的东西，而且这两个新东西和lambda表达的式的联系还非常的密切。 什么是函数式接口之前说了和其他的编程语言不同的是，Java是一门非常面向对象的语言，对象在Java的世界中就是最重要的玩意。其他语言中的lambda表达式都是一种函数，而Java中的lambda表达式不是函数，之前我们说过了是一种依赖于接口的一个玩意。作用和匿名内部类非常的相似。（其实lambda这个玩意就是Java抄袭其他的语言的，其他的语言基本上很早就有了，而且大家都非常喜欢用，那Java可不要趁一波“热度“嘛。不过热度也不能瞎趁，其他的语言之中，函数的地位其实才是老大，比如说python就是一门函数式的原因，Java是一门对象为中心的语言，那么lambda表达式代表的就是一个对象。）上面扯多了，不瞎扯这个玩意了。先回到正题。 不过lambda表达式依赖的接口是有一定的条件的。他必须是只一个函数需要我们来实现。比如说新建一个线程的Runnable接口中只有一个函数run()需要我们实现。这样的接口就可以使用lambda。使用的方法如下。 Runnable a = () -&gt; System.out.println(&quot;Hello World&quot;); 其实这样的接口就是所谓的函数式接口，也就是所有的只有一个抽象函数需要实现的接口就是函数式接口。Java8种函数式接口的上面有一个注解(就像重写父类的方法的注解@override一样)叫做@FucntionalInterface。比如我们要写一个函数式接口 @FunctionalInterface interface A{ void func(); } 当然这个@FunctionalInterface不加也是可以的，就像你函数重写不加@override也是对的，毕竟这个玩意只是一个注解。不过还是要明白加上去的含义是什么的。 那么我们现在就可以说清楚Java当中的lambda表达式是一个什么东西了。lambda表达式就是函数式接口是实例。lambda表达式的存在必须要依赖于函数式接口，不过虽然lambda表达式是一个对象，但是他的作用相当于是一个函数。就像c++当中的仿函数一样，虽然是一个对象，但是是可以调用的，作用也是相当于一个对象。其实C++中的lambda表达式虽然说是一个函数，不过实际上也是一个对象——std::function，所有的可调用的变量都可以是这个std::function，其本质上也是一个类，也就是仿函数Function Class。 函数式接口的作用那么说了那么多没用的废话，这个函数式接口的作用到底是什么呢？仅仅是给了一个定义？？ 我们都知道OOP是面向对象编程的意思。其实今年来又兴起了一种的新的编程的方式——OOF面向函数编程。函数式接口的存在使得Java也可以进行OOF的编程方式。我们可以将函数式接口作为参数，然后使用lambda表达式进行参数的传递。 @FunctionalInterface interface A{ void func(String str); } public void test1(String str, A a) { a.func(str); } 看上面的代码，我们定义了一个函数式接口，然后将这个接口作为函数test1()的参数传入。然后再我们使用test1()函数的时候就可以指定不同的函数来做不同的事情。比如说 @Test public void test2() { String str = &quot;Hello World&quot;; test1(str, new A() { @Override public void func(String str) { System.out.println(str.toUpperCase()); } }); } 使用这种方式，我们使用了一个匿名内部类传递了我们需要是使用的函数，使得给定的字符串变成全是大写的。不过之前我们说的是可以使用lambda表达式的方式进行参数式的传递，下面就使用lambda表达式来试一下。 test1(str, s -&gt; System.out.println(s.toLowerCase())); 使用lambda表达式的话只需要一行的代码而且非常的简洁，这里lambda表达式的优点就充分的体现出来了。 不过说实话，这个写法还是非常的扯的，因为我们还定义了一个接口，要是每一个函数都要去定义一个相应的接口，那岂不是要烦死了。不过我们发现了一个问题，这些接口似乎都是通用的。比如说上面的这个接口中需要实现的方法是接受一个参数String，没有返回值的。那么其余的需要这种接口的函数都可以使用这个接口。那么我们需要的接口就是有限的，按理来说标准库是会提供这些接口给我们使用而不是让我们自己去定义的。 四大核心函数式接口果然，Java替我们提供了丰富的函数式接口，都在java.util.function这个包下。不过有四个接口是非常重要的，被称为四大核心函数借口，下面就来一一介绍一下。 函数式接口 参数类型 返回值类型 Consumer T void Supplier none void Function&lt;T, R&gt; T R Predicate T boolean 下面来一一介绍一下上面的四个接口。 Consumer&lt;T&gt; 消费型接口 名副其实，所谓的消费型接口就是接口里面的函数是需要提供一个参数，但是没有任何的返回值。就像我们消费了这个东西一样。 接口里面的抽象方法的格式为void accept(T t) 上面我们使用的那个接口其实就是一个Consumer&lt;String&gt;的一个接口。 Supplier&lt;T&gt;接口型接口 和上面的消费型接口相反，这个接口里面的函数不需要任何的参数，但是会返回一个东西。这个就是典型的雷锋行为啊。 接口里面的抽象方法的格式为T get() Function&lt;T&gt;函数型接口 这个接口应该是最常用的一个接口。他有一个参数，还有一个返回值，参数和返回值的类型不需要是相同的。 接口里面的格式为R apply(T t) Predicate&lt;T&gt;断定型接口 这个接口是给定一个参数，然后返回真假。也是比较常用的一个接口。 接口里面的函数的格式为boolean test(T t) 需要注意的是，上面我给出的每个接口里面的函数的格式并不是瞎给的。至少调用的话不是瞎给的，我们使用这个接口，都需要调用接口中的函数，函数名就是上面的那样，是固定的。 比如我们上面举的例子就可以使用第一个Consumer&lt;String&gt;这样的一个接口。 public void test11(String str, Consumer&lt;String&gt; consumer) { consumer.accept(str); } @Test public void test3() { String str = &quot;Hello Wrold&quot;; test11(str, s -&gt; System.out.println(s.toLowerCase())); } 遮掩我们就可以是用Java已经给我们定义好的接口了，可谓是非常的方便了。 其他的接口也是可以来简单的写个小例子来示范一下的。 public void testSpplier(String str, Supplier&lt;Integer&gt; supplier) { System.out.println(str + supplier.get()); } @Test public void test3() { testSpplier(&quot;Hello&quot;, () -&gt; new Random().nextInt(100)); } public void testFunction(String str, Function&lt;String, String&gt; function) { System.out.println(str + function.apply(str)); } @Test public void test4() { String str = &quot;Hello&quot;; testFunction(str, s -&gt; s.toUpperCase()); } public void testPredicate(int a, Predicate&lt;Integer&gt; predicate) { if (predicate.test(a)) { System.out.println(&quot;&quot; + a + &quot; is a great num!&quot;); } else { System.out.println(&quot;&quot; + a + &quot;is a bad num!&quot;); } } @Test public void test5() { int a = 10; testPredicate(a, s -&gt; (s &amp; 1) == 0); } 上面就是这些接口的使用的方法的一些示例。不过，说实话这个例子都是这种蛮沙雕的例子，完全是没有什么必要的。不过之二十为了演示函数式接口的使用的形式而已。 方法引用上面的函数式接口基本上就讲完了，其实也没有什么需要注意的地方。用起来也非常的容易理解。下面要说的Java8种的一个想你的特性——方法引用。这个东西也是和lambda表达式相关的，也是为了简化我们的代码。 方法引用的意思就是我们可以在需要lambda的地方，使用我们已经定义过的相同的形式的方法。这么说可能是非常难以理解，下面直接上代码进行演示好了。 public class MethodReference { @Test public void test1() { Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); consumer.accept(&quot;Hello World&quot;); } } 我写了如上的代码，但是非常智能的idea给我的System.out.println()标记了打了一个提示，说lambda can be replaced with method reference。那我就听他的话，是用万能的alt + enter快捷键，idea将我的代码修改了 public class MethodReference { @Test public void test1() { Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(&quot;Hello World&quot;); } } 这就是所谓方法引用。System.out.println()这个方法是System.out的一个方法。这个方法已经定义过了。当我们在lambda中使用的时候（值使用这个函数，其他不用），就可以使用方法引用的方式来替代lambda表达式。 @Test public void test2() { Comparator&lt;Integer&gt; comparator = (a, b) -&gt; Integer.compare(a, b); System.out.println(comparator.compare(3, 4)); } 上面的Comparator也是Java中的一个函数式接口，他的实现函数的格式为int compare(T a, T b) 上面的Integer.compare方法也是我们定义过了的方法。所以说上面的lambda表达式也可以修改成为方法引用。 @Test public void test2() { Comparator&lt;Integer&gt; comparator = Integer::compare; System.out.println(comparator.compare(3, 4)); } 上面就是使用方法引用的形式。 不过应该发现了一个问题，上面的System.out::println的::左面是一个PrintWriter对象，但是Integer::compare的左面是一个类。学过C++的应该都知道::的左面应该是类的。虽然Java可能不是的，不过我们也要搞清楚，左面到底应该是什么，是对象还是类？ 不过还是比较容易分析的。println是一个实例方法。而compare是一个对象的方法。众所周知类是不可以调用实例方法的，那么就是说实例方法的左面需要是类，而静态方法的左面类和对象都是可以的吗？就像函数调用那样子一样吗？ 那我们来做一些测试。我们将System.out::println换成了PrintStream::println之后发现报错了。不过也容易理解，没有System.out，我们都不知道往哪儿去输出。 我们再来测试一下使用左面是对象，右面是静态方法的情况。 @Test public void test2() { Integer i = new Integer(3); Comparator&lt;Integer&gt; comparator = i::compare; System.out.println(comparator.compare(3, 4)); } 又失败了。不过这是报错是出乎我们的意料的。对象是可以调用静态方法的啊，那为什么这种失败了呢？这是不是就是意味着方法引用只有如下的两种形式？ 对象::实例方法和类::静态方法。 因为其余的两种形式我们都测试过了。不过经过查阅资料，其上还有一种方式是可行的。类::实例方法也是可行的。 哈？这个也是可行的？不是上面我们已经测试过了吗？不是不可行的嘛？ 其实实例方法的引用是有点儿特殊的。上面的对象::实例方法和类::静态方法都是比较简单。只要满足参数相同，返回值相同就是可以调用的。但是使用类::实例方法不一样。他的参数必须要是调用对象的参数，方法的其他参数。举个例子来说吧。 @Test public void test3() { BiPredicate&lt;String, String&gt; biPredicate = (x, y) -&gt; x.equals(y); System.out.println(biPredicate.test(&quot;hello&quot;, &quot;Hello&quot;)); biPredicate = String::equals; System.out.println(biPredicate.test(&quot;Hello&quot;, &quot;Hello&quot;)); } 比如上上面的代码都是正确的。上面的那个BiPredicate也是java.util.function下面的一个接口。他的实现函数的形式为boolean test(T t, U u) 上面的那个lambda比较容易理解。不过下面的方法引用是不是有点奇怪了？是用的是类::实例方法的形式。关键是equals()方法在类中的声明如下 public boolean equals(String s); 参数是不匹配的。这就是我们需要注意的地方。当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时，可以使用类::实例方法的形式。 也就是PrintStream::println这个函数可以实现的函数式接口为Biconsumer&lt;PrintStream, String&gt;,第一个参数是println函数的调用对象(比如说System.out)。第二个参数是String，就是输出的内容。(也可以是其他可以输出的类型)。 构造器引用和数组引用除了方法引用之外还有构造器引用和数组引用，其实都是一样的不需要再说那么多了也可以轻松的理解。 下面来举一个简单的小例子就行了。 @Test public void test4() { Supplier&lt;A&gt; supplier = () -&gt; new A(); supplier = A::new; Function&lt;Integer, A&gt; function = i -&gt; new A(i); function = A::new; } class A { A() { } A(int a) { } } 其实构造器也是一个方法，如果使用方法引用的话，按道理来说应该写成A::A，不过人家构造器是特殊的方法，当然要有特殊的形式，使用的是xx::new的形式。 还有一种引用是数组引用。这中引用就是比较特殊的了，不过和构造器引用却是比较类似的。比如下面的代码 @Test public void test5() { Function&lt;Integer, String[]&gt; function = s -&gt; new String[s]; function = String[]::new; System.out.println(function.apply(6)); } 这就是数组引用，和构造器引用是有点儿类似的，简单的了解一下就好了。 总结上面介绍的主要是函数式接口和方法引用。这两个东西都是跟随lambda在Java8中被引用的。虽然他们不是Java8种比较重要的特性，不过还是需要做一些了解的。Java8种最重要的特性是lambda和StreamAPI。其中lambda我们已经简单的认识过了，下面还需要了解一下StreamAPI的使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说枚举]]></title>
    <url>%2F2019%2F10%2F05%2F%E8%AF%B4%E8%AF%B4%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[说说枚举关于前几天好几天都没写博客了，这不是因为这几天国庆放假都在宿舍里面睡觉，而是前几次的研究竟然是研究到了爬虫的领域。导致我又燃起了学习python的欲望，结果学了不少有关python爬虫的内容。本来只是 打算简单的学习一下的，但是我要爬取的网站比如说半次元这个网站，使用的是异步加载的机制(当时我还不知道啥叫ajax和json的异步加载的机制，也不知道这个网站竟然将json文件藏在了js文件中)，所以我就进一步的进行了有关python爬虫的学习，以至于学到了后面的selenuim自动化测试的软件，这还不是最骚的。然后我还是进行了学习，直接学习到了python的爬虫的大型的框架scrapy。学到了这个地方我就感觉应该是比较困难花时间的了，于是简单的学习了一下就放弃了。至于为什么之前学习的python爬虫的内容没有写博家，那当然是因为我对这方面的知识也是一知半解的，根本就搞不透，现在也不想花时间在这个上面，所以说等之后可以花时间研究这个方面上。现阶段还是一学习java为重。 前言枚举这个玩意其实在我而已是蛮没用的东西。从c/c++开始，我们就接触到了枚举这个玩意，不过事实上，我从来都没有使用过枚举这个玩意。我们或许是使用#define xxx xxx或许是使用const xxx xxx = xxx。很少有人去使用枚举这个玩意的。毕竟在c/c++中，枚举也就是int值，我们既然可以使用枚举，也就是可以使用int值来进行替代。而且，不同的枚举之间都是可以比较的，看起来确实是有点儿荒唐。不过Java中的枚举似乎是和我们之前学过的有点儿不一样。因为Java中枚举是一个类，这就避免了不同的枚举类之间荒唐的相互赋值，以及int值对枚举的替代的问题了。 Java中的枚举是什么样子的类？上面我们已经说过了，Java为了避免C/C++那样的问题，将枚举做成了一个类。不过这个枚举到底是一个什么样子的类呢？ 我们可以先来定义一个简单的枚举来测试测试。 enum Season{ SPRING, SUMMER, AUTUMN, WINTER } 使用上面的这种方式，我们就定义了一个季节的枚举。如果这是c++的话，他们四个也就是对应了0 1 2 3。那么在Java中我们可不可以指定给他们对应的int值呢？明显是非法的。 enum Season{ SPRING = 1, SUMMER, AUTUMN, WINTER } 后面全都报错了，这说明在Java中我们是没有办法给枚举赋值的。 那么这个枚举类是如何使用的呢？这个枚举类中的四个枚举似乎是没有修饰符的，是不是想接口那样，给定了默认的修饰符呢？比如说这些属性默认就是public static final的？？？ 我们先来看一下枚举类的使用 public class Demo1 { public static void main(String[] args) { Season s1 = Season.SPRING; Season s2 = Season.AUTUMN; System.out.println(s1 == s2); // false } } 可见我们使用枚举，就像使用枚举类的静态成员变量一样。那么通过上面的代码我们就可以知道了，枚举中的枚举变量的类型应该是public static final Season。至于为什么是final呢？我想这个很容易明白，如果不是final的话。一处被修改了，那么所有的使用这个枚举的类的地方不就都遭殃了吗？而且，似乎我们并没有要修改这个枚举类的必要。 既然我们已经知道了他的限定符了，那么我们是不是就可以想接口那样给他直接加上这些限定符呢？？ 答案是显然不能的，这些枚举似乎不是想接口哪样的值一个定义。这些SPRING已经是有值的了。不过这写玩意是如何实现的呢？当然不是这个枚举类实现的。枚举是一个类，那么他是否有父类呢？ 对了，前面我们使用了==，我们可以使用equals方法看一看。 System.out.println(s1.equals(s2)); 使用idea的方法源码查看，发现这个方法是来自java.lang.Enum这个类的，这就说明了，所有的枚举类都是继承于这个类的，不然怎么可以使用这个类的方法？ java.lang.Enum中的方法还是从官方的文档中看一看这个类。 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; extends Object implements Comparable&lt;E&gt;, Serializable 这个类的声明似乎是有点儿奇怪，不过看一下他的构战函数。 protected Enum(String name, int ordinal) // 唯一的构造函数。 唯一的构造函数都是私有的说明这个类没有办法被继承的（通过extends方式）。enum声明的类的基础肯定是通过底层实现的。 protected Object clone() // 抛出CloneNotSupportedException。 int compareTo(E o) // 将此枚举与指定的对象进行比较以进行订购。 boolean equals(Object other) // 如果指定的对象等于此枚举常量，则返回true。 protected void finalize() // 枚举类不能有finalize方法。 class&lt;E&gt; getDeclaringClass() // 返回与此枚举常量的枚举类型相对应的Class对象。 int hashCode() // 返回此枚举常量的哈希码。 String name() // 返回此枚举常量的名称，与其枚举声明中声明的完全相同。 int ordinal() // 返回此枚举常数的序数（其枚举声明中的位置，其中初始常数的序数为零）。 String toString() // 返回声明中包含的此枚举常量的名称。 static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(class&lt;T&gt; enumType, String name) // 返回具有指定名称的指定枚举类型的枚举常量。 上面是这个类中的所有的方法。官方文档中对这个类的并没有什么描述，只是说这个类是所有的枚举的公开基类。下面我们就通过上面的这些方法来研究一下Java中枚举。 可以看到上面的方法都是子类中可以使用的。 第二个方法令我比较好奇，既然枚举不和int值挂钩，又是如何实现比较的呢？ System.out.println(s1.compareTo(s2)); // -2 输出-2。嗯，这个倒是和c/c++中一摸一样。不会枚举的内部也是对四个属性进行0 1 2 3这样的排序的吧。瞎的我感觉看了一下这个方法的源码。 public final int compareTo(E o) { Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } 上面的那么多是用来判断是否是一个枚举类的。不同的枚举类之间是不能够进行比较的。不过关键是最后一行代码。 return self.ordinal - other.ordinal; ordinal是序数的意思，看来我们猜想的是对的，在枚举的内部也还是将枚举和一个int值挂钩的。我们可以看到方法的列表中也是有int ordinal()方法的。 System.out.println(s1.ordinal()); // 0 System.out.println(s2.ordinal()); // 2 完全符合我们的猜想。也就是这个序数其实就是枚举中声明的序数。不过我们是否是可以改变这个序数呢？就像c/c++中我们做的那样一样。（虽然这个是完全没有一意义的）这个问题我们可以在下面再讨论。 我们继续来看枚举类的方法。 首先一眼看到的方法就是toString()方法。这个方法是Object中就有的，声明如下 public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); } 枚举类中将这个方法从重载了，我们可以实验一下会输出什么东西。 System.out.println(s1); // SPRING 输入的就是我们给定的枚举类的名字。这又是如何实现的呢？再来看一下这个方法的源码的实现。 public String toString() { return name; } 上面也有一个方法叫name()看来和ordinal一样这个属性也被枚举类给保存下来了。 还有一个方法是我们需要了解的。valueOf System.out.println(Season.valueOf(&quot;SPRING&quot;) == Season.SPRING); // true 作用是返回和这个名字相同的枚举变量。上面我们已经知道了，这个名字其实就是name属性。这里的比较使用的==，其实使用equals()也是一样的。毕竟这个枚举的都是唯一实例，无论是比较内容还是地址都是一样的。何况这个类中的equals()方法都相当于没有重载。==与equals是一样的。 public final boolean equals(Object other) { return this==other; } 其实还有一个很重要的方法，是父类没有的。就是values()方法。这个方法的作用是返回枚举类中的所有的枚举变量。 Season[] seasons = Season.values(); for (Season season : seasons) { System.out.println(season); } // SPRING // SUMMER // AUTUMN // WINTER 根据推测方法的声明可能是这样子的。 public Season[] values(); 数组中枚举的顺序就是他们ordinal的顺序。 这让我想到一个问题，既然valueOf方法可以通过name属性获取到枚举值，我们是否可以通过ordinal属性来获取属性的值呢？很遗憾，Java中并没有提供这样的函数，不过我们可以通过values方法来写一个这样的方法。 枚举中的方法其实上面我们一直在谈的都是枚举中的方法。不过我们似乎谈论的大多是枚举类中自带的方法。那我们是否可以在其中写一些方法呢？当然是可以的。比如上面我们说到的通过ordinal属性来获取枚举值。 enum Season{ SPRING, SUMMER, AUTUMN, WINTER; // there is ; public static Season valueOf(int ordinal) { Season[] seasons = values(); if (ordinal &lt; 0 || ordinal &gt;= seasons.length) { throw new IndexOutOfBoundsException(&quot;Ordinal is out of range!&quot;); } return seasons[ordinal]; } } 第一个点需要注意的是枚举变量之间使用的逗号相隔。如果我们要在枚举中写方法的时候，我们需要使用一个分号想方法和定义的枚举型变量隔开。 上面就像使用类一样定义了一个方法。而且经过测验之后也是满足我们的需求的。既然我们可以在枚举类中定义自己的方法。那么自己的属性也必然是可以的。只要在分号的后面就可以了。不仅如此，我们还可以重载枚举中的方法。比如toString()方法。 @Override public String toString() { return &quot;my toString: &quot; + super.toString(); } 这样我们便override了toString方法。 现在我们再回到上面的问题来，valueOf(int ordinal)方法对不对呢？看起来是对的。因为ordinal就是从0开始的。在java.lang.Enum中，ordinal的定义如下 private final int ordinal; 也就是ordinal一经初始化之后便不可以被修改了。不过我们是否可以操作一下ordinal的初始化呢？ 枚举变量的构造函数前面我们一直都忽略了一个细节，那就是java.lang.Enum的构造函数。我们继续来观察一下。 protected Enum(String name, int ordinal) // 唯一的构造函数。 这个构造函数有两个参数name和ordinal。嗯？是不是有点儿熟悉~~那么我们是否可以通过构造函数指定枚举变量的name和ordinal呢？ 看起来是不可以的，我们似乎都接触不到这个构造函数。而且ordinal在java.lang.Enum中的声明是私有的，我们更不可能修改到这个ordinal属性了。不过我们是否是可以修改name属性呢？相同的，我们也是不可以的。因为没有构造函数，属性还是私有的。可见这个方法是正确的。 不过枚举类是否可以拥有自己的构造函数呢？ private String name; private int ordinal; Season(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } 我们发现是真的可以的，构造函数并没有报错，但是上面的那些枚举变量却报错了。经过查阅资料，我们需要使用如下的形式来调用构造函数。 SPRING(&quot;春天&quot;,1), SUMMER(&quot;夏天&quot;,2), AUTUMN(&quot;秋天&quot;,3), WINTER(&quot;冬天&quot;, 4); 原来如此，如果我们在后面没有使用括号，也就是一开始的写法的话就是调用无参的构造函数，如果有参数的话就会寻找相应的参数的构造函数。也就是说其实枚举就是这样的一个普通的类。 class Season extends java.lang.Enum{ public static final Season SPRING = new Season(&quot;春天&quot;,1); public static final Season SUMMER = new Season(&quot;夏天&quot;,2); public static final Season AUTUMN = new Season(&quot;秋天&quot;,3); public static final Season WINTER = new Season(&quot;冬天&quot;,4); private String name; private int ordinal; Season(String name, int ordinal){ this.name = name; this.ordinal = ordinal; } } 上面只是实现的一个例子，我们自然是不可以写出这样的类的。首先继承java.lang.Enum就是一个不可能的事情。不过上面的代码清晰的表现了枚举类的简单的原理。这里我没有使用反编译。毕竟我也不会反编译的手段。不过不使用反编译，我们也可以大概猜出枚举类的结构了。 不过，还有一个非常大的问题。上面的枚举类中我没有使用限定符access modifier。没有使用限定符那么就是default，也就是包可访问的。那么我们可以在类外使用枚举类的构造函数？ Season s = new Season(&quot;xxx&quot;,5); 报错了，报错信息显示这个构造函数是access private的，这里不可以访问。 可见，枚举类的构造函数必然是private的。就比如接口中的函数，即使是什么限定符都不加，他也是public abstract的，这里的构造函数如是。 枚举的继承以及枚举中的抽象函数枚举是继承java.lang.Enum的。这就决定了枚举是不可以继承其他类的，同样的其他类也是不可以继承枚举的。(至于为什么，这不用说也应该可以明白吧)。 不过，虽然枚举类不可以被继承，但是枚举类中，还是允许存在抽象的方法的。这就很令人不解了？既然不可以被继承，那么抽象方法的意义何在呢？ 当我们写下了这个抽象方法的时候，编译器给了一个提示。 class ”Season“ must either be decleared abstrace or implememt abstract method “func” in Season 不过当我使用abstract enum Season的时候他说abstract is not allowed here那这个的意思是自己要实现自己定义的抽象的方法。这也太没道理了吧。 不过更没想到的是，原来是需要这样去实现抽象方法的。 SPRING(&quot;春天&quot;,1){ @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, SUMMER(&quot;夏天&quot;,2){ @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, AUTUMN(&quot;秋天&quot;,3) { @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, WINTER(&quot;冬天&quot;, 4) { @Override public void func() { System.out.println(&quot;Season.func&quot;); } }; 也就是说需要枚举类的属性来实现这个抽象的方法。这个形式，是不是有一点眼熟，没错就是匿名内部类的格式。这些函数在外面都是可以调用的。比如说Season.SPRING.func()。 这个东西之前我们说过的其实匿名函数实现接口，内部是产生了一个类。那么上面的实现抽象函数的过程中是否产生了新的类呢？ 我们可以在func()使用getClass()方法。 class com.sher.enumDemo.Season$1 看来果然是产生一个新的类。哇~，这个枚举中的奥秘也太多了吧。 System.out.println(Season.SPRING.getClass()); // class com.sher.enumDemo.Season$1 System.out.println(Season.AUTUMN.getClass()); // class com.sher.enumDemo.Season$3 在我们之前没有使用抽象函数，以及实现的时候。使用上面的函数输出是 System.out.println(Season.SPRING.getClass()); // class com.sher.enumDemo.Season System.out.println(Season.AUTUMN.getClass()); // class com.sher.enumDemo.Season 正是由于实现了抽象函数所以才产生新的类的。不过这里又来了一个问题。Season.SPRING和Season.AUTUMN的类型不一样了，一个是Season$1,一个是Season$3。按照我们之前的说法，不同的类之间是不可以比较的，因为他们都不是同一个枚举类了。之前似乎说过了一个函数compareTo()，还看过了这个的源码，现在我们在来看一看。 public final int compareTo(E o) { Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } 上面判断的时候，使用了getDeclaringClass()这个函数。而Season$!和Season$3的DeclaringClass都是Season，原来是用这种方式保证枚举的相同类型的。所以说，如果我们要看枚举类型是否相同，其实看getDeclaringClass()就行了，毕竟如果getClass()想同，getDeclaringClass()也是相同的。 枚举与接口虽然我们说由于Java中单继承的机制，枚举是无法继承其他的类的，但是Java中对与接口的实现是没有限制的，所以说枚举类还可以实现接口。不过这里需要注意的是，并不是枚举这个类要实现接口中的函数，而是枚举中每一个枚举变量要实现接口中的函数。比如说有一个接口A interface A{ void aFunc(); } enum Season implements A{ SPRING(&quot;春天&quot;,1){ @Override public void aFunc() { System.out.println(&quot;Season.aFunc&quot;); } @Override public void func() { System.out.println(&quot;Season.func&quot;); System.out.println(this.getClass()); } }, SUMMER(&quot;夏天&quot;,2){ @Override public void aFunc() { System.out.println(&quot;Season.aFunc&quot;); } @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, // ... 可见枚举中接口的实现是和普通的类不一样的。 除此之外，枚举和接口还有另外的一个搭配。那就是在接口中组织枚举。 这个挺起来似乎是有点儿荒唐，接口中怎么能有枚举呢？不过确实如此，可以有这样的语法。 如果我们需要将枚举类进行分组的话就可以使用这种方式。比如食物是一个枚举中的大类别，其中又可以分为甜的，酸的，辣的等等等。又比如说班级中中国学生，也有外国学生，我们想要保留他们都是学生的这个共同属性而又想要分别枚举就可以使用接口来组织枚举。 interface Student { enum ChineseStudent implements Student { ZHANG3(1), LI3(2), WANG5(3); @Override public boolean same(Student s) { if (s instanceof ChineseStudent) { return true; }else { return false; } } ChineseStudent(int a){ } @Override public void printName() { System.out.println(this.name()); } }; enum ExchangeStudent implements Student { JACK, MIKE, TOM; @Override public boolean same(Student s) { if (s instanceof ExchangeStudent) { return true; }else { return false; } } @Override public void printName(){ System.out.println(this.name()); } } boolean same(Student s); void printName(); } 其中接口中的方法，每一个枚举类中都要实现。这里的接口实现和枚举类实现接口那样，不再是每一个属性都要实现了。通过这种方式，中国学生和交换什都保有了Student这样的一个共同的属性，而且还是分别的枚举了。 和普通的接口一样，这个接口也可以被实现。不过只需要实现接口中的那两个函数就行了。 class B implements Student { @Override public boolean same(Student s) { return false; } @Override public void printName() { } } 不过需要注意的是，这时的枚举可以通过上面的类B访问到。比如 Student s = B.ChineseStudent.ZHANG3; 上面就是使用接口来组织枚举的简单的用法，至于更复杂的用法，这里暂时就不做更多的了解了。 枚举与单例模式前面我们介绍了单例模式，在我们学习内部类的时候，我也提到了使用静态内部类的方式来实现单例模式的懒加载。不过在我们详细的谈论单例模式的时候，我们还谈到了一种使用枚举来实现的单例模式。 public class SingletonTest04 { public static void main(String[] args) { Singleton04 singleton1 = Singleton04.INSTANCE; Singleton04 singleton2 = Singleton04.INSTANCE; System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } enum Singleton04 { INSTANCE; } 这种方式是真的简单又粗暴。不仅可以解决多线程的同步问题，也可以防止反序列化创建新的对象。这种方式也是《Effect Java》中推荐的方式。不过这个代码也是有一定的问题的，比如说无法进行懒加载。如果一点问题都没有，这个单例模式可不是十全十美了嘛~~ 总结上面算是对Java中的枚举类的一个比较全面的一个学习了。不过都基本上是简单的介绍，并没有深入底层追究一些细节上面的东西，毕竟那玩意放到现在来说确实是有点儿复杂了。 主要参考文章:重新认识java（十） —- Enum（枚举类）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用lxml和bs4进行爬虫]]></title>
    <url>%2F2019%2F10%2F02%2F%E4%BD%BF%E7%94%A8lxml%E5%92%8Cbs4%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[使用lxml和bs4进行爬虫前言前面其实是学Java的过程中学到正则表达式的，然后结合之前学的IO流来练习一下使用Java进行爬虫。而且我们使用的爬虫的工具还是python爬虫三大工具中最难的——正则表达式。这就让我有点好奇还有两个爬虫的工具是怎么用的了。这里就使用上次的爬虫的例子来简单的介绍一下吧。 使用lxml其实这个东西应该是叫XPath吧，其实我也不是很清楚，不过用起来还是蛮简单的，尤其是学过了一点点前端之后。使用lxml和bs4真的是如鱼得水，好用得不得了。 之前我们使用python进行爬虫的时候使用的是urllib.request这个库，不过现在requests应该是最适合的，因为requests库的api非常的人性化而且也非常的好用。不过问题就是这个库是需要我们去下载的，原生的python是没有这个库的。我们可以使用pip install requests或者python -m pip install requests来安装这个库。lxml也是如此，我们可以使用上面相同的方式来获取到这个库。因为只是简单的介绍，所以我也不会有过多的说明，所以说直接上代码吧。 首先看一下requests的使用。 HEADERS = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } def getUrlText(url): response = requests.get(url, headers=HEADERS) text = response.content.decode(&quot;utf-8&quot;) return text 我们再重新来看一下urllib.request的使用 def getUrlContent(url): headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } req = request.Request(url, headers = headers) resp = request.urlopen(req) urlContent = resp.read().decode(&#39;utf-8&#39;) return urlContent 可以看到requests库的确是方便多了。 requests.get值得就是向目标url发出get请求，相同的requests.post就是发出post请求，这一点上比urllib中的容易理解。对于相应后的返回值，有两个方法是需要注意一下的。response.content返回的是字节码，我们可以通过观察网站的charset手动调用decode()方法进行解码。还有一个方法是response.text返回是字符串，是python通过猜测给我们解的码，所以说这个方法很有可能会出现乱码(真的是一个弟弟方法)，所以说我个人还是习惯于使用response.content。 既然目标网站的源代码我们已经搞过来了，下面一步就是来提取有用的信息了，之前使用的是正则表达式，这里使用lxml。 def getImgSrc(text): html = etree.HTML(text) div = html.xpath(&quot;//div[@class=&#39;content_nr&#39;]&quot;)[0] srcs = div.xpath(&quot;.//img/@src&quot;) return srcs 就简单的几行代码。第二行代码使用etree来加载这个源代码。(其实是lxml.etree，只不过我们使用了from lxml import etree而已)，然后返回了一个对象。我们可以对这个对象使用xpath语法。 下面就简单的说说xpath语法。 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 通过在路径表达式中使用“|”运算符，可以选取若干个路径。 上面就是XPath的一些简单的语法。下面就看着这些语法来看看下面的两行代码。 div = html.xpath(&quot;//div[@class=&#39;content_nr&#39;]&quot;)[0] //div[@class=&#39;content_nr&#39;]是选取class属性为content_nr的div节点，虽然这个节点在网站上只有一个，不过依旧还是返回一个列表。我们也可以在XPath选取的时候就选择第一个，不过要注意的是，这个位置竟然是从1开始的。不过这里我们是不可以写到里面去的，因为里面我们已经加上了一个class 的限定条件了，不可以在后面继续使用[]表示第几个了。 srcs = div.xpath(&quot;.//img/@src&quot;) 我们已经得到了存放许多图片链接的div，其中图片的链接都是在div里面的img标签的src属性下。 这是我们使用的是.//img而不是//img，这是因为此时指定XPath的已经不是html了而是我们选取的div，如果还是使用//img，那么还是会选取到网页中的所有img标签。后面的/@src指的就是选取img标签的src属性，返回值也是一个列表，是一个src里面地址字符串的列表，这就很舒服了~~ 下面下载图片的事情就简单了。 def urlRetrieve(url, destFilename): with open(destFilename, &#39;wb&#39;) as f: f.write(requests.get(url, headers=HEADERS).content) def downloadImgs(srcs, destDir): if not os.path.exists(destDir): os.makedirs(destDir) if not os.path.isdir(destDir): print(&#39;Error!! You must provide a Dir&#39;) exit() for i, src in enumerate(srcs): filename = os.path.join(destDir, str(i)+&#39;.&#39;+src.split(&#39;.&#39;)[-1]) urlRetrieve(src, filename) 模仿urllib库，我写了一个urlRetrieve函数(原函数是urllib.urlretrieve)。所谓下载图片就是将content字节流通过二进制的形式写入到文件当中就行了。 最后再把这些函数串起来就完事了。 def spider(url, destDir): text = getUrlText(url) srcs = getImgSrc(text) downloadImgs(srcs, destDir) 这样爬取单页的操作就完成了。其他的操作都是类似的，这里就不再研究了，只是简单介绍一下而已啦。 使用bs4bs4也是一个扩展库，需要我们使用pip install bs4或者python -m pip install bs4来安装，不过如果你安装了anaconda的话，上面的这些库你都不需要安装。直接自带的！~ bs4的使用和上面的lxml其实是差不多了。至于代码除了getImgSrc之外其余的代码都是相同的。所以说我们看一下getImgSrc()函数就完事了。 def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) div = soup.find_all(&#39;div&#39;, class_ =&#39;content_nr&#39;)[0] imgs = div.find_all(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs 在代码的开始我们使用from bs4 import BeautifulSoup导入这个库。 上面的第二行就是使用lxml解析器将网页的源代码解析成一个。。emm美味的汤？？算了，不管了，上面就是将源代码中的html代码整合成为一种树结构，便于后面的使用。 div = soup.find_all(&#39;div&#39;, class_=&#39;content_nr&#39;)[0] 就是寻找所有class属性为content_nr的标签，返回一个列表。至于为什么是class_是因为class在python中是保留字(类名)，不可以使用。不过我们也可以使用div = soup.find_all(&#39;div&#39;, attrs = {&#39;class&#39;:&#39;content_nr&#39;})这种方式。这时候我们就可以使用class了，因为这里的class是一个字符串。 imgs = div.find_all(&#39;img&#39;) 找到div所有的img标签 srcs = [img[&#39;src&#39;] for img in imgs] img[&#39;src&#39;]是获取img标签的src里面的值，使用上面的那种方式，可以将img标签列表转为一个src列表。其实获取属性还可以使用img.attrs[&#39;src&#39;]的方式，不过这个也是有点儿没事找事了。既然可以少写一点，为什么不少写一点呢？ 其实除了find_all()函数之外，BeautifulSoup还提供了CSS选择器的方式。上面的函数的代码还可以这样写。 def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) div = soup.select(&#39;div.content_nr&#39;)[0] imgs = soup.select(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs 使用CSS选择器也是一个蛮不错的方式。 还有一点需要注意的是，如果网页的代码非常不规范，使用lxml解析器会报错的话，我们可以使用容错性更高的解析器。不过效率肯定是更低了。 soup = BeautifulSoup(text, &#39;html5lib&#39;)。使用这也是需要安装html5lib这个库的，正如使用lxml解析器也需要安装lxml库。 下面给出完整的代码。 import requests import os from bs4 import BeautifulSoup HEADERS = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } def urlRetrieve(url, destFilename): with open(destFilename, &#39;wb&#39;) as f: f.write(requests.get(url, headers=HEADERS).content) def getUrlText(url): response = requests.get(url, headers=HEADERS) text = response.content.decode(&quot;utf-8&quot;) return text def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) # div = soup.find_all(&#39;div&#39;, class_ =&#39;content_nr&#39;)[0] # div = soup.select(&#39;div.content_nr&#39;)[0] div = soup._find_all(&#39;div&#39;, attrs = {&#39;class&#39;:&#39;content_nr&#39;})[0] # imgs = div.find_all(&#39;img&#39;) imgs = div.select(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs def downloadImgs(srcs, destDir): if not os.path.exists(destDir): os.makedirs(destDir) if not os.path.isdir(destDir): print(&#39;Error!! You must provide a Dir&#39;) exit() for i, src in enumerate(srcs): filename = os.path.join(destDir, str(i)+&#39;.&#39;+src.split(&#39;.&#39;)[-1]) urlRetrieve(src, filename) def spider(url, destDir): text = getUrlText(url) srcs = getImgSrc(text) downloadImgs(srcs, destDir) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/78680.html&#39; destDir = &#39;testBs4&#39; spider(url, destDir) 总结对于介绍的三种的数据提取的库，基本上可以这么说。 方式 速度 难度 Regex 最快 最难 lxml/XPath 一般 一般 BeautifulSoup 最慢 最易 不过也不出乎我的意料，哪有什么简单又快的呢？就像python一样，你觉得使用起来难度最小，速度肯定也是较慢的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用正则表达式来爬虫]]></title>
    <url>%2F2019%2F10%2F01%2F%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[使用正则表达式来爬虫前言在上面我们简单的了解了一下正则表达式的使用。其中最后的一个例子中我们讲的是使用正则表达式来匹配html中标签。我们或许可以使用这个功能来干一件大事——使用Java来爬一个简单的虫。这个是不需要任何库的那种，就是用Java中的IO流和强大的正则表达式。不过，我们需要爬取什么样子的网站呢？一开始就想到了我最爱的网站bilibili。那么说干就干吧。来爬一下bilibili。 爬取哔哩哔哩的失败URL url = new URL(&quot;http://www.bilibili.com&quot;); url.openStream(); 虽然上面的代码是没有写全的。不过现在代码已经是出错的了。要么是b站返给我一个极短的没有用的html代码，要么就是直接给我一个403 Error，403错误代表的是访问权限不足，拒绝访问。 有着python爬虫经验的我，一下子就想到了这特喵的肯定是User-Agent的问题，不过如果配置Java中的User-Agent却是一个问题，而且我爬b站好像没啥用啊。我突然想到我玻璃的封面的图片的来源地——萌娘资源站。每次我去里面搞图片的时候都是一张一张的右键另存为，这很是头疼！！经过我的访问，我发现这个网站竟然没有任何的反爬措施，果然小网站就是小网站啊，就决定是你了！！ P.S.: 后来我查阅了资料，找到了Java中设置User-Agent的方式，果然好烦啊！爬虫还是python好。。。 try { URL url = new URL(&quot;https://www.bilibili.com&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &quot; + &quot;(KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line = null; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } 爬取单页所有图片虽然我先把这个网址连的所有的图片全都爬取下来，但是咋还是得一步一步的来。首先下载一张图片这种操作应该就不用写了，所以就从爬取单页的所有的图片开始入手吧。 于是我从这个网页开始入手http://moe.005.tv/78680.html分析网页的结构。 首先，我们需要爬取的是图片。HTML应该都是学过的，图片的地址就是在&lt;img&gt;标签的src属性下。通过查看源代码和使用开发者检查工具，我发现了我想要爬取的内容源代码是这样子的。 &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150225T5.jpg&quot; style=&quot;width: 600px; height: 705px;&quot; /&gt;&lt;br /&gt; ID=76539261&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ215025Wc.jpg&quot; style=&quot;width: 600px; height: 920px;&quot; /&gt;&lt;br /&gt; ID=76539275&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150310O3.jpg&quot; style=&quot;width: 600px; height: 849px;&quot; /&gt;&lt;br /&gt; ID=76539289&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150322Z9.png&quot; style=&quot;width: 600px; height: 839px;&quot; /&gt;&lt;br /&gt; ID=76539340&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ21503334W.jpg&quot; style=&quot;width: 600px; height: 848px;&quot; /&gt;&lt;br /&gt; ID=76539357&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150419601.jpg&quot; style=&quot;width: 600px; height: 424px;&quot; /&gt;&lt;br /&gt; ID=76539479&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150434115.jpg&quot; style=&quot;width: 600px; height: 414px;&quot; /&gt;&lt;br /&gt; ID=76539479&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150449D4.jpg&quot; style=&quot;width: 600px; height: 424px;&quot; /&gt;&lt;br /&gt; ID=76540552&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150501231.jpg&quot; style=&quot;width: 600px; height: 896px;&quot; /&gt;&lt;br /&gt; ID=76546567&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150513612.jpg&quot; style=&quot;width: 600px; height: 600px;&quot; /&gt;&lt;br /&gt; ID=76549801&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150523104.jpg&quot; style=&quot;width: 600px; height: 847px;&quot; /&gt;&lt;br /&gt; ID=76557430&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150533627.png&quot; style=&quot;width: 600px; height: 891px;&quot; /&gt;&lt;br /&gt; ID=76563726&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ21505431R.jpg&quot; style=&quot;width: 600px; height: 718px;&quot; /&gt;&lt;br /&gt; ID=76573133&lt;br /&gt; 可以看到是一个单标签。其中我们真正需要的内容就是里面的src的网址，有了这些网址就相当于有了图片。 爬取网页的源代码不过首先我们需要的是来下载这个网站的源代码。之前也说过了这个网页是没有反爬虫措施的，所以我们可以直接进行访问下载。 private String getUrlContent() { BufferedReader br = null; StringBuilder sb = new StringBuilder(); try { br = new BufferedReader(new InputStreamReader(url.openStream())); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } 上面就是一个简单的IO流的操作，其实应该是写成一个工具类的，毕竟后面的代码中还要用到这个方法。不过已经写完了那就无所谓了。 使用正则表达式匹配链接上面的网页的源代码已经获得了，那么就需要使用到之前所学的正则表达式的知识匹配我们要的字符串了。 这里我写的表达式为&lt;img[^&gt;]*src=\&quot;(.+?)\&quot;.*?/&gt; 我将我要获取的连接放在了一个捕获组中(.+?)那么匹配玩之后我们就可以直接获取这个链接了。 关于上面的表达式其实还有一个问题，为什么我写的表达式这么简洁，不会匹配到其他的没有用的图片吗？还真的不会，我发现其他的无关的图片虽然前面多事满足的，但是结尾都是没有/的就是&lt;img ...&gt;。所有的我需要的图片都是&lt;img ... /&gt;类型的，所以说这就很舒服的嘛！ private List&lt;String&gt; getImgUrl() { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); String urlContent = getUrlContent(); Pattern pattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;(.+?)\&quot;.*?/&gt;&quot;); Matcher matcher = pattern.matcher(urlContent); while (matcher.find()) { String urlImg = matcher.group(1); if (urlImg.contains(&quot;dilidili&quot;)) { break; } if (urlImg.matches(&quot;http://.+?.(jpg|png)&quot;)) { list.add(urlImg); } } return list; } 上面我使用了一个List来存放这些图片的链接。不过需要注意的是，链接中有dilidili的链接都是无法访问的，所以说直接剔除就好了。(莫非dilidili凉了？？) 下载图片上面已经获取到了所有的图片的连接了，下面只要运用之前学的IO流的知识来下载图片就行了。 public void downloadImg() throws Exception { List&lt;String&gt; list = getImgUrl(); int i = 1; BufferedOutputStream bos = null; BufferedInputStream bis = null; for (String img : list) { String suffix = img.substring(img.length() - 4); File file = new File(dest, &quot;&quot; + i + suffix); bos = new BufferedOutputStream(new FileOutputStream(file)); bis = new BufferedInputStream(new URL(img).openStream()); byte[] buffer = new byte[1024]; int cot; while ((cot = bis.read(buffer))!=-1) { bos.write(buffer,0, cot); } bos.flush(); System.out.println(&quot;Download Complete: The &quot;+i+&quot; Img&quot;); i++; } bis.close(); bos.close(); } 首先是文件名字的问题，既然网站上也没有名字，那我就直接使用数字命名大法吧，问题应该不大。 还有一个问题就是文件的后缀名的问题，经过上面的观察，这些图片不是jpg格式就是png格式，那么我只需要取最后的四位就可以得到图片的类型了。 后面就是IO流的操作了，这里就不说了。 爬取一整页的图片经过我的观察这个网站中的源代码的格式基本上都是一模一样的。（那肯定的啊，没有框架写个锤子的网站）经过上面的努力，现在给我们任何一页的的链接，我们就可以下载这一页中的所有的图片。 于是现在我们的任务就是获取一整页中所有页的链接。还是之前获取图片的链接那样一样的操作。观察一下网页中我们需要的部分的源代码。 &lt;a href=&quot;http://moe.005.tv/78680.html&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;zt_pic&quot; style=&quot;background-image:url(http://www.005.tv/uploads/190902/66-1ZZ2151605B7.jpg);&quot;&gt;&lt;img src=&quot;http://www.005.tv/uploads/190902/66-1ZZ2151605B7.jpg&quot;&gt;&lt;em&gt;初音未来插画图片&lt;/em&gt;&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;zt_dep&quot;&gt; &lt;strong&gt;&lt;a href=&quot;http://moe.005.tv/78680.html&quot;&gt;初音未来插画图片&lt;/a&gt;&lt;/strong&gt; &lt;dl&gt; &lt;dt&gt;2019-09-02&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont&quot;&gt;&lt;/i&gt;68&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;初音未来插画图片...&lt;/p&gt; &lt;/span&gt; &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;http://moe.005.tv/78638.html&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;zt_pic&quot; style=&quot;background-image:url(http://www.005.tv/uploads/190822/66-1ZR2143A1X1.jpg);&quot;&gt;&lt;img src=&quot;http://www.005.tv/uploads/190822/66-1ZR2143A1X1.jpg&quot;&gt;&lt;em&gt;【今日P站】热门插画0822&lt;/em&gt;&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;zt_dep&quot;&gt; &lt;strong&gt;&lt;a href=&quot;http://moe.005.tv/78638.html&quot;&gt;【今日P站】热门插画0822&lt;/a&gt;&lt;/strong&gt; &lt;dl&gt; &lt;dt&gt;2019-08-22&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont&quot;&gt;&lt;/i&gt;3704&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;【今日插画】P站热门插画0822...&lt;/p&gt; &lt;/span&gt; &lt;/li&gt;&lt;li&gt; 上面是网页的源代码的一部分。观察一下，我们需要的链接在两个地方都出现了，上面的&lt;a href=&quot;&quot;&gt;中有我们需要的链接，下面的&lt;strong&gt;中的&lt;a href=&quot;&quot;&gt;也有我们需要的内容。不过下面的a中还有我们更想要的东——图片的名字。这么说或许有点儿不妥，应该说是文件夹的名字，这里图片是没有名字的。 爬取网页的源代码的操作和上面就是一模一样的，所以这里不再赘述。 使用正则表达式匹配链接这里我使用的正则表达式是&lt;strong&gt;&lt;a href=\&quot;(http://moe.005.tv/\\d{5}\\.html)\&quot;&gt;(.*?)&lt;/a&gt;&lt;/strong&gt; 这里因为我需要的有网页的链接还有名字这两个属性，所以我使用了两个捕获组，而且为了防止误匹配，其实链接的变化只是后面的五个数字，所以我直接精确的进行匹配，不搞那些.*了。 private void getLink() { List&lt;String&gt; list = new ArrayList&lt;&gt;(); String urlContent = getUrlContent(); Pattern pattern = Pattern.compile(&quot;&lt;strong&gt;&lt;a href=\&quot;(http://moe.005.tv/\\d{5}\\.html)\&quot;&gt;(.*?)&lt;/a&gt;&lt;/strong&gt;&quot;); Matcher matcher = pattern.matcher(urlContent); while (matcher.find()){ linkList.add(matcher.group(1)); nameList.add(matcher.group(2)); } } 这里用了两个List，不过没法返回两个List。我就将这两个LIst作为私有属性而不是函数的返回值。 下载整页图片上面我们已经获取了每一页的链接以及名字，我们就可以利用上面写好了的下面单页用的类进行下载了。这真的棒棒哒！ public void downloadImg() { getLink(); for (int i = 0; i &lt; linkList.size(); i++) { SpiderImg splitImg = new SpiderImg(linkList.get(i), dest+&quot;/&quot;+nameList.get(i)); try { System.out.println(&quot;=====Download Start: &quot;+nameList.get(i)+&quot;=====&quot;); System.out.println(); splitImg.downloadImg(); System.out.println(&quot;=====Download Complete: &quot;+nameList.get(i)+&quot;=====&quot;); System.out.println(); } catch (Exception e) { e.printStackTrace(); } } } 下载全站？？上面我们已经完成了一页的下载，那么下面我们的目标是？？？下载全站的资源？？额，，，这个确实是有点儿过分了。不过我们可以想想如果硬盘和时间允许的情况下是否是可以的。 观察一下每一整页的链接。 第一页http://moe.005.tv/moeimg/tb/list_3_1.html 第二页http://moe.005.tv/moeimg/tb/list_3_2.html …… 第五十页http://moe.005.tv/moeimg/tb/list_3_50.html 观察一下第五十页的源代码，基本没有任何的变化。emm，，我感觉我真的可以下载全站。总共有126页。。。emm，算了算了。 public class SplitMorePage { public static void main(String[] args) { int n = 10; for (int i = 1; i &lt;= n; i++) { System.out.println(&quot;!!!!!Now Downloading The &quot; + i + &quot; Page, Sum of &quot; + n + &quot;Page!!!!!&quot;); String url = &quot;http://moe.005.tv/moeimg/tb/list_3_&quot; + i + &quot;.html&quot;; SpiderPage spider = new SpiderPage(url, &quot;D:/JavaSpider/Page3_&quot; + i); spider.downloadImg(); System.out.println(&quot;!!!!!The &quot; + i + &quot; Page Download Complete,Sum of &quot; + n + &quot;Page!!!!!&quot;); } } } 我下载了几页试了一下，发现已经下载了一千多张图片了，也占用了很大的空间。emm，，一百多页，，算了算了不爬了！ 使用Python上面使用Java爬虫确实是有点儿繁琐的用了将近二百行的代码。说起爬虫这种玩意，可以说是Python的天下啊。那么我就简单的使用python来还原一下上面的Java一样的操作。 这里使用的是urllib.request库，没有使用requests库。 爬取单页所有的图片from urllib import request import re import os def getUrlContent(url): headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } req = request.Request(url, headers = headers) resp = request.urlopen(req) urlContent = resp.read().decode(&#39;utf-8&#39;) return urlContent def getImgUrlList(urlContent): pattern = re.compile(r&#39;&lt;img[^&gt;]*src=&quot;(.+?)&quot;.*?/&gt;&#39;) imgUrlList = pattern.findall(urlContent) return imgUrlList def downloadImg(imgUrl, cot, dest): suffix = imgUrl[-3:] request.urlretrieve(imgUrl, dest+str(cot)+&#39;.&#39;+suffix) def downloadImgs(imgUrlList, dest): if not os.path.exists(dest): os.makedirs(dest) for cot,imgUrl in enumerate(imgUrlList): if &#39;dilidili&#39; in imgUrl: continue else: downloadImg(imgUrl, cot+1, dest) cot += 1 def download(url, dest): urlContent = getUrlContent(url) imgUrlList = getImgUrlList(urlContent) downloadImgs(imgUrlList, dest) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/78680.html&#39; dest = &#39;img/&#39; download(url, dest) 可以看到python的代码明显简单多了，而且还可以简单的指定User-Agent。关键是图片的下载只需要一行代码request.urlretrieve(url, file),不像Java还要使用复杂的IO流操作。（其实Java也可以，只是我没有使用Commons IO罢了，python的函数如此简洁好用，只是因为已经包装好了而已） 爬取一整页的图片import spiderImg from urllib import request import re import os def getPageUrlList(urlContent): pattern = re.compile(r&#39;&lt;strong&gt;&lt;a href=&quot;(http://moe.005.tv/\d{5}\.html)&quot;&gt;(?:&lt;b&gt;)*(.*?)(?:&lt;/b&gt;)*&lt;/a&gt;&lt;/strong&gt;&#39;) pageUrlList = pattern.findall(urlContent) return pageUrlList def downloadPages(pageUrlList, dest): if not os.path.exists(dest): os.makedirs(dest) for pageUrl in pageUrlList: url = pageUrl[0] name = pageUrl[1] path = dest + name + &#39;/&#39; if not os.path.exists(path): os.makedirs(path) spiderImg.download(url, path) def download(url, dest): urlContent = spiderImg.getUrlContent(url) pageUrlList = getPageUrlList(urlContent) downloadPages(pageUrlList, dest) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/moeimg/list_2_11.html&#39; dest = &#39;img/&#39; download(url, dest) 上面的正则表达式中似乎是多了一个两个&lt;b&gt;,这是因为我发现有的标题使用了&lt;b&gt;倒是创建文件夹的时候失败了。于是我才加上了两个非捕获组防止&lt;和&gt;被放到文件名中，倒是创建文件夹失败。 爬取多页图片import spiderPage import os if __name__ == &#39;__main__&#39;: for i in range(29,32): url = &#39;http://moe.005.tv/moeimg/tb/list_3_&#39;+str(i)+&#39;.html&#39; dest = &#39;img/page_3_&#39;+str(i)+&#39;/&#39; if not (os.path.exists(dest)): os.makedirs(dest) try: spiderPage.download(url, dest) except Exception as e: print(&#39;Exception: &#39;+e) 总结上面可以说只是学完了正则表达式之后的一个简单的应用，写出来的也是一个极简极low的一个爬虫程序，不过这个极简极low的爬虫程序还真的解决了我的一个小问题。我再也不用，手动的右键另存为，另存为，花了半天才存了五十张图片了！！棒棒哒！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Python</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F30%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式前言第一次看到正则表达式这个名次可能会有点儿懵，什么叫正则？其实这个是翻译的问题，正则表达式的英文是Regular Expression，常常被简写为Regex，直译过来就是有规律的表达式。所以说，正则表达式就是指描述某种规则的表达式之意。 其实说白了，正则表达式就是用于字符串匹配的工具。我们可以使用正则表达式描述出来我们想要寻找的字符串符合某种规则。其实正则表达式也没有什么十分复杂的地方，主要就在于匹配符的记忆，以及匹配的经验。下面就直击要点，开始介绍正则表达式的匹配符。 正则表达式语法普通字符字母、数字、汉字、下划线、以及没有特殊定义的标点符 号，都是“普通字符”。表达式中的普通字符，在匹配一 个字符串的时候，匹配与之相同的一个字符。 这个玩意是最简单的。比如说hello就是匹配hello。world就是匹配world。没什么要说的地方。 常用的转义字符 匹配符 含义 \n 换行符 \t 制表符 \\ \本身 ^ ，\(, \)等一系列 用来匹配\后面的字符 学过任何一门的编程语言的应该都可以轻松理解上面的意思。因为^ $ ( ) { } [ ] .等这些符号在正则表达式语法具有某些特殊的含义，所以我们需要使用\转义之后才可以匹配这些字符本身。 标准字符集合 匹配符 含义 \d 任意一个数字, 0-9中的任意一个 \w 任意一个字母、数字、下划线中任意一个 \s 空格、制表符、换行符等空白字符中的任意一个 . 任意一个字符除了换行符（\n） 所谓的标准字符集合的意思就是可以和多个字符匹配的表达式。 上面的这些匹配符都是区分大小写的，而且大写是相反的意思。比如\D表示的意思是匹配除了数字以外的任意一个字符。\W表示匹配除了字母、数字和下划线以外的任意一个字符，\S表达匹配除了空格、制表符、换行符这些空白字符以外的任意一个字符。需要注意的是上面的.不要匹配换行符，如果需要匹配任意一个字符的话，推荐使用[\s\S]。细心的其实一下子就可以才出来[]是取并集的意思。 自定义字符集合也就是上面说的那样，[]表示匹配其中的任意一个字符。 匹配符 含义 [abc@f] 匹配a、b、c、@、f中的任意一个字符 [^abc] 匹配除了a、b、c之外的任意一个字符 [c-g2-9] 匹配c到g之间的任意一个字母或2-9之间的任一个数字（包含两端） [^A-Z] 匹配除了A-Z之间字母以外的任意一个字符 从上面可以看到^和-这两个字符在[]中是有特殊含义的。 ^需要放在[]的最前面表示取反的（除以下的字符以外）的意思。 -需要放在字母之间，数字之间，表示其中间的所有字符。注意不能混用，不可以出现a-Z这种写法。 除了^和-之外其他的所有的特殊字符到了[]中便失去了其原本的含义。比如.不再代表万能匹配符，而就是匹配.。 如果想要在[]匹配字符^或者-，需要使用转义字符的方式。如[\^\-]可以匹配^或者-之间的任意一个字符。 标准字符集合除了.在[]中依旧保持其原有的含义。比如[\d\s]匹配任意一个数字或者任意一个空白字符。上面说到的[\s\S]就是匹配任意一个字符。 量词量词，是用来修饰匹配次数的特殊符号 量词 含义 {n} 表达重复n次 {n, m} 表示最少n次，最多m次 {n, } 表示最少n次 ? 表示出现0次或者1次 + 表示出现至少一次，相当于{1,} * 表示不出现或者出现任意次，相当于{0,} 比如有如下的字符串 shr sher sheer sheeer shrr 使用表达式sh\w{3}r可以匹配到sheeer 使用表达式sh[a-z]{1,3}r可以匹配到sher,sheer 使用表达式sh\w{2,}r可以匹配到sheer,sheeer 使用表达式sh.?r可以匹配到shr,sher,shrr 使用表达式sh.+r可以匹配到shr sher sheer sheeer shrr 使用表达式sh.*r可以匹配到shr sher sheer sheeer shrr 上面就是这些量词的用法，看起来时蛮简单的，不过你可能主要到了一个问题，就是最后的两个的匹配。可能我们原来的意思是给我匹配shr,sher。。。这样的多个字符，而他却只给我匹配了一个大字符，这是为什么呢？ 这是因为匹配模式默认开启贪婪模式（匹配的字符串越多越好），所以说只要还下一个字符还是可以匹配的就会继续加上去，使得匹配的字符串越唱越好。 我们可以在量词的后面加上？开启非贪婪模式（匹配的字符串越少越好） 使用表达式sh.+?r可以匹配到shr sher,sheer,sheeer,shrr 使用表达式sh.*?r可以匹配到shr,sher,sheer,sheeer,shr 上面就是正则表达式中的量词的基本的使用方式。 字符边界字符边界并不是用来匹配某一类字符用的，而是用来描述某种调节的位置。 匹配符 含义 ^ 与字符串开始的地方相匹配 $ 与字符串结束的地方相匹配 \b 匹配一个单词边界 所谓的\b所描述的单词边界的意思就是这样的一个位置——位置的两边不都是\w。 有如下的字符串待匹配 sher shera asher asherb sherb sher sher使用表达式^sher可以匹配到位于字符串最开始的第一个sher 使用表达式sher$可以匹配到第二行中的最后的一个sher 使用表达式sher\b可以匹配到四个sher，除了上面的上个sher外，asher的尾部sher被匹配了。 上面就是字符边界的一般使用方法。 不过如果我们需要匹配每一行的开始的sher，或者最后的sher，需要怎么写表达式呢？ window中的换行符是\r\n，我们可以是用sher\r\n匹配到除了最后一行的末尾，所以使用sher\r\n|sher$的表达式来匹配每一行末尾。使用\r\nsher|^sher来匹配每一行的开始。不过有没有简单的方式呢？ 那么我们就需要调节正则表达式的模式了。正则表达式有以下的三种模式可以选择。 IGNORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SINGLELINE 单行模式 整个文本看作一个字符串，只有一个开头，一个结尾。 使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使 用 \A 和 \Z 如果要实现上面我说的匹配每一行开头和结尾。可以开启多行模式。这时^就是指每一行的开始。$就是指每一行的结束。此时如果我们还是想要匹配字符串的开始和结束位置可以使用\A和\Z。 选择符和分组 表达式 作用 Expression1|Expression2 分支结构。表示或，匹配左面或者右面 (Expression) 捕获组。作用下面叙述 (?:Expression) 非捕获组。作用下面叙述 上面的第一个分支结构，上面我也说过了。在非多行模式下表达式：^sher|\r\nsher其中左面是第一行的开始，右面是其他行的开始。取或就是所以行的开始位置。 那么那个所谓的捕获组又是什么意思呢？其实这个名字听起来玄乎玄乎的，其实理解起来也是很容易的。 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 每一对括号会分配一个编号，使用 () 的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式 匹配的文本 第一点其实上面忘了说了，表达式she{3}r中的{3}只可以描述前面的一个字符e,只可以匹配sheeer。如果要描述前面的多个字符需要使用()，比如说(she){3}r就可以匹配sheshesher。 第二点应该和第三点合起来，讲的大概意思就是正则表达式会将()进行分组，其中0表示的就是匹配到的整个字符串。比如表达式((sher)|hony)|(sherhony)。就被分为了四个组。0就是这个表达式本身，剩下来的从(开始从1开始分组。第一组是(sher)|hony。第二组是sher，第三组是sherhony。那么获取了这写分组有什么作用呢？这就要谈到下面的新语法了。 反向引用通过反向引用可以对分组中已经捕获的字符串进行引用。 语法: \nnn。nnn表示的分组的组号。 举例：假如我们要在字符串中匹配这样的一个单词，他的前面两个字符和后面的两个字符是相等的。 字符串为 goingo sher todotodo hony 正确表达式为：\b([a-z]{2})[a-z]*\1\b 上面的表达式中最后的\1就是一个反向引用。引用的是前面匹配到的[a-z]{2}。用这种方式就可以确认单词的首位的两个字符是相同的。而两个\b确保了这是一个单词。 非捕获组不过这个捕获组也有一定的问题。我们之所以可以引用，是因为他将之前括号中的匹配到的字符串放入了内存中供我们后面使用。加入我们不想要引用这部分的类容呢？我们仅仅只是使用括号用于作用一，而不想要浪费捕获组的这部分内容时。我们就可以使用非捕获组(?:Expression)。 比如上面的(she){3}r就可以改成(?:she){3}r。毕竟这个表达式中，使用捕获组是毫无意义的，使用非捕获组的时候，并不会影响字符串的匹配。（不使用反向引用）使用非捕获组还使用反向引用这就是非常没有意义的行为了！！ 零宽断言所谓的零宽就是指没有宽度的意思。很明显这些表达式都是不匹配字符的，只是匹配位置的。比如之前学过的^、$和\b都是零宽的表达式。下面又来介绍一下零宽的另一些表达式。 表达式 含义 (?=Exp) 断言自身位置的后面可以匹配Exp (?&lt;=Exp) 断言自身位置的前面可以匹配Exp (?!Exp) 断言自身位置的后面不可以匹配Exp (?&lt;!Exp) 断言自身位置的前面不可以匹配Exp 字符串:1sher 1shersher sher1 sher34 表达式:sher(?=\d)可以匹配到后面的两个sher不过不会匹配到他们后面的数字。所以这个表达式的意思是匹配后面的一个字符是数字的那个sher。如果使用的是sher(?=\d\d)就只能匹配到最后的那个sher。 表达式: (?&lt;=\d)sher可以匹配到前面的两个sher。(第二个的前面) 表达式: sher(?!\d)可以匹配到前面的两个sher。（第二个的后面） 表达式: (?&lt;!\d)sher可以匹配到后面的两个sher。 上面的所有的基本上就是正则表达式的语法了。不过想要掌握正则表达式还是需要不断的练习的。 正则表达式练习匹配电话号码电话号码分为座机和手机。其中座机可以表示为0\d{2,3}-\d{7,8}手机可以表示为1[34578]\d{9}。（手机号的第二位现在只有34578) 综合上面我们可以得到电话号码的匹配表达式\b0\d{2,3}-\d{7,8}\b|\b1[358]\d{9}\b。其中使用的\b是确保这个不是其他数字的一部分。（不过有时候也不要这个\b，玩意电话号码就是和字母连一起了呢？)。 匹配电子邮件电子邮件的格式是比较简单的。这里我使用的是。 \b\w+@[\da-z]+(\.[a-z]{2,3})+\b 我看了一下网上给出的匹配字符串的正则表达式是 \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 这个我倒是感觉没啥必要，一般的用户名都是只可以\w的。至于后面的域名匹配我倒是感觉他的不够严肃了，而且看起来很沙雕。 匹配HTML标签这个应该是用处最大的东西。HTML标签分为两种标签，一种是成对存在的，另一种是单独存在的。这里我写的表达式是： &lt;\s*([a-z]+)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*?/&gt; 其中第一个\s是防止某些不规范的写法，比如&lt; a&gt;。后面是一个捕获组([a-z]+)用来捕获标签的名字。再后面的[^&gt;]*用来捕获标签中的其他的一些属性值。[\s\S]*?用来捕获标签中的内容。注意使用\s\S而不是.，是因为很多标签的前后都会有很多的内容，也就是说会换行，而.无法匹配换行。所以要使用\s\S。后面的&lt;/\1&gt;中的\1是一个反向引用，用来引用前面的标签中的内容，前后标签的内容是要相等的。后面的&lt;.*?/&gt;是用来匹配单标签的。 不过上面的正则表达式还是有问题的。比如下面的这个HTML中。 &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 会出现匹配失误。第一个&lt;div&gt;和另一个&lt;/div&gt;匹配了。不过关于这个问题，我也没有想到什么解决方式。看来使用正则表达式来匹配嵌套的标签还是有一定的难度的。 Java中的正则表达式public class Demo1 { public static void main(String[] args) { Pattern pattern = Pattern.compile(&quot;sh.*?r&quot;,Pattern.CANON_EQ); Matcher matcher = pattern.matcher(&quot;sher sheer sheeer shrr&quot;); while (matcher.find()) { System.out.println(matcher.group()); } } } 使用的形式主要如上。其实也没什么好说的东西。使用Pattern编译正则表达式，后面可以选择相应的模式。然后匹配一个字符串，返回一个Matcher，然后使用find和group方法就好了。 总结上面只是简单的介绍一个正则表达式的语法，其实正则表达式还有其他很多的高级语法，可以等遇到了再学习吧。下面我准备写一个使用正则表达式来爬虫（Java）的一个小代码。蛤蛤蛤~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说内部类]]></title>
    <url>%2F2019%2F09%2F29%2F%E8%AF%B4%E8%AF%B4%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[说说内部类前言说起Java当中的类和C++中的类有什么区别，我第一个要说的就是Java的类中，竟然还可以写一个类，而且这个类还可以是成员变量。简单的来说，Java当中的内部类分为一下的三种。 内部成员类。（通常将内部成员类简称为内部类） 本地内部类 匿名内部类 这里我们说的内部类指的是非静态的内部类。简单的说也就是内部类是作为外部类的一个成员变量而存在的，必须要存在外部类的对象才能够访问到内部类。如果没有外部类的存在，内部类作为一个成员变量自然也不会存在。由于这种依赖与矛盾关系，在内部类中我们不可以声明静态成员。（静态成员包括静态变量，静态方法，静态成员类和嵌套接口。） 不过有一点比较特殊的是，在内部类中我们可以声明static final的变量，原因是在于编译器对于final变量做了一个特殊的处理。final变量会被直接写入字节码中，而不会生成变量的符号引用。 内部类的使用public class InnerClassDemo1 { private int aaa = 3; private static final int bbb = 4; public static void main(String[] args) { InnerClassDemo1 in = new InnerClassDemo1(); InnerClassDemo1.Inner inner = in.new Inner(); inner.func(); // out: Hello World \n class com.sher.innerclass.InnerClassDemo1$Inner InnerClassDemo1.Inner.InnerInner innerInner = new InnerClassDemo1().new Inner().new InnerInner(); innerInner.func(); // out: Hello World Again \n class com.sher.innerclass.InnerClassDemo1$Inner$InnerInner } public class Inner { public static final String a = &quot;Hello World&quot;; // public static int a = 3; // No static properties but static final. void func(){ System.out.println(a); System.out.println(aaa); System.out.println(bbb); System.out.println(this.getClass()); } public class InnerInner { public static final String b = &quot;Hello World Again&quot;; void func(){ System.out.println(b); System.out.println(this.getClass()); } } } } 上面我演示的是一个内部类，但是内部类当中还有着一个内部类，这个内部类依旧是合法的。我们可以将内部类直接当作是这个类的一个成员变量。一个比较特殊的一点是我们如何创建一个内部类的i变量。首先是这个内部类的类型是外部类.内部类。我们新建一个内部类的方式是，外部类对象.new 内部类()。这个格式或许有一点儿奇怪，不过仔细想想确实非常的正常。内部类是依赖于外部类说存在的，那么内部类的类型上肯定是要有外部类。如果没有的话，不同的类拥有相同名字的内部类，难道说这这两个内部类是同一个类吗？二来就是内部类的创建方式。既然内部类是依赖成员变量，那么肯定是依赖于外部类的对象而存在的。不同的外部类拥有不同的成员变量，这也是理所应当的事。 上面已经说过了内部类中是不可以有静态成员的，除了static final变量。 还有要说的就是在内部类中是否可以访问到外部类的变量。由上面可见，无论是成员变量还是静态变量都是可以访问的。比较内部类本身也是外部类的一个成员变量。 现在我们在来观察一下，这个内部类的名字是不是就是我们给他的名字呢？看结果显然不是，看来和我们上次说的那个匿名内部类是一样的。系统也是默认的生成了一个类。也是使用了$这个符号。不过那么我们是否可以使用一下的方式来新建内部类的对象呢？ InnerClassDemo1$Inner$InnerInner a = new InnerClassDemo1$Inner$InnerInner(); 运行了一下试试，果然是不行的。不过我也没期待这种方式是可行的。这也不是python私有变量的那种自欺欺人的私有。怎么可能通过这种方式就可以访问呢。 静态内部类上面说的都是内部成员类，作为对比来说，可以来简单说说静态内部类。 public class InnerClassDemo2 { private int aaa = 3; private static int bbb = 4; private static final String ccc = &quot;Outer&quot;; public static void main(String[] args) { StaticInner static1 = new StaticInner(); static1.func(); A.Go(); } public static class StaticInner{ public static final String a = &quot;Hello World&quot;; static int b = 3; int c = 4; void func(){ System.out.println(a); // System.out.println(aaa); System.out.println(InnerClassDemo2.bbb); System.out.println(ccc); } } } class A { public static void Go() { InnerClassDemo2.StaticInner inner = new InnerClassDemo2.StaticInner(); inner.func(); } } 上面演示的是静态内部类。内部成员类是对象的一个成员，那么静态内部类就是类的一个静态成员。静态内部类不需要依赖类的对象而存在，所以创建静态内部类的时候也不需要使用对象.new xx()的方式，而是使用new 外部类.静态内部类()的方式。在外部类中的时候，我们可以省略外部类.，这个用法和静态变量是一样的。 对与外部类的访问权限，也是和静态成员是一样的。他可以访问带类的静态属性(包括private)，但是不可以访问到非静态的属性，正如静态方法不可以访问非静态属性一样。 比较一下这两个类的话，我们可以看到这个静态内部类更向是一个真正的类，这个类中的数据基本上什么都是可以有的。（因为静态成员类是不依赖对象的。） 还有一个比较重要的东西没说，之前我们谈论单例设计模式的时候，我们使用了一种方法就是使用静态内部类来实现的。我们在来看一下实现的代码。 public class SingletonTest03 { public static void main(String[] args) { Singleton03 singleton1 = Singleton03.getInstance(); Singleton03 singleton2 = Singleton03.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton03{ private Singleton03() {} // 使用静态内部类 private static class SingletonInstance { private static final Singleton03 INSTANCE = new Singleton03(); } public static Singleton03 getInstance() { return SingletonInstance.INSTANCE; } } 因为静态内部类还有一个特点就是静态内部类中的静态数据只有被类第一次被使用到的时候创建。而且这种创建是线程安全的，这都是由JVM来保证的。至于为什么是这样的，这要学到JVM类的加载机制之后才能更深层次的理解之内的原因了吧。 内部类与外部类的联系上面简答的扯了一扯内部类(通常不加任何说明的内部类就是指内部成员类)与静态内部类的关系，以及他们之间的区别。下面我们想要讨论一下的是，内部类的外部类之前的关系。 上面我们以及了解到了，其实在我们写了一个内部类的之后，Java替我们生成的类并不是我们所谓的内部类的名字。而是外部类$内部类这样的一个名字。其实内部类也是一个正常的类，不过这个类是如何和绑定他的外部类建立联系的呢？ 对于内部类来说，编译器会默认生成一个final成员变量，变量的类型是外部类的类型，用来指向外部类的对象。 public class Inner{ final Outer this$0; public Inner(Outer t){ this$0 = t; super(); } } 其中引用名称this$0是编译器自动生成的，在创建内部类的对象的时候，系统会自动将外部类的的对象(outer)作为参数自动传入内部类的构造器中。 Outer.Inner inner = outer.new Inner(outer); 其实，与此同时，也会将新创建的内部类的对象(this)作为第一个参数隐式传递。假如创建玩inner对象之后，返回的引用是x，那么代码可以解析如下。 Outer.Inner inner = outer.new Inner(x, outer); 从上面可以看出来，内部类和外部类的绑定是通过this$0这个引用的。不过这些代码并不是真实存在的。这些都是我们用来描述编译器私下完成的工作的。 本地内部类上面基本上已经说完了最重要的一个内部类——内部成员类。下面就来简单的介绍一个下一个内部类——本地内部类。 和内部成员类不一样的是，这种类并不是作为类的一个成员变量，从结构上类似一个局部变量，所以说也就没有了所谓的访问权限了。 在本地类中，可以访问其所声明的方法，构造器或初始化块所属类的所有的成员， 如果要是在静态方法或者静态初始化块中声明的，则需要一个对象的引用来访问类的实例成员。 对于局部变量或方法（构造器）中声明的形式参数，本地类只可以访问final修饰的局部变量或参数。 这个类是不用和外部类进行绑定的，所以和上面的内部成员类不一样，不存在一个final引用和外部类绑定。 其实这种我感觉用处并不大，稍微了解一下就行了。 匿名内部类其实之前在谈论接口的时候，我们已经提及了这个匿名内部类了。使用匿名内部类的情况其实也就那么一种。 new A(){ xxx; } 这里的A就是一个接口，生成了一个匿名的实现了这个接口类的对象。这种写法主要是使用与这个类或者对象只会使用一次。不过Java 8之后，出来乐意lambda表达式可以替代这个匿名内部类，唉~匿名内部类是真的惨！ 总结上面是对Java中内部类的一个简单的介绍。仔细想想看Java中为什么有这么多的内部类呢？其实只是因为这些类在类中的位置不一样。（除了匿名内部类）。他们有些是作为类的实例成员，有些是作为类的静态成员，有些还是作为类中的一种局部变量。其实说白了，作为什么成员，这个类就具有那样性质的功能。从这个方面去理解内部类就一点也不难理解了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唠一唠接口]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%94%A0%E4%B8%80%E5%94%A0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[唠一唠接口接口可以new？众所周知，接口是一种完全抽象化的设计，不能够实例化，即我们不能创建接口类型的对象。也就是说我们是不可以new出一个接口对象的，但是仔细想想看，我们是不是经常使用new一个接口的操作呢？ new出一个接口其实之前刚刚讲过了lambda表达式，在那儿的时候我就想多说一句的，不过我还是忍住了，到这个地方再说。 public class Test { public static void main(String[] args) { Bird bird = new Bird() { @Override public void fly() { System.out.println(&quot;Bird can fly!&quot;); } }; // Bird bird = ()-&gt;{ // System.out.println(&quot;Bird can fly&quot;); // }; bird.fly(); } } interface Bird { void fly(); } 注释中我使用的是lambda表达式的写法，上面的是一个匿名内部类。停！上面的是一个匿名内部类？我们是不是搞错了，上面我们new了一个接口？这编译器竟然还不报错，是吃干饭的嘛？ 上面的代码一切都运行正常，不过这是不是就可以说明接口其实是可以进行实例化的呢？ 既然他是可以new出来的，那我们就在这个类中打印一下他的类型看一下。看看是不是Bird类型，如果是的话就可以证明其实接口也是可以被new的。 System.out.println(this.getClass()); 输出的结果是class com.sher.learnInterface.Test$1 Test$1这是个什么类，Test类是我们创建的，但是这个类我们根本不知道。这到底是怎么回事呢？ 其实接口可以new完全是一个假象。接口是完全抽象化的设计，是不可能实例化的。不过那如果理解上面的代码呢？其实程序中的创建方式就是匿名内部类来实现的。上面的那个类Test$1就是由系统创建的一个类，这个类实现了Bird接口，并且实现了fly()方法。不怪刚学Java的时候，Java不建议在自己起的变量名中使用$，因为这个符号广泛的被Java所使用。 上面的那个匿名内部类的实现如下 static final class Test$1 implement Bird{ public void fly(){ System.out.println(&quot;Bird can fly&quot;); } } Bird bird = new Test$1(); 由此可见，认为接口可以new真的是天大的笑话。 Java中没有多继承？Java来源于C++。可以多继承是C++的一个重大的特点之一，不过Java认为C++中的多继承把继承结构搞得一团糟，比如继承两个类都有相同的方法和属性的时候。所以索性Java直接禁止类的多继承，只允许单继承。但是Java中多了接口，类可以实现多个接口。 所以说，当别人问你，Java中有没有多继承的时候，我们应该回答没有？？ 上面只是说Java禁止类的多继承，也没说禁止其他的多继承啊。但是Java中除了类，还有什么玩意可以继承的吗？还真的有，那就是接口，接口也是可以继承的。是的，你没有听错，接口也是可以继承的。 下面我们来重新的了解一下接口到底是个什么玩意。 接口中所有的方法都必须是public , abstract类型 接口中的所有的属性都必须是public, static, final类型。 接口中的所有的内部类（包括枚举）都必须是public, static类型。 上面是Java当中接口的一些硬性的要求，第三点或许有点儿陌生，不过不看第三点其实问题也不大。 然后下面我要该了解的就是接口继承的规则了，其实这也就是方法重写的规则。如果接口中的mSub方法，重写了父接口的mSuper接口，那么需要满足一下的条件。 mSub的签名是mSuper的子签名 mSub的返回类型是mSuper返回类型的可替换类型 mSub不能抛出比mSuper更多的受检异常 上面的条件其实我们早就知道了。（方法的签名就是指函数的参数的类型） 对于类的基础中的方法重写还要有几个条件，不过这些条件接口都已经默认的满足了。 mSub和mSuper都是实例方法。（接口中的方法都是实例方法，不可能是static) mSub的访问权限不能低于mSuper。(接口中的方法全都是public的) mSub继承了父类的mSuper方法。(都是public的，当然是可以继承的) 经过了上面的探讨，我们可以知道，Java中的接口是完全可以继承的，而且是可以进行多继承的。 不过既然是可以多继承的，那么我们就要来处理一下C++中的那个问题，如果有相同的方法或者属性，怎么办？ 相同的属性名interface A{ int id = 1; } interface B{ int id = 2; } interface C extends A, B{ int id1 = A.id; int id2 = B.id; } public class Test2 implements A, B { public static void main(String[] args) { // System.out.println(id); 、、 Reference to &#39;id&#39; is ambiguous, both A.id and B.id match System.out.println(A.id); System.out.println(B.id); } } 从上面可以看到，如果是实现了多个接口的话，同时接口中有相同的属性，我们就不可以使用简单的方式来访问这个变量，我们必须在使用的时候在前面加上类名一防止产生没有必要的歧义。 相同的方法签名加入方法名相同，但是方法的签名相同，那么这个两个方法是完全可以分辨的。所以这种函数没有什么歧义。比如func(int)和func(String)是完全没有歧义的。有歧义的就是方法签名相同的函数。 interface A { void func(); } interface B { void func(); } interface C extends A, B { } public class Test2 implements C { public static void main(String[] args) { A a = new Test2(); a.func(); B b = new Test2(); b.func(); } @Override public void func() { } } 可以看到上面有相同的返回值是没有关系的，反正两个接口中都是没有实现的，所以类中实现一个就行了。使用其中的任何一个接口都可以访问到这个函数，但是两个函数是一样的。(相同名的函数，你还想实现两次，那怎么调用？) 不过如果方法的返回值不一样呢？ interface A { int func(); } interface B { String func(); } interface C extends A, B { // Error } public class Test2 implements C { // Error } 虽然这个上面没有什么报错提示，但是我的idea上报错都满天飞了，看来返回值不相同是没有办法多继承的了。 不过真的如此吗？ interface A { Collection&lt;String&gt; func(); } interface B { List&lt;String&gt; func(); } interface C extends A, B { } public class Test2 implements C { public static void main(String[] args) { A a = new Test2(); a.func(); B b = new Test2(); b.func(); } @Override public List&lt;String&gt; func() { return null; } } 可以看到，虽然方法的返回值是不一样的，但是由于List&lt;&gt;是Collection&lt;&gt;的子类，所以说多继承的时候会将范围扩大，返回值变成了List&lt;String&gt;，这样就可以多继承啦。（List&lt;String&gt;同时为List&lt;String&gt;和Collection&lt;String&gt;的子签名）。 由此可见，如果方法的签名相同，而且返回值还没有相同的子签名，那么这个两个接口将无法进行多继承。 接口中可以拥有非final的属性吗？经过上面的了解，我们也知道了接口当中的所有的属性都必须要是public static final 的。原因是在于Java当中的接口是一种完全抽象的结构。是用来给多个类实现的。如果存在非final的变量，其中的一个实现修改了变量，其他的所有的实现中的该变量都将被修改，这是非常不合理的。所以说Java的中接口是对修改封闭的。禁止你修改的。 但是真的是对修改封闭了吗？ final是对值的修改封闭的。但是Java中有非常多的引用的类型。我修改引用里面的内容但是却不修改引用这完全符合final。 interface AA{ CA ca = new CA(); } public class Test3 implements AA{ public static void main(String[] args) { System.out.println(ca.id); // 10 ca.id = 110; System.out.println(ca.id); // 110 } } class CA{ public static int id = 10; } 可见，通过这种方式，我们修改了接口中的值，（其实并没有修改，接口中保存的只是引用）就好像有了一个非final的属性。 我写这个例子并不是为了说，这样写就可以是接口拥有非final的属性，恰恰相反，我是为了防止这种情况的发生，在接口中我们尽量不要放置这种引用类型的变量。（idea才提醒我使用ca.id是个危险的行为） 总结Java中的接口可谓的是一个非常强大的结构。算了，我也没有什么可以总结的地方了，一句话，接口牛逼就是了！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识lambda]]></title>
    <url>%2F2019%2F09%2F29%2F%E8%AE%A4%E8%AF%86ambda%2F</url>
    <content type="text"><![CDATA[认识lambda前言lambda是匿名函数，虽然Java中的匿名函数没有学过，但是C++中的匿名函数我非常的熟悉啊，而且python中也曾经接触过匿名函数，不过python中的匿名长什么样子我都记不得了。现在就来学学Java中的lambda函数吧。 初识lambda说得跟恋爱似的，我和lambda的相识也是一个不经意间，并不是我要去故意的去了解lambda，他却是出现在了我的面前。话说第一个看到lambda是学习python的时候，不过现在python中lambda长什么锤子样我都已经忘记了。给我印象最深的C++中的lambda，毕竟C++是我最爱的语言。而认识Java的lambda确实因为Core Java Volume I这本书。这本书的前面使用了Java Swing编写了一个小程序，以此来彰显Java的魅力。（反正我是丝毫没感觉到）。 代码如下。 package com.sher.corejava.imageview; import javax.swing.*; import javax.swing.filechooser.FileNameExtensionFilter; import java.awt.*; import java.io.File; /** * @author SHeR * @time 8/21/2019 10:27 PM * @describe A simple java swing(GUI) ImageViewer project from &quot;Core Java, Volume I&quot; */ public class ImageViewer { public static void main(String[] args) { // What is &#39;() -&gt;&#39;?? This should be Anonymous Inner Class // It is Lambda Function related changes in Java8 EventQueue.invokeLater(() -&gt; { var frame = new ImageViewerFrame(); frame.setTitle(&quot;ImageViewer&quot;); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setVisible(true); }); /* So this Lambda Function can be wrote like this -- Anonymous Inner Class But the compiler says that Anonymous New Runnable can be replaced by lambda EventQueue.invokeLater(new Runnable() { @Override public void run() { ImageViewerFrame imageViewerFrame = new ImageViewerFrame(); imageViewerFrame.setTitle(&quot;ImageViewer&quot;); imageViewerFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); imageViewerFrame.setVisible(true); } }); */ } } @SuppressWarnings(&quot;all&quot;) class ImageViewerFrame extends JFrame { private static final int WIDTH = 800; private static final int HEIGHT = 600; public ImageViewerFrame() { setSize(WIDTH, HEIGHT); // Use a lable to display image JLabel jLabel = new JLabel(); this.add(jLabel); JFileChooser jFileChooser = new JFileChooser(); // Choose File Extension FileNameExtensionFilter fileNameExtensionFilter = new FileNameExtensionFilter(&quot;JPG &amp; GIF Images&quot;, &quot;jpg&quot;, &quot;gif&quot;); jFileChooser.setFileFilter(fileNameExtensionFilter); // Set initial open path jFileChooser.setCurrentDirectory(new File(&quot;C:\\Users\\SHeR\\blog&quot;)); // set up the menu bar JMenuBar jMenuBar = new JMenuBar(); setJMenuBar(jMenuBar); JMenu menu = new JMenu(&quot;File&quot;); jMenuBar.add(menu); JMenuItem open = new JMenuItem(&quot;Open&quot;); menu.add(open); // Lambda Function again! open.addActionListener(event -&gt; { int result = jFileChooser.showOpenDialog(null); // if file selected, set it as icon of the label if (result == JFileChooser.APPROVE_OPTION) { String name = jFileChooser.getSelectedFile().getPath(); jLabel.setIcon(new ImageIcon(name)); } }); JMenuItem exit = new JMenuItem(&quot;Exit&quot;); menu.add(exit); // Wow, Lambda Function! That&#39;s fucking simple and beautiful! exit.addActionListener(event -&gt; System.exit(0)); } } 可以看到代码的17行，71行，当时我看到了是一脸懵逼的，这是个什么玩意？后来我去查阅-&gt; in java竟然查到了这个是Java中的lambda function。这个用法是java 8中才引入的。 我观察了17行invokeLater()函数，参数是一个Runnable参数。（Runnable是一个多线程相关的接口，有一个run()方法需要实现。）所以我寻思写法应该是想我下面注释中那样哒。好歹我也是学过了一点安卓的，这里写一个匿名类还是明白的。不过他用了lambda的方式来写，好像写的东西更少了，不过也有点儿看不懂了。 lambdaJava中lambda的基本格式是(arg1, arg2...) -&gt; {body} 或者也可以加上参数的类型。type1 arg1, type2 arg2... -&gt; { body } 比如写一个最简单的lambda表达式就是(int a, int b) -&gt; {return a+b} 不过问题是这个破函数如何调用呢？？我尝试着像使用匿名函数那样去调用，没想到没有任何作用。 ((int a, int b) -&gt; {return a+b;})(1, 2)像这样调用，是我太天真了，误解了Java中的lambda。Java中lambda和我在C++中学到的一点都不一样，他不像是一种独立的函数，而是像一种依赖于接口的特殊函数。 比如上面的那个函数用法应该是这样 public class lambda { public static void main(String[] args) { Test t = (a, b) -&gt; {return a+b;}; int c = t.func(3, 4); System.out.println(c); } } interface Test{ int func(int a, int b); } 上面的lambda中，函数的参数类型是可以推导的，所以可以省略，而函数体中只有一行代码。所以大括号都可以省略，甚至return都是可以省略的。Test t = (a, b) -&gt; a+b;(不需要两个分号了) 更多的lambda使用例子Comparator&lt;String&gt; c; c = (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2); public Runnable toDoLater() { return () -&gt; { System.out.println(&quot;later&quot;); } } final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); list.forEach((a)-&gt;{ System.out.println(&quot;hello: &quot;+ a); }); filterFiles(new FileFilter[] { f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(&quot;q&quot;) }); 不过如果接口中有多个函数需要实现呢？ 那就只能gg了，据我所知lambda不能解决这个问题，而且就算是可以解决，那也会很复杂而且代码的可读性会下降。 lambda的目标类型和C++中的lambda不一样，Java中的lambda没有一个固定的类型所以Java中的lambda不能够独立的存在，只可以依赖于其他的东西，比如接口。同样的(a, b) -&gt; a+b;，我可以给很多的接口使用，这要适合lambda的形式就可以了。 所谓的适合lambda的形式就是 参数在数量上和类型上意义对应。（类型上很多的时候都是自动推导） 返回值相兼容。 异常类型也相兼容。 lambda中的变量域以及变量捕捉当我们使用匿名内部类的时候，内部类外面的变量，除非被声明为final，是不可以被使用的。但是如果使用lambda表达式的话，那就不一样了。lambda可以使用外界有效可读的变量。lambda和匿名内部类还有一个重大的区别是，匿名内部类中的this指的是这个内部类，而lambda内部的this指的就是所在的类。 上面说lambda可以使用外界有效可读的变量。那么什么事有效可读的变量呢？ 所谓的有效可读的变量就是值，这个变量被初始化之后从来没有改变过，也就说给他加上final也不会报编译错误的变量。 那么lambda是否可以修改这些变量呢？ 答案是lambda表达式对值封闭，对变量开放; int sum = 0; list.forEach(e -&gt; { sum += e.size(); }); // Illegal, close over values List&lt;Integer&gt; aList = new List&lt;&gt;(); list.forEach(e -&gt; { aList.add(e); }); // Legal, open over variables 这其实也是很好理解的，上面的那个经过lambda之后sum值都修改过了，这还能是有效可读变量吗？不过下面的那个就没有修改了吗？当然没有对象中保存的一个引用，使用add方法之后这个对象的引用并没有发生变化，所以是合法的。 final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); 这样都是合法的，但是进行下面的操作的时候就不再合法了。 final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list = null; // Error: cannot assign a value to final varible 小结Java当中lambda是十分的复杂的，是Java8当中的一个最重要的更新之一。之前我也没有学过Java8的新特性（现在已经Java13了），所以这里的lambda也就不扯那么多了。下面有一篇文章对lambda的介绍是非常的详细的，建议看看。 深入理解Java 8 lambda Java lambda表达式入门]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的包装类--装箱与拆箱]]></title>
    <url>%2F2019%2F09%2F28%2FJava%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[Java的包装类–装箱与拆箱前言众所周知，Java是一种纯面向对象的语言（并不是说Java程序员都要看着女朋友编程），不像C++中既可以面向对象也可以面向过程。但是这不意味着Java当中全被的类型都是对象。之前我们也学过Java中的类型包括，对象和8种基本数据类型。之所以不将这八种基本数据类型是因为相对于对象来说，基本数据类型在使用是更加的方便，而且使用的效率上也是远远的高于对象类型。但是，在Java的一些类库中，并不支持对基本数据类型的操作，比如说集合类型。刚开始学Java的新手肯定会发现这样的一个问题。 List&lt;int&gt; list = new List&lt;int&gt;(); 上面的这种代码，估计八成就是从C++刚转到Java的新手写出的代码。 第一点List是一个接口，是不能够new的，我们只可以new出他的子类，比如我们经常使用的ArrayList。 第二点Java当中的集合类型并不支持基本数据类型，我们应该将基本数据类型转变为相应的包装类。 所以说正确的代码应该是 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 后面的&lt;&gt;中的类型是可以省略不写的，毕竟前面都已经写过了。 为什么不能使用基本数据类型？同样是面向对象的语言，Java和C++中的对象是不一样的。Java中对象和python有一点类型，他们都有一个终极的父类Object，所以说所有的对象肯定都是Object的子类。但是C++是不一样的。 现在我们考虑List中为什么不能使用基本数据类型，我们可以先看一下List如果不指定类型会怎么样。 List list2 = new ArrayList(); 我们发现这样的代码也可以通过，而且和上面的代码不一样，这个List中可以放任何类型的数据(除了基本数据类型)。为什么呢？因为如果不指定对应的类型的话，List这些容器就会默认指定类型为Object，而Java中的任何的对象都是Object类型的子类，所以说是可以放入的。(但是这样也有一个坏处，我们取出的数据类型也是Object，这时我们可能并不知道将这个数据转成什么样的类型，所以说最好还是要指定好类型)。但是基本数据类型不是对象，他们和Ojbect没有任何的联系，所以说基本数据类型是放不进去的。要想放进去，我们就必须要是基本数据类型和对象之间建立一种一一对应的联系。于是包装类出现了。 就比如说上面的Intger就是int类型的包装类。这个类中封装了一个基本数据类型。这个时候，当集合想要操作基本数据类型的时候，就可以转向基本数据类型的包装类进行操作。 包装类介绍下面就以int的包装类Integer为例进行包装类的说明。 java.lang.Object java.lang.Number java.lang.Integer public final class Integer extends Number implements Comparable&lt;Integer&gt; Integer类包装一个对象中的原始类型int的值。类型为Integer的对象包含一个单一字段，其类型为int 。 此外，该类还提供了一些将int转换为String和String转换为int ，以及在处理int时有用的其他常量和方法。 这个类的方法是非常多的，而且大多为static方法，比如说我们之前经常使用的String转为int的方法就是他的静态方法.Integet.parseInt(String num, int radix)第二个参数是指定进制，默认是十进制。 先看一个这个类的构造函数 Integer(int value) // 构造一个新分配的 Integer对象，该对象表示指定的 int值。 Integer(String s) // 构造一个新分配 Integer对象，表示 int由指示值 String参数。 然后就是他的所有的方法其实是没有必要一一去看的。下面说的是所有的包装类都有的方法。 第一个就是xxxValue()成员方法，返回这个包装类中封装的基本数据类型。如 int intValue() // 将 Integer的值作为 int 。 如果要是double的话就是doubleValue，char就是charValue。 第二个就是valueOf(xxx)静态方法，参数是一个基本的数据类型。比如说 static Integer valueOf(int i) // 返回一个 Integer指定的 int值的 Integer实例。 不过也可以是String，指定进制的那个可不是所有的包装类都有的，只是整形才有的方法。 static Integer valueOf(String s) // 返回一个 Integer对象，保存指定的值为 String 。 static Integer valueOf(String s, int radix) // 返回一个 Integer对象，保存从指定的String中 String的值，当用第二个参数给出的基数进行解析时。 这个方法的用法如下所示。 Integer i = Integer.valueOf(3); 还有另一种写法是 Integer i = new Integer(3); 这两种方法其实等价的，但是官方建议使用第一种方法，也就是valueOf()方法，这个方法更加的快一点。这个可能是和包装类的常量池有关，就比如我们使用String的时候使用String a = “hello”;而不推荐使用String a = new String(&quot;Hello&quot;);因为前者，一是可以加入String的常量池，方便以后再用，而是如果常量池中有的话也可以不用产生新的对象。毕竟Java的中的String是一种不可变类型，基本数据类型的包装类也是如此。好像有点儿扯远了。下面继续回到正题中来。的 上面我们介绍的虽然只是int的包装类，但是其余的包装类的使用其实也是差不多的，方法也都是差不多的。 下面来展示一下基本数据类型和他们的包装类型。 基本数据类型 包装类型 基本数据类型 包装类型 int Integer short Short char Character double Double boolean Boolean byte Byte long Long float Float 可以除了int和char变成了Integer和Character的全称之外，其余的包装类都是将首字母大小.(这就是Java的命名规则) 装箱与拆箱上面说到了Java当中的集合类型只可以放入基本数据类型的包装类，但是这一点确实有点违背我们的常识。比如这样的代码 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); 可以看到，这个list中我们放入的是1,但是1是一个基本数据类型。我们要放入的本应该是包装类型，却放入了基本数据。那么是真的放入了基本的数据类型吗？其实不然。 在jdk1.5之前这样写代码是错误的。jdk1.5之前，我们需要手动装箱，手懂拆箱。 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(Integer.valueOf(1)); // list.add(new Integer(1)); 但是jdk1.5之后，Java引入自动装箱，自动拆箱的机制。也就是虽然我们是list.add(1)，编译器会将1自动装箱成Integer数据类型，然后放入list中。这一点虽然从原码上看不出来，但是反编译Java的文件，我们甚至可以看出编译器调用的是Integer.valueOf(1)这个方法。 那什么又是拆箱呢？比如如下的代码 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); int a = list.get(1); 从上面的知识我们应该知道了，list.get()返回的应该是Object的子类Integer，但是我们确实使用int类型来接受返回值的，这就有点奇怪了。其实这就是自动拆箱。通过反编译Java class文件，我们可以知道调用的intValue方法。也就是Java编译器自动调用intValue方法将Integer中封装的int数据赋值给了左面的int变量。 进一步研究装箱与拆箱通过上面的研究，我们已经知道了Java中的基本类型和包装类是可以直接相互赋值的。比如一下的代码都是正确的 int a = Integer.valueof(3); Integer b = 3; 那么除了赋值，加减乘除有如何呢？比如下面代码。 Integer a = 3; int b = a + 4; Integer c = a + b; 上面的代码都是正常运行的，可以说明Java的自动装箱拆箱机制还是非常聪明的，基本上和使用原来的基本数据类型一样。为啥是基本上？？？原因下面再说。 我们先看看第三行代码，a是int，b是Integer。他们两个是不同的类型的。那么Java是装箱呢？还是拆箱呢？这个问题其实不难回答。加入说是装箱的话，变成了两个Integer相加，不过Java中是没有运算符重载的，两个对象加个毛线啊，是加不了的。(我知道String对象是可以加的，不过那个也不算是运算符重载实际上。。。)。所以说我们只能拆箱，变成两个int相加，然后将结果装箱赋值给左面的Integer对象。 由此我们可以知道，当包装类在进行加减乘除的运算的时候，会拆箱成基本的数据类型进行运算。 上面说了使用包装类其实并不能和使用基础数据类型完全一模一样，下面来举了例子。 short a = 1; short b = 2; a += b; // if it is &#39;a = a + b&#39;, it will be error! Short a = 1; Short b = 2; a += b; // Error!! 上面的使用基本数据类型是对的，下面的是错误的。可能很多人都看不出来对与错，大概率是因为不懂+=这个符号的含义。其实上面的a += b就是相当于a = (short)(a + b);两个short值相加是一个int,这个知识点确实是很多人的盲区。int虽然不可以直接赋值给short，但是+=自带了一个强转，而int是可以强转为short的。再看看下面的代码，a += b是相当于a = (Short)(a + b);这里我们是要将一个int的值转为一个Short，这明显是不可能的。所以说这行代码将会报错了。综上所述，可以使用基本数据类型的时候，我们非要使用他的包装类，这不是闲得蛋疼嘛。别没事找事干就不会有什么问题。 不过还有一个特殊的云算符==,这个符号似乎是既可以应用于对象之间也可以应用于基本数据之间。对象还有一个equals()方法与==的作用相似。之前我写过东西谈过这个问题了。这里不再赘述这个问题了。举例说明。 Integer a = 3; Integer b = 3; int c = 3; System.out.println(a == b); // true System.out.println(a == c); // true System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // true 可以看到上面的三个结果都是true。看一下Integer中的equals()方法的源码。 public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } 可以看到是做了重写的（重写了Object的equals()方法）。而且是比较包装类中的值。 那么现在来看一下第五行的代码，一个int值和Integer类对象进行==比较。究竟是将int装箱呢？还是将Integer拆箱呢？这两种方法好像是都可以的，毕竟无论是对象还是基本数据类型都是可以使用==操作符的。不过Java采用的是将Integer拆箱。为什么呢？知道==和equals()的区别的人应该都不会意外。对象的==比较的是地址（引用），如果把int装箱，这个地址都不是之前我们可以决定的，又有什么比较的意义呢？ 不过现在你可能有所发现，==比较的是地址，为何第四行输出的也是true?? 这个就是另外的一个问题了。且听下面慢慢道来。 包装类的缓存之前我们或许都遇到过关于String缓存的例子。(上面我也谈到了缓存这一块的知识了). String a = &quot;Hello World&quot;; String b = new String(&quot;Hello World&quot;); String c = &quot;Hello World&quot;; String d = new String(&quot;Hello World&quot;); System.out.println(a == b); // false System.out.println(a == c); // true System.out.println(b == d); // false 上面的第四行和第五行的输出结果相异，主要就是因为String常量池。我们使用String xx = “xxx;”的方式声明一个String变量的时候，系统会将这个“xxx”放入常量池。（毕竟String是一个不可变的对象），然后将地址赋给xx。下面如果还有String变量的值和这个常量池中相等的话，就不会新建String对象，会直接返回常量池中的String对象。所以说上面的a和c的地址相同的。使用new String(&quot;xxx&quot;);的方式声明的String对象虽然也是不可变的对象，不过他位于堆中而不是常量池中。所以说他们的地址是不相等的。 那么上面说提及的包装类是不是也是这么个情况呢？写个代码测试一下. public class Test { public static void main(String[] args) { Integer a = -200; Integer b = -200; Integer c = -100; Integer d = -100; Integer e = 100; Integer f = 100; Integer g = 200; Integer h = 200; System.out.println(a == b); // false System.out.println(c == d); // true System.out.println(e == f); // true System.out.println(g == h); // false } } 在我写这个代码的时候，idea就一直提示我，不要使用==用于包装类的比较，建议使用equals()。这个和String的比较倒是非常类似的，都是建议使用equals()方法。不过这个结果就和String类非常的不类似了，竟然不是都输入true,还有的输入的是false。 这到底是什么原因呢？我开始查阅资料，和观察Integer的源码。发现了这样的一个类。 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * jdk.internal.misc.VM class. * * WARNING: The cache is archived with CDS and reloaded from the shared * archive at runtime. The archived cache (Integer[]) and Integer objects * reside in the closed archive heap regions. Care should be taken when * changing the implementation and the cache array should not be assigned * with new Integer object(s) after initialization. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible VM.initializeFromArchive(IntegerCache.class); int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size &gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i &lt; c.length; i++) { c[i] = new Integer(j++); } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 其实这个代码一点都看不懂，不过看看上面的文档就可以的。文档中说 缓存以支持JLS要求的自动装箱的对象标识语义，其值介于-128和127（含）之间。 首次使用时会初始化缓存。 缓存的大小可以由{@code -XX：AutoBoxCacheMax = &lt;size&gt;}选项控制。 在VM初始化期间，可以设置java.lang.Integer.IntegerCache.high属性并将其保存在jdk.internal.misc.VM类的私有系统属性中。 警告：缓存是使用CDS存档的，并在运行时从共享存档中重新加载。 归档的缓存（Integer []）和Integer对象位于封闭的归档堆区域中。 更改实现时应注意，初始化后不应为缓存数组分配新的Integer对象。 第一点就是告诉我们，如果我们不指定的话，系统将会默认缓存[-128, 127]之间的包装类。后面就是我们修改缓存大小的方式。 这样我们就明白了为什么上面的有一些是是输出的true，而有一些是输出的false。原因是在于-200和200已经不在Integer的缓存的范围中了，所以需要另外的构建对象，因而返回false。而-100和100在缓存的范围当中，所以直接获取了缓存的值。因而返回true。 我们也可以来看看Integer.valueOf()方法，这个方法中也有缓存的体现。 @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 上面的if当中的范围就是缓存的范围。如果不在缓存中的范围的时候才去new一个Integer对象。 那么除了Integer类，其余的包装类的缓存范围又是多少呢？ 包装类型 缓存范围 包装类型 缓存范围 Boolean true, false（全部） Byte [-128, 127]（全部） Short [-128, 127] Character [0, 127] Integer [-128, 127] Long [-128, 127] Float 无 Double 无 其实他们的缓存值还是非常有规律的。浮点值类型没有缓存值，布尔类型只有两个值当然都要缓存。至于其他的都是[-128, 127]。不过因为Character是没有负值的，所以去掉了负数的部分。 其实缓存值中只有Integer是最特殊的。我们是可以修改Integer缓存的上限的。(127是最低的上限)。Integer的下限-128是固定的不能修改的。至于如何修改上限，这里就不折腾了。可以干，但是没有必要。 总结Java当中的包装类可谓是一个非常重要而且非常常用的一个类。关键是用到的时候你或许还没意识到自己已经用到了这个类了，这就是所谓的自动装箱和自动拆箱。既然这个类这么常用，我们就势必应该缓存这个类的常用的部分，以便后面多次使用节省时间和内存，这就是所谓的包装类的缓存。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO应用——文件分割]]></title>
    <url>%2F2019%2F09%2F27%2FIO%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[IO应用——文件分割介绍很多下载软件下载的速度飞快是因为使用了多线程下载（至于多线程的知识，后面还是会学习的），将文件分割成不同的小块，然后不同的小块同时下载，最后再将这些小块的文件进行合并，这样下载就完成了，这样可以显著的提高下载的速度。这里我们显然不是做一个这样的下载器，而是做其中的一部分，将文件分割成许多小块，然后再将这些小文件合并。 思路其实之前没有看过任何人的思路或者写法，我就自己就我之前学过的IO流的知识来实现这个功能。其实说简单也不简单。能用就行其实确实是可以用，不过代码中的漏洞或者交互性应该是很差的。 我的代码public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; try { File file = new File(src); fis = new FileInputStream(file); byte[] buff = new byte[(int) file.length() / num + 1]; fis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest + a)); fos.write(buff); fos.flush(); a++; fis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; int a = 1; try { fos = new FileOutputStream(new File(dest)); while (a &lt;= num) { File file = new File(src + a); fis = new FileInputStream(file); fos.write(fis.readAllBytes()); a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/test.jpg&quot;, &quot;D:/dst&quot;, 10); merge(&quot;D:/dst&quot;,&quot;D:/merge.jpg&quot;,10); } } 这个思路故事是个人都会做。不过这个代码的问题也是非常的大的。在分割图片你的时候或许我们察觉不到分割后然后合并的文件和之前的文件有什么区别，但是分割文本文件额时候，不一样的地方就非常的明显了。我们可以轻易的发现，文本的最后会多出一点儿的内容，而且这一点儿的内容非常的奇怪，我也不清楚这一小块的内容是从哪儿来的。现在也非常的惆怅。我真的是喵了个咪了！ 为什么会出现最后多出了一部分你的内容呢？是因为我们没有考虑到最后一块的大小，一般来说最后一块的大小肯定是要比前面的几块都要小的，所以说在写入最后一块的时候不能再用前面的大小。 经过修改后的代码 如下所示 package com.sher.ioinjava; import java.io.*; /** * @author SHeR * @time 9/27/2019 8:36 PM * @describe */ public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; try { File file = new File(src); if (!file.isFile()) { throw new IllegalArgumentException(&quot;Src must be a file&quot;); } File dst = new File(dest); if (!dst.exists()){ if (!dst.mkdir()){ return; } } fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[(int) file.length() / num + 1]; int cot = bis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest +&quot;/&quot;+ a)); bos = new BufferedOutputStream(fos); bos.write(buff, 0, cot); bos.flush(); a++; cot = bis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[1024]; int cot = -1; while ((cot = bis.read(buff))!=-1){ bos.write(buff, 0, cot); } a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/SimpleInput.java&quot;, &quot;D:/dst&quot;, 3); merge(&quot;D:/dst&quot;,&quot;D:/hello.java&quot;); } } 经过我的测试，上面的代码基本上是没什么错误的地方了。那么这个题目我们就算是完成了。思路大概就是分割的时候一个输入流多个输出流，合并的时候一个输出流多个输入流。 不过这个代码并不能说是很完善的，我们看一下别人写的代码。 package com.sher.ioinjava; import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.Vector; /** * @author SHeR * @time 9/28/2019 11:30 AM * @describe */ public class SplitFile { //源头 private File src; //目的地(文件夹) private String destDir; //所有分割后的文件存储路径 private List&lt;String&gt; destPaths; //每块大小 private int blockSize; //块数: 多少块 private int size; public SplitFile(String srcPath,String destDir) { this(srcPath,destDir,1024); } public SplitFile(String srcPath,String destDir,int blockSize) { this.src =new File(srcPath); this.destDir =destDir; this.blockSize =blockSize; this.destPaths =new ArrayList&lt;String&gt;(); //初始化 init(); } //初始化 private void init() { //总长度 long len = this.src.length(); //块数: 多少块 this.size =(int) Math.ceil(len*1.0/blockSize); //路径 for(int i=0;i&lt;size;i++) { this.destPaths.add(this.destDir +&quot;/&quot;+i+&quot;-&quot;+this.src.getName()); } } /** * 分割 * 1、计算每一块的起始位置及大小 * 2、分割 * @throws IOException */ public void split() throws IOException { //总长度 long len = src.length(); //起始位置和实际大小 int beginPos = 0; int actualSize = (int)(blockSize&gt;len?len:blockSize); for(int i=0;i&lt;size;i++) { beginPos = i*blockSize; if(i==size-1) { //最后一块 actualSize = (int)len; }else { actualSize = blockSize; len -=actualSize; //剩余量 } splitDetail(i,beginPos,actualSize); } } /** * 指定第i块的起始位置 和实际长度 * @param i * @param beginPos * @param actualSize * @throws IOException */ private void splitDetail(int i,int beginPos,int actualSize ) throws IOException { RandomAccessFile raf =new RandomAccessFile(this.src,&quot;r&quot;); RandomAccessFile raf2 =new RandomAccessFile(this.destPaths.get(i),&quot;rw&quot;); //随机读取 raf.seek(beginPos); //读取 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=raf.read(flush))!=-1) { if(actualSize&gt;len) { //获取本次读取的所有内容 raf2.write(flush, 0, len); actualSize -=len; }else { raf2.write(flush, 0, actualSize); break; } } raf2.close(); raf.close(); } /** * 文件的合并 * @throws IOException */ public void merge(String destPath) throws IOException { //输出流 OutputStream os =new BufferedOutputStream( new FileOutputStream(destPath,true)); Vector&lt;InputStream&gt; vi=new Vector&lt;InputStream&gt;(); SequenceInputStream sis =null; //输入流 for(int i=0;i&lt;destPaths.size();i++) { vi.add(new BufferedInputStream(new FileInputStream(destPaths.get(i)))); } sis =new SequenceInputStream(vi.elements()); //拷贝 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=sis.read(flush))!=-1) { os.write(flush,0,len); //分段写出 } os.flush(); sis.close(); os.close(); } public static void main(String[] args) throws IOException { SplitFile sf = new SplitFile(&quot;Exercise/src/SimpleInput.java&quot;,&quot;dest&quot;) ; sf.split(); sf.merge(&quot;aaa.java&quot;); } } 里面使用了两个新的流RandomAccessFile和SequenceInputStream。我们可以稍微学习一下这个流，然后对我们直接的代码进行一些改进。 不过我发现使用上面的第一个类好像更加的繁琐，而且我完全没有必须去随机读取，所有说使用上面的第一个流就是没事找事干的。而上面的第二个流是将多个输入流合成一个输入流，使用后面操作更加的简单，我感觉这个功能还是稍微可以的。所以说这个可以有！ 原来的分割文件的代码我没有进行修改，合并文件的方法我使用了SequenceInputStream进行了修改。修改后代码如下所示： public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; SequenceInputStream sinput = null; Vector&lt;InputStream&gt; vector = new Vector&lt;&gt;(); int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); vector.add(bis); a++; } sinput = new SequenceInputStream(vector.elements()); int cot = -1; byte[] buff = new byte[1024]; while ((cot = sinput.read(buff))!=-1){ bos.write(buff, 0, cot); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } if (sinput != null) { sinput.close(); } } catch (IOException e) { e.printStackTrace(); } } } 其实修改的地方并不多，只是将多个输入流整合成一个输入流了而已。 总结上面的虽然是一个简单的应用，不过也会出不少的细节上面的小问题。所以说，解决了这个问题，对我们对IO的理解还是有一定的帮助的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons IO简介]]></title>
    <url>%2F2019%2F09%2F26%2FApache%20Commons%20IO%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Apache Commons IO简介 之前一直学的都是Java中IO的知识，使用起来基本上都是那个一个样，说实话我确实是有点儿感到厌倦了。于是世界上著名的开源组织阿帕奇(Apache)将Java中的IO进行了封装写了Commons IO这个玩意。这个是需要从阿帕奇的光网上面去下载的，因为这个并不是jdk自带的库。下载完之后还自带了源码以及官方文档，不过都是英文的，，这就非常考验我的能力了。 先看一下这个Commons IO 由哪些东西组成。 org.apache.commons.io // This package defines utility classes for working with streams, readers, writers and files. org.apache.commons.io.comparator // This package provides various Comparator implementations for Files. org.apache.commons.io.filefilter // This package defines an interface (IOFileFilter) that combines both FileFilter and FilenameFilter. org.apache.commons.io.input // This package provides implementations of input classes, such as InputStream and Reader. org.apache.commons.io.monitor // This package provides a component for monitoring file system events (directory and file create, update and delete events). org.apache.commons.io.output // This package provides implementations of output classes, such as OutputStream and Writer. org.apache.commons.io.serialization // This package provides a framework for controlling the deserialization of classes. 上面的这所只言片语，说实话我是什么都看不懂的，如果不是对Commons IO的体系有足够的了解，是肯定看不懂的。就像给我们一开始看那个Java io的体系图，我们也肯定是看的一脸懵逼的吖~~ 而且上面的并不是一些类而已，只是一些包，每个包中还有非常多的类，每个类中又有非常多的方法。所以说不可能一个一个去学习的，只能寻找自己需要的去学，这里就看一下别人的博客,毕竟我对这个玩意是一点也不了解。 Apache Commons IO入门教程 这个博客写了一点，但是我感觉写的并不怎么样，看了也没什么收获。下面我就直接上一些这个类的常用方法的代码吧。 文件或者文件夹的大小public class TestCommonIo { public static void main(String[] args) { long len1 = FileUtils.sizeOf(new File(&quot;test&quot;)); long len2 = FileUtils.sizeOf(new File(&quot;./Exercise/src&quot;)); System.out.println(len1); System.out.println(len2); } } 上面的第一个就是文件的大小，第二个是文件夹的大小，使用的方法是一样的。对于计算一个文件的大小，这还是非常简单的，使用length()方法就可以了，不过计算文件夹的代码确实要进行递归的操作，可以说要考虑的东西很多，而且也很繁琐。 我们可以看一下这个方法的源码 public static long sizeOf(final File file) { if (!file.exists()) { final String message = file + &quot; does not exist&quot;; throw new IllegalArgumentException(message); } if (file.isDirectory()) { return sizeOfDirectory0(file); // private method; expects directory } else { return file.length(); } } 可以看到源码中专门写了一个函数来计算文件夹的大小 private static long sizeOfDirectory0(final File directory) { final File[] files = directory.listFiles(); if (files == null) { // null if security restricted return 0L; } long size = 0; for (final File file : files) { try { if (!isSymlink(file)) { size += sizeOf0(file); // internal method if (size &lt; 0) { break; } } } catch (final IOException ioe) { // Ignore exceptions caught when asking if a File is a symlink. } } return size; } private static long sizeOf0(final File file) { if (file.isDirectory()) { return sizeOfDirectory0(file); } else { return file.length(); // will be 0 if file does not exist } } 简单的看一下确实也是使用递归的方法来计算文件夹的大小的。 列出文件static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, null); for (File file : files) { System.out.println(file.getName()); } } listFiles函数的第一个参数是待列的文件夹，第二个参数是文件过滤器（这里使用的是非空过滤器），第三个参数是文件夹过滤器（使用null就是表示不列出文件夹） static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 使用这个方法就可以列出所有的文件，包括文件夹以及文件夹里面的内容。还有一种常用的文件过滤器是后缀名过滤。比如说我只想要后缀为Java的非空的文件，可以这样写。 static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), FileFilterUtils.and(new SuffixFileFilter(&quot;java&quot;), EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 可以使用FileFilterUtils.and,FileFilterUtils.or或者FileFilterUtils.or来组织过滤器之间的逻辑，比如上面的就是以java为后缀名的并且非空的文件。 读取内容static void test3() { try { String msg = FileUtils.readFileToString(new File(&quot;hony&quot;), StandardCharsets.UTF_8); System.out.println(msg); byte[] b = FileUtils.readFileToByteArray(new File(&quot;hony&quot;)); System.out.println(new String(b, StandardCharsets.UTF_8)); List&lt;String&gt; lines = FileUtils.readLines(new File(&quot;hony&quot;), StandardCharsets.UTF_8); for (String line : lines) { System.out.println(line); } LineIterator lineIterator = FileUtils.lineIterator(new File(&quot;hony&quot;), &quot;UTF-8&quot;); while (lineIterator.hasNext()) { System.out.println(lineIterator.nextLine()); } } catch (IOException e) { e.printStackTrace(); } } 读取文件中的内容主要有上面的四种方式，无论哪一种都是比我们使用原始的Java IO流方便多了。 第一种是直接将文件中的内容读取到一个String对象中。第二种则是读取到字节数组中。 第三种是将文件的每一行都放入到一个List中。第四种方式倒是有点儿特殊，是使用迭代器的方式进行遍历文件的。 写出内容static void test4() { try { FileUtils.write(new File(&quot;happy.txt&quot;), &quot;I am happy1!&quot;, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;happy.txt&quot;), &quot;I am happy2!&quot;, StandardCharsets.UTF_8, true); FileUtils.writeByteArrayToFile(new File(&quot;happy.txt&quot;), &quot;I am happy3!&quot;.getBytes(StandardCharsets.UTF_8), true); List&lt;String&gt; datas = new ArrayList&lt;&gt;(); datas.add(&quot;sher&quot;); datas.add(&quot;hony&quot;); datas.add(&quot;sherhony&quot;); FileUtils.writeLines(new File(&quot;happy.txt&quot;), datas, &quot;\r\n&quot;, true); } catch (IOException e) { e.printStackTrace(); } } 写出到文件中同样有以上的好几种方式。上面函数的第四个参数都是代表是否一追加的形式写入到文件当中，在Java原始流当中也是使用的这种方式。不过下面的FileUtils.writeLines方法的第三个参数不再是编码了，而是分隔符，也就是说写入的这些data之间用什么隔开，这里我是用的是windows下的换行符。 拷贝拷贝包括拷贝文件或者说的是拷贝文件夹，拷贝文件的操作我们已经做过了，但是拷贝文件夹的操作是有点儿复杂，需要递归的操作。不过这个commons io提供给我们一个十分方便地方法。 static void test5() { try { FileUtils.copyFile(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;Exercise/src/test-copy.jpg&quot;)); FileUtils.copyFileToDirectory(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;D:/&quot;)); FileUtils.copyDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/out-copy&quot;)); FileUtils.copyDirectoryToDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/src&quot;)); String url = &quot;http://i1.hdslb.com/bfs/archive/9cc5e3fcc7d6c48e5a0d8d3dd8bbb6ed11937f89.jpg&quot;; FileUtils.copyURLToFile(new URL(url), new File(&quot;Exercise/src/miaonei.jpg&quot;)); String baidu = &quot;http://www.baidu.com&quot;; String wangyi = &quot;http://www.163.com&quot;; String bd = IOUtils.toString(new URL(baidu), StandardCharsets.UTF_8); String wy = IOUtils.toString(new URL(wangyi), &quot;GBK&quot;); FileUtils.writeStringToFile(new File(&quot;Exercise/src/baidu.txt&quot;), bd, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;Exercise/src/wangyi.txt&quot;), wy, &quot;GBK&quot;); } catch (IOException e) { e.printStackTrace(); } } 上面是拷贝的常见的操作。可以看到这个方法是什么的方便的。不过需要注意的是，从网络流中拷贝东西（也就是下载东西）的时候，如果是文字的话（也就网页的代码），可以使用IOUtils.toString方法，这个方法可以指定字符的编码。 总结上面就是Commons IO中简单的常用的一些操作，不过Commons IO这么强大的库怎么可能就这么一点点功能，只不过其余的功能太过与强大，而且并不是经常用到，所以现在可以不用了解。现在就是简单的看看这个类，知道有这么个玩意就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-06]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E4%B8%AD%E7%9A%84IO-06%2F</url>
    <content type="text"><![CDATA[Java 中的IO-06回顾其实之前我们已经学过了Java IO中的主要的一些流，剩下来的流基本上都是一个套路没有必要一个一个再去研讨。下面是Java IO中的一个体系图。 Java IO中主要分为了四大抽象类，然后各种流都是继承于这些抽象类，实现这些抽象类的方法。下面的图中有的是我每次学过的，有的是我们没看过的，有的还是Java中已经废弃了的，不过其实我们也完全没有必要按照这个图再去将其余的流再去学习一次，我们学习java IO其实是学习的Java IO 的思路。即使我们遇到一个陌生的流，我们也完全可以应付的来。 回到Hello World我们对IO流的学习其实是源于Hello world的输出，当时我们不知道，现在我们知道了System.out其实就是一个流对象，调用println()方法就是向控制台中输出信息。而当我们想要获取键盘的输入的时候我们使用的是System.in这个流，一般情况下，我们使用的方式是 Scanner in = new Scanner(System.in); String str = in.next(); int num = in.nextInt(); 这个Scanner就是Java为了方便我们处理键盘的输入而产生的类。不过我们也可以使用我们之前的方式读取键盘的输入。 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String s = bufferedReader.readLine(); int a = Integer.parseInt(bufferedReader.readLine()); System.out.println(s + a); 不过可以清晰的看到这个方法是有一点儿烦的，所以说使用Scanner在读取控制台的输入还是非常的方便而且简单的。 不过这个Scanner并不是只可以读取控制的输入的，也可以读取文件。只要是流都是可以读取的。更好的是这个类有hasNext等一系列的方法，所以说上面的scanner代码可以修改一下。 Scanner in = new Scanner(System.in); if (in.hasNext()){ String str = in.next(); } if (in.hasNextInt){ int num = in.nextInt(); } 下面来演示一下使用Scanner来读取文件的操作，其实是一样的，文件流和控制台的标准流都是流。 private static void scannerReadFile() { // Use Scanner to read file! final String path = &quot;C:/Users/SHeR/IdeaProjects/Exercise/src/com/sher/corejava/hello/file.txt&quot;; Scanner scanner = null; try { scanner = new Scanner(Path.of(path), StandardCharsets.UTF_8); while (scanner.hasNextLine()) { System.out.println(scanner.nextLine()); } } catch (IOException e) { e.printStackTrace(); } finally { if (scanner != null) { scanner.close(); } } } System.in是一个OnputStream，但是System.out并不是OutputStream而是一个叫PrintWriter的玩意，这就是很好奇了。现在我们来看一看这个PrintWriter是一个什么玩意。 PrintWriter看到这个类是以Writer结尾的，我们立马就知道了，这是一个字符流。不过也对，我们想控制台输入的肯定是字符啊。输入字节我们也是看不懂的，这是没必要的。先观察一下这个类的官方文档再说。 java.lang.Object java.io.Writer java.io.PrintWriter public class PrintWriter extends Writer 将对象的格式表示打印到文本输出流。这个类实现了全部在发现print种方法PrintStream 。它不包含用于编写原始字节的方法，程序应使用未编码的字节流。 不像PrintStream类，如果启用自动刷新，它只会在调用的println，printf，或format方法来完成，而不是当一个换行符恰好是输出。 这些方法使用平台自己的行分隔符而不是换行符。 这个类中的方法不会抛出I / O异常，尽管它的一些构造函数可能。 客户可以通过调用checkError()查询是否发生错误。 PrintWriter(File file) // 使用指定的文件创建一个新的PrintWriter，而不需要自动的线路刷新。 PrintWriter(File file, String csn) // 使用指定的文件和字符集创建一个新的PrintWriter，而不需要自动进行线条刷新。 PrintWriter(OutputStream out) // 从现有的OutputStream创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(OutputStream out, boolean autoFlush) // 从现有的OutputStream创建一个新的PrintWriter。 PrintWriter(String fileName) // 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新。 PrintWriter(String fileName, String csn) // 使用指定的文件名和字符集创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(Writer out) // 创建一个新的PrintWriter，没有自动线冲洗。 PrintWriter(Writer out, boolean autoFlush) //创建一个新的PrintWriter。 PrintWriter append(char c) // 将指定的字符附加到此作者。 PrintWriter append(CharSequence csq) // 将指定的字符序列附加到此作者。 PrintWriter append(CharSequence csq, int start, int end) // 将指定字符序列的子序列附加到此作者。 boolean checkError() // 如果流未关闭，请刷新流并检查其错误状态。 protected void clearError() // 清除此流的错误状态。 void close() // 关闭流并释放与之相关联的任何系统资源。 void flush() // 刷新流。 PrintWriter format(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 PrintWriter format(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 void print(boolean b) // 打印布尔值。 void print(char c) // 打印一个字符 void print(char[] s) // 打印字符数组。 void print(double d) // 打印双精度浮点数。 void print(float f) // 打印浮点数。 void print(int i) // 打印一个整数。 void print(long l) // 打印一个长整数。 void print(Object obj) // 打印一个对象。 void print(String s) // 打印字符串。 PrintWriter printf(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 PrintWriter printf(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 void println() // 通过写入行分隔符字符串来终止当前行。 void println(boolean x) // 打印一个布尔值，然后终止该行。 void println(char x) // 打印一个字符，然后终止该行。 void println(char[] x) // 打印字符数组，然后终止行。 void println(double x) // 打印双精度浮点数，然后终止行。 void println(float x) // 打印一个浮点数，然后终止该行。 void println(int x) // 打印一个整数，然后终止该行。 void println(long x) // 打印一个长整型，然后终止行。 void println(Object x) // 打印一个对象，然后终止该行。 void println(String x) // 打印一个字符串，然后终止行。 protected void setError() // 表示发生错误。 void write(char[] buf) // 写入一个字符数组。 void write(char[] buf, int off, int len) // 写一个字符数组的一部分。 void write(int c) // 写一个字符 void write(String s) // 写一个字符串 void write(String s, int off, int len) // 写一个字符串的一部分。 可以看到这个类虽然方法很多，不过基本上都是重载的方法。也就是print,printf,println这三个方法。 下面来个代码来演示一下这个流的使用。 private static void printWriterFile() { PrintWriter printWriter = null; try { printWriter = new PrintWriter(&quot;Hello.txt&quot;, StandardCharsets.UTF_8); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world\nhello core java&quot;); } catch (IOException e) { e.printStackTrace(); } finally { if (printWriter != null) { printWriter.close(); } } } 从上面的构战函数可以得知，也可以从现有的OutputStream的基础上创建PrintWriter。所以上面的代码等价于 private static void printWriterFile() { FileOutputStream fileOutputStream = null; PrintWriter printWriter = null; try { fileOutputStream = new FileOutputStream(new File(&quot;hello.txt&quot;)); printWriter = new PrintWriter(fileOutputStream); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world&quot;); printWriter.println(&quot;hello hello&quot;); printWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileOutputStream != null) { fileOutputStream.close(); } if (printWriter != null) { printWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } 注意：上面代码的第十行代码是必须的，不然文件中不会产生任何的数据。其实每次输出都可以刷新一下缓冲的。 上面说了PrintWriter那么是否有PrintReader呢？答案是没有的，，，至于为什么，好好想想去伐。。。 总结到此为此，对IO的学习基本上已经结束了。下面的一个将会讲一讲Commons IO这个玩意，那时候也就是IO真正的结束了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-05]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-05%2F</url>
    <content type="text"><![CDATA[Java中的IO-05引言上一篇文章中我们谈及了字节数组流以及字符数组流，这些流虽然不常见，但是在一定时候却能发挥巨大的作用。这里我们要学习的不是和数组有关的了，而是和Java中的数据类型有关的流。众所周知，Java中的数据分为基本数据类型还有对象，那么我就从基本数据类型开始说起吧。 DataInputStream, DateOutputStream这两个流的使用方式也是非常简答的。简单的看看官方文档就行了。 java.lang.Object java.io.InputStream java.io.FilterInputStream java.io.DataInputStream public class DataInputStream extends FilterInputStream implements DataInput 数据输入流允许应用程序以独立于机器的方式从底层输入流读取原始Java数据类型。应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。 DataInputStream对于多线程访问来说不一定是安全的。 线程安全是可选的，是本课程中用户的责任。 DataInputStream(InputStream in) // 创建使用指定的底层InputStream的DataInputStream。 int read(byte[] b) // 从包含的输入流中读取一些字节数，并将它们存储到缓冲区数组 b 。 int read(byte[] b, int off, int len) // 从包含的输入流读取最多 len个字节的数据为字节数组。 boolean readBoolean() // 见的总承包 readBoolean的方法 DataInput 。 byte readByte() // 见的总承包 readByte的方法 DataInput 。 char readChar() // 见 readChar方法的总合同 DataInput 。 double readDouble() // 见 readDouble方法 DataInput的总体合同。 float readFloat() // 见 readFloat法 DataInput的一般合同。 void readFully(byte[] b) // 见的总承包 readFully的方法 DataInput 。 void readFully(byte[] b, int off, int len) // 见的总承包 readFully的方法 DataInput 。 int readInt() // 见 readInt方法 DataInput的一般合同。 String readLine() /*已弃用 此方法无法将字节正确转换为字符。 从JDK 1.1开始，读取文本行的BufferedReader.readLine()方法是通过BufferedReader.readLine()方法。 使用DataInputStream类读取行的程序可以转换为使用BufferedReader类替换以下形式的代码： DataInputStream d = new DataInputStream(in); 与： BufferedReader d = new BufferedReader(new InputStreamReader(in)); */ long readLong() // 见的总承包 readLong的方法 DataInput 。 short readShort() // 见 readShort方法 DataInput的一般合同。 int readUnsignedByte() // 见的总承包 readUnsignedByte的方法 DataInput 。 int readUnsignedShort() // 见 readUnsignedShort法 DataInput的一般合同。 String readUTF() // 见 readUTF法 DataInput的一般合同。 static String readUTF(DataInput in) // 从流in读取以modified UTF-8格式编码的Unicode字符串的表示; 这个字符串然后作为String返回。 int skipBytes(int n) // 见 skipBytes法 DataInput的一般合同。 这些方法倒也是非常容易理解的。下面直接给出代码举例吧。 代码举例public class DataStreamDemo { public static void main(String[] args) { DataOutputStream out = null; BufferedReader br = null; byte[] a= &quot;sheriby\nsheriby\nhonysher&quot;.getBytes(StandardCharsets.UTF_8); try { DataInputStream in = new DataInputStream(new ByteArrayInputStream(a)); out = new DataOutputStream(new FileOutputStream(&quot;./Exercise/src/sher2&quot;)); br = new BufferedReader(new InputStreamReader(in)); String line; while ((line = br.readLine()) != null) { String temp = line.toUpperCase(); out.writeChars(temp); out.writeChar(&#39;\n&#39;); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (out != null) { out.close(); } if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实上面的这个代码的示例并不是非常的典型，所谓的典型的用法其实是下面的这个用法。 public class DataStreamDemo2 { public static void main(String[] args) { DataOutputStream out = null; DataInputStream in = null; try { out = new DataOutputStream(new FileOutputStream(&quot;test&quot;)); out.writeInt(2); out.writeDouble(3.1415926); out.writeUTF(&quot;sher is the best boy!&quot;); out.writeBoolean(false); in = new DataInputStream(new FileInputStream(&quot;test&quot;)); System.out.println(in.readInt()); System.out.println(in.readDouble()); System.out.println(in.readInt()); System.out.println(in.readUTF()); System.out.println(in.readBoolean()); } catch (Exception e) { e.printStackTrace(); } finally { try { if (in != null) { in.close(); } if (out != null) { out.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 我们通过DataOutputStream将我们需要的数据按顺序写入到了文件当中，然后使用DataInputStream来读取文件中的基本类型的数据，不过需要注意的是我们读取时的顺序必须要和写入是的顺序是相同的，不然代码就会抛出一个异常。还要注意的是，此时那个文件test并不是一个可读的文件(是我们有点儿看不懂的文件)。比如 @ !�M�J sher is the best boy! 可以看到前面的数据都是不可读的，只有后面的是writeUTF()写入的是可读的，但是如果只是用writeUTF()方法的话也是会出现不可读的字符的，那是因为使用wrteUTF()方法会在前面的两个字节储存长度信息。 上面基本上就是这两个流的基本的用法了。 ObjectInputStream, ObjectOutputStream上面的流是进行基本数据类型的读写，下面要说的下Java当中最为重要的对象类型的读写流。用法与上面的基本数据类型流基本是类似的。不过也有一些需要注意的地方。下面就看一下ObjecOutputStream的官方文档吧。 java.lang.Object java.io.OutputStream java.io.ObjectOutputStream public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants 官方文档中对这个类的说明非常的长而且复杂，所以我们先看看构造器还有他的成员方法吧。 protected ObjectOutputStream() // 为完全重新实现ObjectOutputStream的子类提供一种方法，不必分配刚刚被ObjectOutputStream实现使用的私有数据。 ObjectOutputStream(OutputStream out) // 创建一个写入指定的OutputStream的ObjectOutputStream。 第一个构造方法是protected的，所以我们大可不必看这个玩意。 protected void annotateClass(类&lt;?&gt; cl) // 子类可以实现此方法，以允许类数据存储在流中。 protected void annotateProxyClass(类&lt;?&gt; cl) // 子类可以实现这种方法来存储流中的自定义数据以及动态代理类的描述符。 void close() // 关闭流。 void defaultWriteObject() // 将当前类的非静态和非瞬态字段写入此流。 protected void drain() // 排除ObjectOutputStream中的缓冲数据。 protected boolean enableReplaceObject(boolean enable) // 启用流来替换流中的对象。 void flush() // 刷新流。 ObjectOutputStream.PutField putFields() // 检索用于缓冲要写入流的持久性字段的对象。 protected Object replaceObject(Object obj) // 该方法将允许ObjectOutputStream的可信子类在序列化期间将一个对象替换为另一个对象。 void reset() // 复位将忽略已写入流的任何对象的状态。 void useProtocolVersion(int version) // 指定在编写流时使用的流协议版本。 void write(byte[] buf) // 写入一个字节数组。 void write(byte[] buf, int off, int len) // 写入一个子字节数组。 void write(int val) // 写一个字节。 void writeBoolean(boolean val) // 写一个布尔值。 void writeByte(int val) // 写入一个8位字节。 void writeBytes(String str) // 写一个字符串作为字节序列。 void writeChar(int val) // 写一个16位的字符。 void writeChars(String str) // 写一个字符串作为一系列的字符。 protected void writeClassDescriptor(ObjectStreamClass desc) // 将指定的类描述符写入ObjectOutputStream。 void writeDouble(double val) // 写一个64位的双倍。 void writeFields() // 将缓冲的字段写入流。 void writeFloat(float val) // 写一个32位浮点数。 void writeInt(int val) // 写一个32位int。 void writeLong(long val) // 写一个64位长 void writeObject(Object obj) // 将指定的对象写入ObjectOutputStream。 protected void writeObjectOverride(Object obj) // 子类使用的方法来覆盖默认的writeObject方法。 void writeShort(int val) // 写一个16位短。 protected void writeStreamHeader() // 提供了writeStreamHeader方法，因此子类可以在流中附加或预先添加自己的头。 void writeUnshared(Object obj) // 将“非共享”对象写入ObjectOutputStream。 void writeUTF(String str) // 此字符串的原始数据写入格式为 modified UTF-8 。 可以看到这个类的成员方法是非常多的，但是我们可以发现的是，这个类不仅仅是可以写入对象，也可以写入基本数据类型，甚至原始数组(原始数组其实也是一个对象)。DataStream的功能基本上都是被ObjectStream说涵盖了的。 下面就来看看官方文档对这个类的一些说明。 ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。 只有支持java.io.Serializable接口的对象才能写入流中。 每个可序列化对象的类被编码，包括类的类名和签名，对象的字段和数组的值以及从初始对象引用的任何其他对象的关闭。 方法writeObject用于将一个对象写入流中。 任何对象，包括字符串和数组，都是用writeObject编写的。 多个对象或原语可以写入流。 必须从对应的ObjectInputstream读取对象，其类型和写入次序相同。 原始数据类型也可以使用DataOutput中的适当方法写入流中。 字符串也可以使用writeUTF方法写入。 对象的默认序列化机制写入对象的类，类签名以及所有非瞬态和非静态字段的值。 引用其他对象（除了在瞬态或静态字段中）也会导致这些对象被写入。 使用引用共享机制对单个对象的多个引用进行编码，以便可以将对象的图形恢复为与原始文件相同的形状。 例如，要写一个ObjectInputStream中的示例可以读取的对象： FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeInt(12345); oos.writeObject(&quot;Today&quot;); oos.writeObject(new Date()); oos.close(); 在序列化和反序列化过程中需要特殊处理的类必须采用具有这些精确签名的特殊方法： private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException; private void writeObject(java.io.ObjectOutputStream stream) throws IOException private void readObjectNoData() throws ObjectStreamException; writeObject方法负责为其特定的类编写对象的状态，以便相应的readObject方法可以恢复它。 该方法不需要关心属于对象的超类或子类的状态。 通过使用writeObject方法或通过使用DataOutput支持的原始数据类型的方法将各个字段写入ObjectOutputStream来保存状态。 序列化不会写出任何不实现java.io.Serializable接口的对象的字段。 不可序列化的对象的子类可以是可序列化的。 在这种情况下，非可序列化类必须有一个无参数构造函数，以允许其字段被初始化。 在这种情况下，子类有责任保存并恢复不可序列化类的状态。 通常情况下，该类的字段是可访问的（public，package或protected），或者可以使用get和set方法来恢复状态。 可以通过实现抛出NotSerializableException的writeObject和readObject方法来防止对象的序列化。 异常将被ObjectOutputStream捕获并中止序列化过程。 实现Externalizable接口允许对象完全控制对象的序列化表单的内容和格式。 调用Externalizable接口writeExternal和readExternal的方法来保存和恢复对象的状态。 当由类实现时，他们可以使用ObjectOutput和ObjectInput的所有方法来写入和读取自己的状态。 对象处理发生的任何版本控制都是有责任的。 枚举常数与普通可序列化或外部化对象不同的是序列化。 枚举常数的序列化形式仅由其名称组成; 不传输常数的字段值。 要序列化一个枚举常量，ObjectOutputStream会写入常数名称方法返回的字符串。 像其他可序列化或可外部化的对象一样，枚举常量可以作为随后在序列化流中出现的反向引用的目标。 枚举常数序列化的过程无法定制; 在序列化期间，将忽略由枚举类型定义的任何类特定的writeObject和writeReplace方法。 类似地，任何serialPersistentFields或serialVersionUID字段声明也被忽略 - 所有枚举类型都有一个固定的serialVersionUID为0L。 原始数据（不包括可序列化字段和外部化数据）在块数据记录中写入ObjectOutputStream。 块数据记录由报头和数据组成。 块数据头由标记和跟随标题的字节数组成。 连续的原始数据写入被合并成一个块数据记录。 用于块数据记录的阻塞因子将是1024字节。 每个块数据记录将被填充到1024个字节，或者每当块数据模式终止时都被写入。 调用ObjectOutputStream方法writeObject，defaultWriteObject和writeFields最初终止任何现有的块数据记录。 第二点是非常重要的，只有支持java.io.Serializable接口的对象才能写入流中，如果没用实现这个接口，写入的时候会报错。至于什么叫Serializable呢。这个被称为是可序列化的。就是可以被写入到文件当中。要使类实现这个接口，这需要implement Serializable不需要实现任何的函数。也就是说这个接口这是起了一个标记的作用，其母的是告诉编译器这个类可以被序列化写入到文件当中去。不过如果有一些数据我们不想其被写入到文件当中去，我们就要加上transient关键词，表示这个属性不会被写入到文件中去。关于序列化还有一点要说的是，序列化不只是对象的一个简单的复制，和此对象有关的所有的有关的对象都会被写入到文件当中去，如果其中有不可序列化的对象也会报错。假如序列化只是写入链接，当我们反序列化的时候码举例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java Io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-04]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-04%2F</url>
    <content type="text"><![CDATA[Java中的IO-04回顾之前已经介绍过很多的IO流了。比如四大抽象流InputStream，OutputStream，Reader,Writer。前面的两个是字节流，后面的两个是字符流。所谓的字节流与字符流之间的最大的区别就是，字节流是写给计算机看的，而字符流写写给我们人看的。Java当中所有的IO流基本上都继承于这个四大抽象流，而且基本上都以他们结尾。之前还说过一个特殊的流OutputStreamWriter，InputStreamReader。这两个流却是有点儿特殊，他们的前面是字节流，后面却是字符流。之前我们说他是处理字符相关的流，不过实际上他是将字节流转换成字符流的特殊流。因而我们可以指定编码(字节流转换成为字符流的一种方式)来进行字节到字符的转换。如果我们要处理一些字符文件的话，之前学的FileReader，FileWriter无疑是一个最合适的选择。如果要是处理一些字节文件比如图片或者视频什么的，我们需要使用字节流FileInputStream，FileOutputStream。不过单独使用这些流的话，效率可能是一个问题。所以缓冲区是必须的，Java IO 中给我们提供了缓冲的包装流。BufferedInputStream,BufferedOutputStream,BufferedReader,BufferedWriter。这四个流是对前面的四个基本的抽象流的包装，如果不是什么特殊情况的话，我们可以每次都加上这个缓冲层。 ByteArrayInputStream, ByteArrayOutputStream字节流我们只是介绍了一种，也就是从文件中读取字节。不过并不是所有的情况下我们都要从文件中读取字节的。比如说我们获取一个字节数组，我们想使用流来处理一下这个字节数组，好像我们现在学过的流中没有这样的功能。 于是现在我们引入了处理数组的新的流，ByteArrayInputStream和 ByteArrayOutputStream。 下面就是我们正常的官方文档的学习环节。 java.lang.Object java.io.InputStream java.io.ByteArrayInputStream public class ByteArrayInputStream extends InputStream A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。 关闭ByteArrayInputStream没有任何效果。 在关闭流之后，可以调用此类中的方法，而不生成IOException 。 ByteArrayInputStream(byte[] buf) // 创建一个 ByteArrayInputStream ，使其使用 buf作为其缓冲区数组。 ByteArrayInputStream(byte[] buf, int offset, int length) // 创建 ByteArrayInputStream使用 buf作为其缓冲器阵列。 int available() // 返回可从此输入流读取（或跳过）的剩余字节数。 void close() // 关闭 ByteArrayInputStream没有任何效果。 void mark(int readAheadLimit) // 设置流中当前标记的位置。 boolean markSupported() // 测试 InputStream是否支持标记/复位。 int read() // 从该输入流读取下一个数据字节。 int read(byte[] b, int off, int len) // 将 len字节的数据读入此输入流中的字节数组。 void reset() // 将缓冲区重置为标记位置。 long skip(long n) // 从此输入流跳过 n个字节的输入。 其实上面的这些方法，和这些属性都是可以一眼就看懂的，和其他的流是没什么区别的。 看一下官方文档的第一点，我们可以知道使用ByteArrayInputStream内部有一个缓冲区，那是否可以使用BufferedInputStream来包装呢？这个肯定是可以用的，毕竟这个也是InputStream的子类吖。 第二点是关于这个流的关闭的，官方文档告诉我们，这个流的关闭是不会做任何事情的，也就是说我们可以选择不关闭。但是为了IO流中操作的有机的统一和规范。虽然关闭没有用，我们还是推荐来关闭一下子的。 代码举例public class ByteArrayInputStreamDemo { public static void main(String[] args) { byte[] b = &quot;sher is a wonderful boy!&quot;.getBytes(); ByteArrayInputStream bais = new ByteArrayInputStream(b); StringBuilder sb = new StringBuilder(); int temp = 0; while ((temp = bais.read()) != -1){ sb.append((char) temp); } System.out.println(sb.toString()); } } 其实上面的我的用法不没有是把这个作为一个IO流来使用，所以也没有使用IO流的try catch finally的标准操作。而且这个流也是不会抛出IOException的。 下面随便写一个有关ByteArrayOutputStream的代码举例 public class ByteArrayOutputStreamDemo { public static void main(String[] args) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); while (baos.size() &lt;= 10){ try { baos.write(System.in.read()); } catch (IOException e) { e.printStackTrace(); } } byte[] b = baos.toByteArray(); System.out.println(new String(b)); } } 这里也没有使用标准的IO流操作方式，毕竟这个流是有点儿特殊了。 CharArrayWriter, CharArrayReader和上面的字节数组类似的，字符流中也有相应的流是和字符数组相关的。其实他们之间的道理是一样的，这里就不再赘述了。 public class CharArrayWriterDemo { public static void main(String[] args) { char[] ch = &quot;sher is the best boy!&quot;.toCharArray(); CharArrayWriter c = new CharArrayWriter(); try { c.write(ch); c.flush(); } catch (IOException e) { e.printStackTrace(); } System.out.println(c.toString()); } } public class CharArrayReaderDemo { public static void main(String[] args) { char [] ch = &quot;abcdefg&quot;.toCharArray(); CharArrayReader char1 = new CharArrayReader(ch); StringBuilder sb = new StringBuilder(); int temp = 0; while (true){ try { if (((temp = char1.read()) == -1)) break; } catch (IOException e) { e.printStackTrace(); } sb.append((char)temp); } System.out.println(sb.toString()); } } 总结其实这些流都不是常见的流，基本上我们是用不到的。不过稍微做一下了解也是好的呢、]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-03]]></title>
    <url>%2F2019%2F09%2F24%2FJava%E4%B8%AD%E7%9A%84IO-03%2F</url>
    <content type="text"><![CDATA[Java中的IO-03缓冲流BufferedReader和BufferedWriter在之前我们讲OutputStreamWriter中，官网文档给了我们三个建议。其中第二条是我们有点儿看不懂的。现在我们再来看一遍试试看。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。 例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 为了提高更高的效率，我们要用一个包装类BufferedWriter，减少频繁调用转换器。这个到底是什么意思呢？众所周知，buffer是缓冲区的意思，那么这个BufferedWriter的作用大概率就是给OutputStreamWriter添加了一个缓冲的地方。 我们来看一下原来的OutputStreamWriter的代码。 public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, &quot;GBK&quot;); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个是如何写入的呢？里面好像只有那一行的代码。。。osw.write(content)，这个我们怎么看写入的方式呢？我们可以再来看一看OutputStreamReader的代码。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个读取的过程就看的非常的清晰了，每次我们都读取了一个字符，然后判断是否为空，然后输入那一个字符。也就是说读取和输出之间没有缓冲区。其实我们可以每次读取1024（比如）个字符，然后一次性写入。然后再去读取1024个字符。这个buffer数组其实就是所谓的缓冲区。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int cot; byte[] buffer = new byte[1024]; // 缓冲区 while ((cot = is.read(buffer)) != -1){ System.out.println(new String(buffer, 0, cot)); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面只是我们简单的实现了一个缓冲的原理。Java IO中专门给我提供了这样的包装类（所谓的包装类就是设计模式中的装饰模式，简单的说就是给原有的类添加一些新的功能）。就是BufferedXXX，后面的XXX就是指的就是我们之前学过的Reader, Writer和InputStream和OutputStream这些流。 下面来看一下官方的文档是怎么说的。 public class BufferedReader extends Reader 从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取。 可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途。 通常，由读取器做出的每个读取请求将引起对底层字符或字节流的相应读取请求。 因此，建议将BufferedReader包装在其read（）操作可能昂贵的读取器上，例如FileReaders和InputStreamReaders。 例如， BufferedReader in = new BufferedReader(new FileReader(&quot;foo.in&quot;)); 将缓冲指定文件的输入。没有缓冲，每次调用read（）或readLine（）可能会导致从文件中读取字节，转换成字符，然后返回，这可能非常低效。 使用DataInputStreams进行文本输入的程序可以通过用适当的BufferedReader替换每个DataInputStream进行本地化。 看一下他的构造函数。 BufferedReader(Reader in) // 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) // 创建使用指定大小的输入缓冲区的缓冲字符输入流。 非常的简单，他是一个包装流，就是为了来包装Reader这个类的子类的，其中我们可以使用第二个参数来指定缓冲区的大小，不过也看了上面的说明其实一般情况是我们是不用指定的。 下面该看的就是这个类的方法了。其实这个流对象的各种方法我们基本都已经熟悉了。不过这个BufferedReader有一个我最喜欢的方法，那就是readLine()方法。 public String readLine() throws IOException 读一行文字。 一行被视为由换行符（&#39;\ n&#39;），回车符（&#39;\ r&#39;）中的任何一个或随后的换行符终止。 结果 包含行的内容的字符串，不包括任何行终止字符，如果已达到流的末尾，则为null 异常 IOException - 如果发生I / O错误 另请参见： Files.readAllLines(java.nio.file.Path, java.nio.charset.Charset) 一次就可以读一行了，这个方法不要太方便哦~~ 下面随便写一个代码来展示一下这个类。 public class BufferedReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(file)); String line; while ((line = bufferedReader.readLine()) != null){ System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { if (bufferedReader != null){ try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 可见看到，这里我没有将FileReader这个类放在外面，也没有在finally中将其关闭，那是因为在我们关闭BufferedReader的时候其实也就是关闭了FileReader，之前说了BufferedReader是他的包装流，其实包装的就是FileWriter，底层也是FileWriter，所谓的BufferedReader其实也不是流，只是一个壳子而已。这就是为啥叫他包装流或者说装饰流。 下面就是BufferedWriter了，其实具体的用法都是相似的。 public class BufferedWriterDemo { public static void main(String[] args) { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(&quot;./Exercise/src/buf.txt&quot;)); String content = &quot;hello World&quot;; writer.write(content); writer.newLine(); writer.write(content); writer.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 可以看到BufferedWriter多了一个方法。newLine()。在linux和windows当中换行的符号是不一样的。windows中的换行是\r\n，而在linux中的换行的符号是\n。其中\r的意思是回到行首。所以说使用newLine()这个方法来换行个不错的选择。 BufferedInputStream和BufferedOutputStream上面讲过了BufferedReader, BufferedWriter了，下面的这两个也是包装流，其实就可以一带而过了。 public class BufferedInputStreamDemo { public static void main(String[] args) { BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try { bufferedInputStream = new BufferedInputStream( new FileInputStream(&quot;./Exercise/src/test.jpg&quot;)); byte[] b = bufferedInputStream.readAllBytes(); bufferedOutputStream = new BufferedOutputStream( new FileOutputStream(&quot;./Exercise/src/testCopy.jpg&quot;)); bufferedOutputStream.write(b); bufferedOutputStream.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (bufferedInputStream != null){ bufferedInputStream.close(); } if (bufferedOutputStream != null){ bufferedOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实从上面可以看出，用法和之前是完全相同的，使用Buffered之后，只是增加了一个所谓的缓冲区，是流的输入和输出变得更加快呢，而且BufferedReader还提供了readLine()这种神级的方法，所以说，Buffered这种东西，不是啥特殊情况的话，最后在使用流的时候都加上吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的IO-02]]></title>
    <url>%2F2019%2F09%2F23%2FJava%E4%B8%AD%E7%9A%84IO-02%2F</url>
    <content type="text"><![CDATA[Java中的IO-02FileInputStream与FileOutputStream对字节文件的操作根据官方文档的说法，FileInputStream和FileOutputStream这两个流主要是对图像，视频等原始字节流进行操作的，但是我们举的例子却是一个字符串操作，不能体现这两个流的专门用途。下面可以用这两个流写一个图片的拷贝操作。 图片文件的拷贝public class ImgCopy { public static void main(String[] args) { File file = new File(&quot;D:/unziptest.jpg&quot;); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(file); byte[] b = fis.readAllBytes(); // 读取原始字节 fos = new FileOutputStream(&quot;./Exercise/src/test.jpg&quot;); fos.write(b); // 写入到文件中 } catch (Exception e) { e.printStackTrace(); } finally { // 关闭流 try { if (fis != null){ fis.close(); } if (fos != null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面是一个简单的图片的拷贝的操作。其中第八行的字节来源是从本地读取，其实也可以从网络上读取，然后写入到本地，这样就是一个文件下载的操作。其实这个写入字节和写入字符串的操作比起来，是一模一样的，因为这个流就是写入原始字节，就算是字符串我们不也是使用content.getBytes()的方式得到字节的。（注意这里的编码问题，默认就是工程的编码，我这里就是utf-8 的编码） 字符IO流我们之前看FileOutputStream的官方文档的时候，发现了这样的一句话。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 那么这个FileWriter又是个什么玩意呢？ 从官方文档中看他的继承结构。 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter 我们发现这个流和OutputStream竟然没有任何关系，他竟然是继承于一个叫java.io.writer的类。 public abstract class Writer extends Object implements Appendable, Closeable, Flushable 用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 然而，大多数子类将覆盖这里定义的一些方法，以便提供更高的效率，附加的功能或两者。 看来这个流是专门为了更加方便的写入字符而准备了。可以看到他的write方法中的参数是char[]，而不是byte[]，这样我们就可以不把字符转为字节进行写入，这样可以更加方便地写入也可以更加方便地读取。（有些字符可能会占用两个字节，如果我们是一个字节一个字节进行读取的话，就可能会出现乱码的情况，但是一个字符一个字符读取就不会出现这种问题。所以说进行字符流的操作的时候尽量使用这个流的子类） 写入写出基本上都是有对应的类的，这里既然有Writer，那当然就会Reader，不过他们的用法基本都是相同的。 OutputStreamWriter与InputStreamReaderpublic class OutputStreamWriter extends Writer OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 每次调用write（）方法都会使编码转换器在给定字符上被调用。所得到的字节在写入底层输出流之前累积在缓冲区中。可以指定此缓冲区的大小，但是默认情况下它大部分用于大多数目的。请注意，传递给write（）方法的字符不会缓冲。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 上面是官方文档对这个类的一些说明。第一点倒是之前讲过了一点，对于字符流，一般我们要指定一个字符集，如果不指定的话就会是我们项目默认的字符集，不过如果我们的代码文件转移到别的环境之后，可能会出现一些字符集不一样的bug。至于第三点，我们发现了一个新的流，这个是之后要介绍的了。 OutputStreamWriter(OutputStream out) // 创建一个使用默认字符编码的OutputStreamWriter。 OutputStreamWriter(OutputStream out, Charset cs) // 创建一个使用给定字符集的OutputStreamWriter。 OutputStreamWriter(OutputStream out, CharsetEncoder enc) // 创建一个使用给定字符集编码器的OutputStreamWriter。 OutputStreamWriter(OutputStream out, String charsetName) //创建一个使用命名字符集的OutputStreamWriter。 观察这个类的三个狗渣函数，第一个构造函数没有指定字符集使用的就是默认的字符集。而后面的是哪个构造函数使用了三种不同的方式指定了这个字符流使用的字符集。一般情况下，我们使用第四种就行了，使用字符串来指定字符集，比如“UTF-8”和“GBK”这两种常见的字符集。不过我们使用如下的方式程序将会运行的更快StandardCharsets.UTF-8 然后我们再看看这个函数的第一个参数，是一个OutputStream，我们知道OutputStream是一个抽象类，是不能被实例化的，所以我们可以使用他的子类，比如FileOutputStream。 现在再看看这个类的主要的方法。 void close() // 关闭流，先刷新。 void flush() // 刷新流。 String getEncoding() // 返回此流使用的字符编码的名称。 void write(char[] cbuf, int off, int len) // 写入字符数组的一部分。 void write(int c) // 写一个字符 void write(String str, int off, int len) // 写一个字符串的一部分。 可见这个类不仅可以写入字符数组byte[]，还可以写入String，这是真的方便啊。 代码测试public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, StandardCharsets.UTF_8); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 代码的几点说明： 在new出OutputStream的时候，一般我们要指定一个字符集，可以使用StandardCharsets.UTF_8的这种写法。也可以直接写“UTF-8&quot;。 写入流的时候可以直接使用String，也可以直接使用char[]，不必将其转换成为字节。 关闭流的时候，我们需要先关闭外部的OutputStream然后再关闭内部的FileOutputStream，不然会抛出异常。 至于InputStreamReader的使用，和OutPutstreamWriter的使用是如出一辙的。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 不过需要注意的是，使用read()方法可以读取一个字符，当读取到文件的末尾的时候将返回-1。 OutputStreamWriter已经基本可以满足我们写入字符串的需要了，不过这和官方文档告诉我们的FileWrtter还是不一样，FileWriter‘是其的子类。 FileWriter与FileReader的使用public class FileWriter extends OutputStreamWriter java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter FileWriter既然是上面说的那个OutputStreamWriter的子类，那么它到底有什么有别于他的父类的特殊功能呢？ 方便课写字符文件。该类的构造函数假定默认字符编码和默认字节缓冲区大小是可以接受的。要自己指定这些值，请在FileOutputStream上构造一个OutputStreamWriter。 文件是否可用或可能被创建取决于底层平台。 特别是某些平台允许一次只能打开一个文件来写入一个FileWriter （或其他文件写入对象）。 在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileWriter是用于写入字符流。 要编写原始字节流，请考虑使用FileOutputStream 。 可以看一下第一点，我们可以知道使用这个类的时候我们是无法向OutputStreamWriter那样指定一个字符集的，这个类默认使用系统或者是项目的默认的字符集。第二点倒是不难理解，不过也没有什么重点可言。我们可以看到第三点，这个和我们在FileOutputStream中看到的是一样的。 不过问题在于，使用FileWriter和OutputstreamWriter之间到底有什么区别呢？ FileWriter(File file) // 给一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append) // 给一个File对象构造一个FileWriter对象。 FileWriter(FileDescriptor fd) // 构造与文件描述符关联的FileWriter对象。 FileWriter(String fileName) // 构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append) // 构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。 这里的构造函数没有我们之间看到的OutputStream了，也就是说我们使用FileWriter的时候不必像使用OutputstreamWriter那样先创建一个FIleOutputStream，这个倒是蛮方便的。我们可以给定File类或者文件名进行字符文件的读取。这个类的话是没有额外的方法的，也就是说这个类的使用方法和OutputStreamWriter基本是一样的。 public class FileWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); FileWriter writer = null; try { writer = new FileWriter(file); String content = &quot;why are u so beautiful my girl?&quot;; writer.write(content); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } FileReader的使用方式也是类似的。 public class FileReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); FileReader reader = null; try { reader = new FileReader(file); int res; while ((res = reader.read()) != -1) { System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (reader != null){ reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 总结上面主要介绍的就是Writer和Reader，其实IO中的四大抽象类就是InputStream，OutputStream，Writer，Reader这四种。前两种主要负责的就是原始字节流的操作，而后两种主要就是字符流的操作。不过我们也是可以通过前面的两种类来操作字符流的，不过这就是有点儿麻烦而且无法处理多字符的问题。后面要学习的是更加复杂一点的IO流的知识。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-01]]></title>
    <url>%2F2019%2F09%2F22%2FJava%E4%B8%AD%E7%9A%84IO-01%2F</url>
    <content type="text"><![CDATA[java中的IO-01基本介绍所谓的IO就是Input and Output的意思。在C++中我们学到的IO主要就是两种, Istream and Ostream，cin和cout就是这两个流的对象。C++是这样子的，那么Java又如何呢？我们学习一门语言总是要从hello world开始学起，也就是向控制台中输出hello world这个字符串。在C++中我们使用的是std::cout&lt;&lt;“Hello World”&lt;&lt;std::endl;，在Java中我们使用的是System.out.println(&quot;Hello world&quot;);。既然是输出，那么肯定是和IO流相关的。cout是std::ostream的一个对象，功能是向控制台输出。那么Java中的这个函数又如何理解呢？System是Java中的一个类。 public final class System extends Object 官方文档中这样说道 System类包含几个有用的类字段和方法。它不能被实例化。 System类提供的System包括标准输入，标准输出和错误输出流; 访问外部定义的属性和环境变量; 一种加载文件和库的方法; 以及用于快速复制阵列的一部分的实用方法。 我们继续查阅官方文档，发现System类中有几个静态的成员！ static printStream err; // 标准错误输出流 static printStream in; // 标准输入流 static printStream out; // 标准输出流 这样一来Java中的这个输出函数就很好理解了。 System.out是一个对象，相当于C++中的cout。println是System.out的一个static method用于向控制台输出信息，并在最后输出换行。如果不需要换行的话我们可以使用print方法。 OutputStream与InputStream不过这个System.out为什么能输出字符串呢？那肯定是因为他是一个类似于std::ostream的玩意，他的类型是printStream。我们观察一下它的继承结构。 java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.PrintStream 最顶层的Object这个是毫无疑问的，Java当中的所有的类都是继承于java.lang.Object的。所以说最重要的是第二个 java.io.OutputStream, 正所谓，遇事不决先参看官方文档。 public abstract class OutputStream extends Object implements Closeable, Flushable 这个抽象类是表示字节输出流的所有类的超类。输出流接收输出字节并将其发送到某个接收器。 需要定义OutputStream子类的应用OutputStream必须至少提供一个写入一个字节输出的方法。 void close(); // 关闭此输出流并释放与此流相关联的任何系统资源。 void flush(); // 刷新此输出流并强制任何缓冲的输出字节被写出。 void write(byte[] b); // 将 b.length字节从指定的字节数组写入此输出流。 void wirte(byte[] b, int off, int len); // 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 abstract void write(int b); // 将指定的字节写入此输出流。 这个类是一个抽象的类是不能够被实例化的，也就是说他是所有的输出流的一个模子。我们要针对特殊的情形使用这个类的子类。 InputStream和这个也是同样的道理。 FileOutputStream 与 FIleInputStream前面说了那么多的废话，现在假如我们要输出一些东西到文件中储存能不能做到呢？答案是明显的，我们需要OutputStream的一个合适的子类，这里我们找到了FileOutputStream。我们继续查阅官方文档。 public class FileOutputStream extends OutputStream 文件输出流是用于将数据写入到输出流File或一个FileDescriptor 。文件是否可用或可能被创建取决于底层平台。特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream （或其他文件写入对象）。在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 从文档中我们可以读出，这个类主要是将原始字节流写入到文件当中去的。不过既然这个类可以被实例化，我们就要看看这个类的构造函数是怎么样的。 FileOutputStream(File file) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(File file, boolean append) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(FileDescriptor fdObj) // 创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 FileOutputStream(String name) // 创建文件输出流以指定的名称写入文件。 FileOutputStream(String name, boolean append) // 创建文件输出流以指定的名称写入文件。 这里我们看到了一个File类，可以肯定，这个类代表的就是我们要写入的文件，不过下面的两个构造函数使用的却是String name。这两个是不一样的。 既然是写入，我们还要知道这个类的写入方法是如何的。 void write(byte[] b) // 将 b.length个字节从指定的字节数组写入此文件输出流。 void write(byte[] b, int off, int len) // 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 void write(int b) // 将指定的字节写入此文件输出流。 代码测试public class FileOutputStreamDemo { public static void main(String[] args) { try { FileOutputStream fileOutputStream = new FileOutputStream(&quot;sher&quot;); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这里我们没有使用FIle类来代表文件，使用的是一个String–“sher”，然后使用write方法将字节写入到文件中。最后使用close方法关闭这个流。这里问题来了，我们只是提供了文件的名字，那么文件放在哪儿呢？？莫非是和这个类的文件同级？答案让我很懵逼，这个文件出现在我的项目文件夹的同级。其实这个位置是很沙雕的，因为我有多个项目，谁都不知道这个文件到底是属于哪一个项目的，如果是和src文件夹同级我倒是可以理解。那么我们需要修改文件的位置该如何呢？我们可以修改给定的这个文件的绝对路径，比如说我们是使用如下的代码 FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:/sher&quot;); 那么这个文件就会创建在D盘下。其实我们没有给他一个绝对路径的时候，他使用的就是相对路径，这里的相对路径不是我们想象中的那个相对与代码文件的，而是相对于整个项目的。比如我们也可以这样写。 FileOutputStream fileOutputStream = new FileOutputStream(&quot;./Exercise/src/sher&quot;); 点的意思的本目录，点点指的是上一级目录，这里在我看来点是多余的，但是去除点之后就会报错。可能是没有点他就认为这个是一个绝对路径吧。通过上面的方法我们就将文件创建到了src目录下。不过之前我们提到了一个File类，那个类又如何使用呢？ 我们可以尝试着使用File类。不过在使用File类之前我们还需要去了解一下File类。 public class File extends Object implements Serializable, Comparable&lt;File&gt; 文件和目录路径名的抽象表示，这是官方文档对File类的说明。 File类主要有如下的构战函数 File(File parent, String child) // 从父抽象路径名和子路径名字符串创建新的 File实例。 File(String pathname) // 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File(String parent, String child) // 从父路径名字符串和子路径名字符串创建新的 File实例。 我们修改了一下代码 public class FileOutputStreamDemo { public static void main(String[] args) { try { File file = new File(&quot;./Exercise/src/sher&quot;); System.out.println(file.getPath()); FileOutputStream fileOutputStream = new FileOutputStream(file); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这个修改倒是不痛不痒的，只是修改了一点点而已。其实File类还有其他非常多的方法，这里我们学习的是IO，只要简单的会使用就好啦。 注意点： 你可能注意到了FileOutputStream构造函数还有第二个参数(boolean append)，默认是false（其实这句话是错误的，Java中的函数没有默认值，只是如果我们没有第二个参数的话，调用的单个参数函数就是相当于第二个参数是false），如果我们将其设置为true的话，写入的文件的时候就不会将原有文件清空，而且接着后面继续写入。（如果文件不存在就会创建该文件） write(byte[] b, int off, int len)的使用。 fileOutputStream.write(content.getBytes(), 3, 4);写入文件的就是“r is”从第三个字符开始，写入四个字符。注意一个中文是两个字符。 write(int b)的使用 这个就更简单了，这个就是写入一个字节。比如wirte(97)就是写入一个字符a. flush()方法的使用 有时候写入的时候可能并不会直接写入，我们需要使用flush()方法刷新缓冲区之后才能写入。所有说可以在写入操作完成之后加上这个flush()方法。 上面还只是文件的简单的写入，下面还要学习一下简单的文件的读取操作。 public class FileInputStreamDemo { public static void main(String[] args) { try { FileInputStream fileInputStream = new FileInputStream(&quot;./Exercise/src/sher&quot;); byte[] b = new byte[1024]; int res = fileInputStream.read(b); System.out.println(res); System.out.println(new String(b)); } catch (Exception e) { e.printStackTrace(); } } } read函数有一个返回值，这个值的意思的读取的字符数。 其实这个FileInputStream和FileOutputStream是非常类似的。只有个别的方法存在差别。 比如说FileInputStream对象没有flush方法，不过他有一个skip方法。 long skip(long n) // 跳过并从输入流中丢弃 n字节的数据。 如果我们使用skip(1)的话，第一个字节将会被我们跳过，他的返回值是实际跳过的字节数。 总结到这里我们就基本学完了Java io的几个最基本的类，这些类也是以后学习更加复杂的IO类的基石。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈最长回文子串——马拉车算法]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%86%8D%E8%B0%88%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[再谈最长回文子串——马拉车算法 之前说过一个算法，也是和字符串有关的——字符串的匹配算法。我们介绍了暴力匹配的BF算法，还有比较难以理解的KMP算法，最后还介绍了一种简单搞笑的Sunday算法。这里我们谈论的也是字符串问题，也就是前面所讲的最长回文子串问题，本来说是不再介绍这种适用性不强的算法的，但是这个马拉车算法和KMP算法是类似的，也是一种奇葩的算法，这里就稍微了解一下吧。 基本介绍之前解决这个问题我们使用的是动态规划算法，时间复杂度是O(n2), 空间复杂度也是O(n2)。毫无疑问这个算法还是有一点儿低效的。之前字符串的暴力匹配的算法时间复杂度是O(nm)，使用KMP算法可以优化到O(n+m)，直接是优化了一整个等级。KMP算法思路是利用已经匹配失败之后的信息来帮助下一次匹配。马拉车算法也是如此，利用回文串匹配失败的信息来加速回文串的判断。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈动态规划]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%8D%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[再谈动态规划 动态规划算法是很常见的，但是上次讲的那啥动态规划讲的几个例子都不是非常的经典，不过他们依旧都是动态规划。可以很清楚的看到他们都是利用了一个类似递归的表达式（状态转换式），从一个子问题的解到另一个子问题的解。如何能一眼看出这个使用的是动态规划算法，如何一眼看出状态转换式，这个可以说是非常困难的，需要对动态规划算法非常的熟悉才行。现在就来举几个之前写好了的例子来看看动态规划算法吧。 动态规划题目最大路径和这道题口头叙述起来比较困难，直接图形化描述吧。 1 3 2 2 4 7 上面有一个三角形形状的数阵。我们从第一层开始走到最后一层，每次到下一层只能选择向左或者向右，请问如何走才能使得最终走的路径上的数字之后是最大的。思路分析这个也是动态规划算法吗？这个当然是。先想想这个问题的子问题到底是什么？我们要知道走到第三层路径的最大的和，假如我们已经知道第二层的最大路径的和呢？ 这有啥用，我们也不知道其他的位置怎么样，比如上面的那个第二层的最大路径和是4，但是要找到三层的最大路径要走旁边的那个2，所以说我们知道最大路径和是没用的。 但是我们可以考虑到每一层的每一个点的最大路径的值，最终的结果也就是最后一层的值的最大值。 4 3 2 3 7这是我们已经知道了第二层的每个点的最大路径值，那么第三层和第二层之间有什么联系呢？ 比如第一个2，他只能和4加，那就是6,。 3可以选择和4或3加，去最大值就是7。 7只可以和3加，那就是10 6 7 10最后我们找到最后一层的最大值，也就是10。这就是最大路径和。 那么状态转移式该如何写呢？ f(i, j) = max(f(i-1, j-1), f(i-1, j)) + f(i, j)； 当然这里的i,j都是有条件的。i的含义是第几层，j的含义的第几个。这样我们就可以使用二维数组来表示这个了 1 3 2 2 4 7但是这样是否最优呢？我们可以轻易的发现，每次我们只是使用了一层的数据。比如找第三层的我们只需要第二层，找第四层我们只需要第三层，那么我们可不可以只使用一个一维数组来表示呢？ 我们现在有个思路就是从最后一层开始算，为什么呢？因为到点是固定的。第一层只有一个值，最终得到的最大路径肯定是一维数组的第一个数，而且也不用考虑左右的问题了。 2 3 7 4 3 1 这是一个二维数组 找一个一维数组将最后一排赋给它 2 3 7 和第二排比较 —————— 2 3 7 3 2 -&gt; 6 9 7 只是变了第一个数和第二个数 和第一层比较 ---- 6 9 7 1 -&gt; 10 9 7 这是变了第一个数，而这个第一个数就是最大路径这个想法确实是蛮巧妙的。我感觉牛逼！！ 这是状态转移方程就改变了 maxNum(j) = max( maxNum(j), maxNum(j+1) ) + f(i)(j) 这里的maxNum就是之前的那个一维数组。到最后这个数组的第一个数肯定就是最大路径和。 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 10 int n = 0; int maxSum[MAX] = {0}; int num[MAX][MAX] = {0}; int main(){ cout&lt;&lt;&quot;Please input n:&quot;; cin &gt;&gt; n; for (int i=0; i&lt;n ;i++){ for (int j=0; j&lt;=i; j++){ cin &gt;&gt; num[i][j]; } } // 把最后一排赋给那个一维数组 for (int i=0; i&lt;n; i++){ maxSum[i] = num[n-1][i]; } for (int i = n-2; i&gt;=0; --i){ for (int j=0; j &lt;=i; ++j){ maxSum[j] = max(maxSum[j], maxSum[j+1]) + num[i][j]; } } cout&lt;&lt;maxSum[0]; return 0; } 代码说明： 其实思路分析那一块，我做的说明已经足够多了，这里就稍微说一点吧。其实也就只有for循环那一块了吧。 第一个for循环指的是从倒数第二行开始，一直比到第一行(上面我们也是这么说的，倒着来比较) 第二个for循环是计算一位数组里的值，下面也用到了我们说的状态转移方程。 线性模型 过桥 /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ 思路分析这个题目其实蛮难的，说实话不容易想到。不过要说这个是动态规划的话，我们就要找子问题。第n个人过河，和第n-1个人过河到底有没有联系？好像并没有什么联系,每个人过桥的 时间都是乱的。但是假如我们把每个人过桥的时间给从大到小排个序呢？ 这时候加了一个时间最大的人，该如何选择过河方案？ 首先我们得让那n-1个人过河，然后派时间最少的人去河对面接那个后来的人。但是这样子的时间是不是最短的呢？肯定是的，就算你让后来的那个人代替倒数第二个人也是时间最短，因为他们始终只是过河过了一次，他们时间慢的人是不可以回头去接对面的人过来的。所以我们就得到了状态转移方程 f(i) = f(i-1) + 2*time[0] + time[i] 但是还有一个问题，这也就是这个问题难的地方。我难道不可以让n-2个人先过河，然后再让2个人过河。 这样的时间又如何呢？易得他们的状态转移方程 f(i) = f(i-2) + time[0] + time[i] + 2*time[1] 这个状态转移方程也是要说明一点的。首先我们要让最快的那个人把灯送回去，然后让最后两个人过河，再让第二快的去接最快的那个人。 我们得到了两个状态转移方程，只是我们只要取得他们之间的最小值就行了。所以说最终的状态转移方程是 f(i) = min( f(i-1) + 2*time[0] + time[i], f(i-2) + time[0] + time[i] + 2*time[1]) 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ int size_time[10]{0}; int solution(vector&lt;int&gt;, int); int solution(vector&lt;int&gt; person_time){ return solution(person_time, person_time.size()-1); } // 备忘录类型的自上而下的动态规划，使用递归来实现 int solution(vector&lt;int&gt; person_time, int size){ // 动态规划 if (size_time[size] != 0){ return size_time[size]; } if (size == 0){ size_time[0] = person_time[0]; return size_time[0]; }else if (size == 1){ size_time[1] = max(person_time[0],person_time[1]); return size_time[1]; }else{ // 递归的一个子问题，前几个怎么过，再加一个人怎么过？ 双数是怎么过？单数是怎么过？ size_time[size] = min(solution(person_time, size-1)+person_time[0]+person_time[size], solution(person_time, size-2) + person_time[0] + person_time[size] + 2*person_time[1]); return size_time[size]; } } 前面的那个动态规划的文章也说过了，我们完全可以将这里的递归转为递推。 int solution2(vector&lt;int&gt; person_time){ int size = person_time.size()-1; size_time[0] = person_time[0]; if (size == 0){ return size_time[0]; } size_time[1] = max(person_time[0], person_time[1]); if (size == 1){ return size_time[1]; } // 其实完全可以不使用数组，只使用三个变量就可以完事了，不过这个已经不是非常的重要了，问题不大 // 自下而上的动态规划，使用递归的方式实现，比上面的算法更加的高效 for (int i=2; i&lt;=size; ++i){ size_time[i] = min(size_time[i-1]+person_time[0]+person_time[i], size_time[i-2]+person_time[0]+person_time[i]+2*person_time[1]); } return size_time[size]; } int main(int argc, char const *argv[]) { vector&lt;int&gt; person_time = {5,1,2 ,10}; sort(person_time.begin(), person_time.end()); // 一定要排序！ cout&lt;&lt;solution2(person_time)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 区间模型 回文串/** * 动态规划算法的区间模型 * 区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解， * 然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 */ 思路分析 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 分析： 典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时， 在X两边各添加一个字符’a’后，aXa仍然是一个回文串， 我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数， 那么对于A[i] == A[j]的情况，很明显有 d[i][j]= d[i+1][j-1] （这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串， 所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策： 在A[j]后面添加一个字符A[i]； 在A[i]前面添加一个字符A[j]； 根据两种决策列出状态转移方程为：d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1)空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。 代码实现#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using std::string; using std::cout; using std::endl; using std::min; int memo[10][10]{0}; int func(string, int, int); int func(string str){ return func(str, 0, str.length()-1); } // 开始区间类型的动态规划 下面使用的时候备忘录类型的 int func(string str, int start, int end){ if (memo[start][end] != 0){ return memo[start][end]; } if (start &gt;= end){ return 0; } if (str[start] == str[end]){ return func(str, start+1, end-1); }else { memo[start][end] = min(func(str, start+1, end), func(str, start, end-1))+1; return memo[start][end]; } } int main(int argc, char const *argv[]) { string str = &quot;srsher&quot;; cout&lt;&lt;func(str)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 0/1背包问题0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品， 使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。思路分析这是我第三次看到这个问题。我们还是先开始来找子问题。比如有四个物品，我们将其按价格排个序。现在加入我们只是发第一个物品。得到金额。然后我们放两个物品，得到金额。问题就在放n个物品得到的金额和n-1个物品到底有没有关联呢？ 可以第n个物品太重了，空间根本放不下，放n个物品的金额就是等于n-1个物品。 还有可能第n个物品可以放下去，还有剩余的空间，再用剩余的空间放那n-1个物品。 这两种方案并不能确定谁大谁小，所以说状态转移方程中，要比较他们的大小关系。 f(n, weight) = min{f(n-1, weight), v[n]+f(n-1 ,weight-w[n]))} 这里的weight其实指的是背包的容量还有多少。v数组指的是某一样物品的价格，w指的是某一样物品的重量 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using std::cout; using std::endl; using std::vector; using std::max; int memo[10][10]{0}; int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int i, int size){ if (i == 0){ if (weight[0] &gt; size){ return 0; }else { return value[0]; } } if (memo[i][size] != 0){ return memo[i][size]; } if (weight[i] &gt; size){ return func(weight, value, i-1, size); } // 放入第i件物品，再使用剩下的空间放i-1件物品， 这样做到底有没有不放入第i件，只是使用前面的i件好？ // 但是有个问题是，这个我们可能不知道到底把什么放入了背包？？？这个问题很大我感觉。。。 // 不过，似乎用一个数组来表示是否被放入的状态可能可以解决 memo[i][size] = max(func(weight, value, i-1, size), func(weight, value, i-1, size-weight[i])+value[i]); return memo[i][size]; } int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int size){ return func(weight, value, weight.size()-1, size); } int main(int argc, char const *argv[]) { vector&lt;int&gt; weight = {1,3,5,7,9}; vector&lt;int&gt; value = {1,3,5,7,10}; cout &lt;&lt; func(weight, value, 100) &lt;&lt;endl; system(&quot;pause&quot;); return 0; } 总结上面的几道题目就是动态规划问题的经典问题。从这里我们基本就可以看出动态规划的问题到底该怎么解决。第一寻找子问题到底是什么？然后寻找状态转移方程，注意这个状态转移方程的多样性。其实之前的那个动态规划基本介绍中讲的蛮详细的，不过也蛮啰嗦的。不管了，动态规划就此了结吧，拜拜了您嘞！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串问题]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最长回文子串问题 突然发现已经好久没有写博客了，虽然说最近一直都在补京阿尼的番还有一些猛男番确实是原因之一啦。不过最近确实是在看安卓这方面的东西，之前尝试着写了一点，但是我这个安卓也是小白，啥都不懂，只是在学一点儿基础，这好像也没啥好写的东西吖。于是就上leetcode看看，没想到前面的第五题我竟然都没写，不过通过率是低的真实，不用说，这肯定是一道比较难的题目了，下面就来看看这个题目吧。 题目的基本介绍给定一个字符串s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 这个题目看起来似乎是很简单的，不过说实话难的很。反正我是不会做的。而且这个题目的解法是真的特别的多，有很多的神仙解法，把这些的只适用于这道题目的神仙解法都研究透了，似乎这也没有什么意义，所以这里我要介绍的也就是这道题目的最简单的也是最复杂的解法——使用动态规划来解决。 思路分析动态规划算法之前就已经说过了，不过当时似乎没有写什么例子，也没做做过多的说明。不过，动态规划的基本思路我们还是明白的。找到子问题不同状态之间的关联，也就是那个递推的公式。比如说背包问题，放三样东西和放两样东西之间的关联是如何的。找到了这样的公式，问题也就可以轻松的解决了。 这道题目其实也蛮类似的。我们假定i和j分别指向字符串的头和尾，我们要知道i-j这一块是回文串，那么我们就可以得到i+1-j-1这一块肯定也是字符串，而且i处的字符要等于j处的字符。这时我们就可以得到一个关系表达式： 这个递推的表达式，说实话是蛮简单的了，不过不理解动态规划的算法确实很难想出来，反正我是没有想出来的。不过看懂还是可以看懂的(到头来，做了那么多的动态规划的题目，遇到这种题目根本不知道用动态规划，也不明白如何用动态规划，可悲可悲,明天可以把之前做的那四个动态规划的题目给总结了) 这样动态规划的思路就用了，如何使用代码来实现呢？ 上面的f(i, j)很容易的想到使用二维数组来实现，和背包问题是类似的。f(i, j)表示的意思就是i-j是否是回文串（i和j都是包含的） 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Solution { public: static string longestPalindrome(string s) { int length = s.length(); if(length == 0 || length == 1){ return s; } int max_len=1; int max_start=0; bool** f= new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } // 这个似乎不初始化也是对的 // for (int i=0; i&lt;length; i++){ // for (int j=0; j&lt;length; j++){ // f[i][j] = false; // } // } for(int j=0;j&lt;length;j++){ int i=0; f[j][j]=true; for(;i&lt;j;i++){ f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); if(f[i][j] &amp;&amp; j-i+1 &gt; max_len){ max_len = j-i+1; max_start = i; } } } return s.substr(max_start, max_len); } }; int main(int argc, char const *argv[]) { cout&lt;&lt;Solution::longestPalindrome(&quot;abbbbdsfdsga&quot;)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 代码说明： 堆上的二维数组 因为这里我使用的C++，不是Java。所以说在堆上new一个二维数组这种玩意的事，我是真的没用过。问了网上，他们都推荐使用vector,不过这个vector还是要resize的要给定vector一个大小才能够那样像数组一样的使用 vector&lt;vector&lt;bool&gt;&gt; f; for (int i=0; i&lt;length; i++){ f.emplace_back(vector&lt;bool&gt;(length, false)); } 这样确实是一个好办法，不过new二维数组也不是难事，我一开始是这样子干的。 bool** f = new bool[length][length]; 不过，很遗憾，报错了，不可以在堆上new出一个二维的数组，这里是C++，这里不是Java。 那怎么办呢？我又尝试了这样子的 bool** f = new bool[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这个方法也确实是够蠢的，new返回的是bool*，我却使用bool**来接收，这是肯定错误的啊。 后来查了资料才知道，原来可以这样子干啊。 bool** f = new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这样子就搞定了，第一个new返回的是bool**类型的，第二个new返回的是bool*类型的， 这样子堆上的一个二维数组的问题也就解决了。那为啥不用vector呢？可以用，而且作为使用C++的程序员，最好就别使用这种C类型的数组的。但是为了满足好奇心，这次就使用一下子。(C++11中stl中出现了array，其实说真的我们已经不需要C类型的任何数组和，无论是堆上的还是常量区上的，C++中都有对应的数据结构，stl就是这么强大) for循环内 和背包问题是类似的，我们可以先只是取前面几个字符串，然后每次加一个字符。j就是代表着取的字符串的最后的位置（包含）。每次都将f[j][j]置为true，因为此时字符串长度为1这肯定是回文的。然后然i从0开始到j判断f[i][j]的值，也就是说此时j永远是结束的那个位置。而j又是从0开始的到length-1结束，也就是所有的情况都会被遍历的。而这个算法的时间复杂度从这儿就很容易的得出来是O(n2)，空间复杂度也是O(n2)，算得上是一个比较低效的算法了，就这个题目有O(n), O(n)的算法，不过我也不需要去了解了，看过多的骚算法也不好，反正也用不到，费脑细胞。 f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); 这个就是使用的上面的那个递推的表达式，不过有点儿不同。我在后面加入了j-i==1，这时也就是说字符串的长度就是2，这是是不能进行后面的那个递推的，所以要单独拎出来。 至于后面的那个判断也就是看看找到的回文字符串的长度有没有最大的大，如果有的话就把他记下来，而且还要把开始的位置记下来，因为函数返回的字符串不是长度。刚好c++中的substr()这个函数就两个参数，第一个参数是开始的索引，第二个位置是字符串的长度。 return s.substr(max_start, max_len); 如果是Java的话就不是这样子了。Java当中的substring()函数（为啥不是subString？这明显不符合Java函数的驼峰式的命名规范啊。。。）的第一个参数是开始的索引，第二个参数的结束的索引（不包含） return s.substring(max_start, max_start+max_len); 总结动态规划算法算是很常见的了，如果理解了这个算法，会发现这个算法其实代码很好写，就是找那个递推的关系。不过我现在也就是停留在能做成做过的动态规划的题目，如果真的是给我一道算法的题目，我真的不知道是否该用动态规划算法，如果要用又是怎么用呢？唉，还是太菜了，对这个算法的理解还不够。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（二）工厂模式]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本介绍大名鼎鼎的GOF对工厂模式的定义是这样子的。 “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。) 工厂模式的分类 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式； 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。 为什么要使用工厂模式 解耦 ：把对象的创建和使用的过程分开 降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。 下面将分这三种模式来简单的介绍一下工厂模式。 简单工厂模式简单工厂的基本介绍严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况。 最重要的是它违背了我们在概述中说的 开放-封闭原则 （虽然可以通过反射的机制来避免，后面我们会介绍到） 。因为每次你要新添加一个功能，都需要在生switch-case 语句（或者if-else 语句）中去修改代码，添加分支条件。 简单工厂的适用场景 需要创建的对象较少。 客户端不关心对象的创建过程。 简单工厂模式角色分配 工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 简单工厂实例public interface IProduct { void print(); // 这是要暴露的方法 } public abstract class AbstractProduct implements IProduct { protected void printBefore(){ System.out.println(&quot;before print&quot;); // 这里所公共的实现 } } public class AProduct extends AbstractProduct { private String name; public AProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print A &gt;&gt;&gt;&quot;+name); } } public class BProduct extends AbstractProduct { private String name; public BProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print B &gt;&gt;&gt;&quot;+name); } } public class SimpleFactory{ public static AProduct sellAProduct(){ return new AProduct(); } public static BProduct sellBProduct(){ return new BProduct; } } 这里我们有两个产品分为是产品A和产品B。还有一个卖产品的简单工厂，里面有卖A产品和卖B产品的地方。现在我们加入这个设计是合理的。现在多了一个C产品，我们要写一个C产品，让他继承那个抽象的产品，然后还有在工厂当中加入买C产品的函数。这显然有点儿烦了。我们可以将工厂进一步的抽象。 public class SimpleFactory { public static IProduct getProduct(String name){ if(&quot;A&quot;.equals(name)){ return new AProduct(name); }else if(&quot;B&quot;.equals(name)){ return new BProduct(name); }else if(&quot;C&quot;.equals(name)){ return new CProduct(name); }else { throw new IllegalArgumentException(); } } } 这样我们就可以只用一个方法就可以完成所有的产品的制作了。但是这个简单工厂并不符合设计模式。每次增加产品的时候都要修改工厂类的方法。我们做产品的一个主要的思路就是尽量不要依赖具体，尽量不要修改而是增加。 为什么要使用工厂模式？ 如果这里要要多了店要来买我们的产品，如果没有工厂的话，所有的店都要依赖我们的产品类。一旦产品有什么修改，比如说增加了什么产品，或者修改了什么产品，所有的店家都要修改代码。所以说这样非常的不好。有了工厂之后，店不用直接依赖什么具体的类，不用使用new来产生产品，而是依赖工厂，通过工厂来获取产品。只是产品有了修改，在简单工厂模式里面来说，只是修改了工厂类而已，店家的类的代码没有必要去修改。 再来一个例子 创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图. （1）创建Shape接口 public interface Shape { void draw(); } （2）创建实现该接口的具体图形类 圆形 public class Circle implements Shape { public Circle() { System.out.println(&quot;Circle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Circle&quot;); } } 长方形 public class Rectangle implements Shape { public Rectangle() { System.out.println(&quot;Rectangle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Rectangle&quot;); } } 正方形 public class Square implements Shape { public Square() { System.out.println(&quot;Square&quot;); } @Override public void draw() { System.out.println(&quot;Draw Square&quot;); } } （3）创建工厂类： public class ShapeFactory { // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) { if (shapeType == null) { return null; } if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) { return new Circle(); } else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) { return new Rectangle(); } else if (shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)) { return new Square(); } return null; } } （4）测试方法： public class Test { public static void main(String[] args) { // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape(&quot;CIRCLE&quot;); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape(&quot;RECTANGLE&quot;); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape(&quot;SQUARE&quot;); square.draw(); } } 输出结果： Circle Draw Circle Rectangle Draw Rectangle Square Draw Square这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。 所以说简单工厂模式需要进行改进。 工厂方法模式先来说说上面的AB产品的例子。 public interface IFactory { IProduct getProduct(); } public class AFactory implements IFactory { @Override public IProduct getProduct() { return new AProduct(AProduct.class.getName()); } } public class BFactory implements IFactory { @Override public IProduct getProduct() { return new BProduct(BProduct.class.getName()); } } 这一次我们让客户端不再依赖具体的工厂类，而是依赖一个抽象的工厂类。然后让各个生产对应的产品的工厂继承抽象工厂，实现抽象工厂的方法。这时，我们就满足依赖倒置原则了。我们的客户端不再依赖具体，而是一览抽象。当我们有了一个C产品的时候，我们只有添加C类，和CFactory就行了，我们这时只是增加了代码，没有修改之前的代码，符合设计模式的规则。 突然发现有些糟糕了，因为代码变得很多了，因为功能类似的产品我们进行 3 层抽象，针对每个产品我们还抽象出了 2 层的工厂类。但是我们在某个具体的业务场景中，不单单是只实例化一个类啊。举一个例子，在游戏中，我们要一个战士配装备，首先我们需要配一把枪械（枪械有很多，步枪，狙击枪等，使用问题 1 进行抽象），但是配了枪械之后，我们还需要配子弹啊（继续使用问题 1 的方法进行抽象），好了，现在可以抽象出 2 层的工厂类了，针对现在的情况我们是不是可以让一个工厂既生产枪械，又生产子弹呢？ 这就是抽象工厂模式。简单来说，可以把有一些有联系或者相近的产品，放到一个工厂去生产，没有必要单独再开一个工厂了。 图形的工厂方法的介绍 上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。 (1)增加一个工厂接口： public interface Factory { public Shape getShape(); }（2）增加相关工厂类: 圆形工厂类 public class CircleFactory implements Factory { @Override public Shape getShape() { // TODO Auto-generated method stub return new Circle(); } }长方形工厂类 public class RectangleFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Rectangle(); } }圆形工厂类 public class SquareFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Square(); } }（3）测试： public class Test { public static void main(String[] args) { Factory circlefactory = new CircleFactory(); Shape circle = circlefactory.getShape(); circle.draw(); } }输出结果： Circle Draw Circle工厂方法的一些应用我们都知道 Java 的泛型是采用类型擦除来实现的（在 javac 编译过程的中把泛型去掉，加上强制类型转换）。所以我们不能直接 new T()来实例化一个对象。其实可以采用工厂方法模式设计模式来解决。 假设我们有一个类，里面要用到了泛型的实例化。 public class Foo&lt;T&gt;(){ private T t; public Foo(){ t = new T(); // 这个代码是有问题的，我们使用工厂设计模式进行改进 } } 我们给出工厂接口如下： public interface IFactory&lt;T&gt;(){ T create(); } 进而我们可以采用如下的方法进行改进 public class Foo&lt;T&gt;(){ private T t; public &lt;F extends IFactory&lt;T&gt;&gt; Foo(F factory){ // t = new T(); return factory.create(); } } 这个时候，我们可以采用如下的方式实例化 Foo new Foo(new Ifactory&lt;Integer&gt;(){ Integer create(){ return new Integer(0); } }); new Foo(new Ifactory&lt;String&gt;(){ String create(){ return &quot;Hello&quot;; } }); 抽象工厂抽象工厂的基本介绍在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。 抽象工厂应该是比较最难理解的一个工厂模式了。 抽象工厂的适用场景 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品） 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 抽象工厂方法模式角色分配 抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。 不知道大家玩过穿越火线或者吃鸡这类游戏了吗，游戏中存在各种枪。我们假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。（AK工厂生产AK系列产品包括子弹啊，AK枪的类型啊这些，M4A1工厂同理） （1）创建相关接口： 枪 public interface Gun { public void shooting(); } 子弹 public interface Bullet { public void load(); } （2）创建接口对应实现类： AK类 public class AK implements Gun{ @Override public void shooting() { System.out.println(&quot;shooting with AK&quot;); } } M4A1类 public class M4A1 implements Gun { @Override public void shooting() { System.out.println(&quot;shooting with M4A1&quot;); } } AK子弹类 public class AK_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with AK&quot;); } } M4A1子弹类 public class M4A1_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with M4A1&quot;); } } （3）创建工厂接口 public interface Factory { public Gun produceGun(); public Bullet produceBullet(); } （4）创建具体工厂 生产AK和AK子弹的工厂 public class AK_Factory implements Factory{ @Override public Gun produceGun() { return new AK(); } @Override public Bullet produceBullet() { return new AK_Bullet(); } } 生产M4A1和M4A1子弹的工厂 public class M4A1_Factory implements Factory{ @Override public Gun produceGun() { return new M4A1(); } @Override public Bullet produceBullet() { return new M4A1_Bullet(); } } （5）测试 public class Test { public static void main(String[] args) { Factory factory; Gun gun; Bullet bullet; factory =new AK_Factory(); bullet=factory.produceBullet(); bullet.load(); gun=factory.produceGun(); gun.shooting(); } } 输出结果： Load bullets with AK shooting with AK总结意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 参考：深入理解工厂模式 知乎回答 工厂模式|菜鸟教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图和图的BFS与DFS]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84BFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[图和图的BFS与DFS图的基本介绍图和树一样，也是一种数据结构，不过这种数据结构恐怕是来得复杂了那么一点点。图一般由节点(Vertex) 与 边（Edge）来组成， 其中边是否是有方向的又将图分为有向图和无向图。有时边还是带有权值的，这时图被称为带权图。 图的表示的方式也有很多样，这里我们采用的是最简单的邻接矩阵来表示图。不要看到矩阵就嗷嗷嗷的~其实这里就是一个二维的数组而已，和线代没关系的，不要慌嘛。 图的创建看其实图和树还是有一点儿像的，但如果使用树的方式去构建图的话，效率就会变得特别的低下，所以我们要考虑其他的表示图的方案。 表示顶点创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。 class Vertex&lt;E&gt;{ private E label; private boolean isVisited; public Vertex(E label){ this.label = label; } public E getLabel() { return label; } public void setLabel(E label) { this.label = label; } public boolean isVisited() { return isVisited; } public void setVisited(boolean isVisited) { this.isVisited = isVisited; } } 表示边图的实际信息都保存在边上，因为它们描述了图的结构。我们容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。 我们是用邻接矩阵的方式来表示顶点是否是相邻的，如果是相邻的权值又是多少。 上图就是一个邻接矩阵，可以看到这个是一个实对称矩阵（求出对应的二次型的标准型，并判断是否正定，跑偏了，和线性代数没有关系的）。第一行的那个2就表示第一个节点和第二个节点是相连的，而且权值为2，这个又是一个无向图，所以一定是对称的。 表示图根据上面的思路就可以轻松的写出图的结构，还有一些简单的函数。 使用集合来存放节点，是用二维数组来存放邻接矩阵。so easy class Graph2&lt;E&gt; { private ArrayList&lt;Vertex&lt;E&gt;&gt; vertexList; private int[][] edges; private int numOfEdges; public Graph2(int n) { this.edges = new int[n][n]; this.vertexList = new ArrayList&lt;Vertex&lt;E&gt;&gt;(n); this.numOfEdges = 0; } public int getNumOfVerter() { return vertexList.size(); } public int getNumOfEdges() { return numOfEdges; } public E getValueByIndex(int index) { return vertexList.get(index).getLabel(); } public int getWeight(int v1, int v2) { return edges[v1][v2]; } public void showGraph() { for (int[] val : edges) { System.out.println(Arrays.toString(val)); } } public void insertVertex(Vertex&lt;E&gt; vertex) { vertexList.add(vertex); } public void insertEdge(int v1, int v2) { insertEdge(v1, v2, 1); } public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; ++numOfEdges; } } 下面我们去主方法进行一次测试，看看代码是否存在一些问题。 public static void main(String[] args) { int n = 5; Graph2&lt;String&gt; graph = new Graph2&lt;String&gt;(n); String[] vertexValues = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; for (int i = 0; i &lt; vertexValues.length; i++) { graph.insertVertex(new Vertex&lt;String&gt;(vertexValues[i])); } graph.insertEdge(0, 1); graph.insertEdge(0, 2); graph.insertEdge(1, 2); graph.insertEdge(1, 3); graph.insertEdge(1, 4); graph.showGraph(); } 输出的结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0] 到此为止，一个图就已经创建完成了。下面我们开始研究图的遍历的问题。 图的遍历图的遍历和树的遍历一样，也有两种。一个广度优先遍历，一个是深度优先遍历。之前在将树的遍历的时候就讲了这个是如何实现的了。不过图的遍历和树的遍历又是不一样的了，图中是没有指针来连接各个节点的。所以说只是遍历的思路是一样的，算法还是完全不同的。树的遍历用到了队列和栈，不过图是不需要的。 深度优先遍历 深度优先遍历的思路 深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是： 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。 然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。 简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止 这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。 如图所示： 深度优先搜索的算法比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。 代码实现首先我们要写找到临近节点的函数 public int getFirstNeighbor(int index) { for (int j = 0; j &lt; getNumOfVerter(); j++) { if (edges[index][j] &gt; 0) {// 表示两个节点是相通的。 return j; } } return -1; } public int getNextNeighbor(int v1, int v2) { for (int j = v2+1; j &lt; getNumOfVerter(); j++) { if (edges[v1][j] &gt; 0) { return j; } } return -1; } 然后就可以写深度优先遍历的代码了 // 图的深度优先遍历(DFS) private void depthFirstSearch(int i) { System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); int w = getFirstNeighbor(i); while (w != -1) { // 如果第一个邻近顶点w没有被访问过，就直接以他作为开始继续深度优先 if (!vertexList.get(w).isVisited()) { depthFirstSearch(w); }else { // 如果已经被方位过了，就继续寻找下一个w，如果等于-1的话就说明，没有邻近定点了，退出循环即可。 w = getNextNeighbor(i, w); } } } public void depthFirstSearch() { initVisit(); // 图并不一定是连通的，我们要对每一个顶点都作为开始判断一下，是否有没有被访问过的节点。 for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { depthFirstSearch(i); } } } // 初始化visit，防止之前已经进行过什么遍历了，再次遍历就会出问题。 public void initVisit() { for (Vertex&lt;E&gt; val : vertexList) { val.setVisited(false); } } 代码说明： 大部分的内容我都在上面的注释中进行过说明了，而且这个图的深度优先的遍历确实是有一点儿简单，所以没什么说的也是很正常的，看懂我注释基本上的明白了图的深度优先遍历的。 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 广度优先遍历 广度优先遍历的思路 广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是： 首先访问出发点Vi 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。 如图所示： 简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层 广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下： 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中; 从图中取下一个顶点v，添加到已访问的顶点列表 将所有与v相邻的未访问顶点添加到队列。 可见这个图的广度优先遍历和树的广度优先遍历还是有点儿相似的，都是使用队列这个数据结构来实现的。深度优先遍历不一样，树使用的是栈这个数据结构。 代码实现// 广度优先遍历(BFS) private void broadFirstSearch(int i) { int u; // 队列的头节点对应的下标 int w; // LinkedList实现了队列的接口，所以说可以拿来当队列来使用 LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); queue.addLast(i);// 入队列 while (!queue.isEmpty()) { u = queue.removeFirst();// 出队列 w = getFirstNeighbor(u); while (w != -1) { if (!vertexList.get(w).isVisited()) { System.out.print(getValueByIndex(w) + &quot;-&gt;&quot;); vertexList.get(w).setVisited(true); queue.addLast(w); }else { w = getNextNeighbor(u, w); } } } } public void broadFirstSearch() { initVisit(); for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { broadFirstSearch(i); } } } 代码说明： u和w是什么含义？ u表示的是队列中的第一个顶点，也就是说出队列的那个顶点。w和上面的深度优先是一样的，都是表示的是当前顶点的下一个邻接顶点。 两个while循环？ 先看第二个while循环，如果这个邻接顶点w没有被访问过，那么我们就方位，不然我们就找u的下一个邻接顶点。其实这个也是很好理解的。如果这个while循环结束的话，那么也就是以为着u的所有的邻接顶点都被访问过了。那么我们就访问u的邻接顶点的所有的邻接顶点。刚才的u的所有的邻接顶点都已经入队列了。我们只需要按顺序让他们出队列就行了。如果第一个while循环也结束了，那就说明u的所有的可以连通的顶点都通过广度优先遍历访问玩了。但是这并不意味着图就遍历完了。上面也说过了，图可能不是连通的。所以就有了下面的那个函数来做保证 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 和深度优先遍历输出的结果竟然是一样的，不过这个例子是纯属巧合而已 总结上面我表示图是用的邻接矩阵的方式，还可以使用邻接表的方式来表示这个图结构，而且效率也是有点儿小高。不过这里我就不瞎掰了，就先介绍一个邻接矩阵就完事了。感觉图的 BFS和DFS比树的真的是差不多，至少理解其实都不是很难。 参考文章：数据结构与算法：图和图算法(一)扩展文章：数据结构与算法 - 图论]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（一）单例模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式基本介绍单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单例模式的基本思路实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 单例模式的实现饿汉式public class SingletonTest01{ public static void main(String[] args) { // Singleton01 singleton01 = new SingletonTest01(); Singleton01 singleton1 = Singleton01.getInstance(); Singleton01 singleton2 = Singleton01.getInstance(); System.out.println(&quot;singleton1:&quot;+singleton1.hashCode()); System.out.println(&quot;singleton2:&quot;+singleton2.hashCode()); } } class Singleton01 { // 静态变存储唯一的实例化对象 private static final Singleton01 INSTANCE = new Singleton01(); // 构造器私有化 private Singleton01() {} // 提供唯一的实例化对象 public static Singleton01 getInstance() { return INSTANCE; } } 像这样子实现单例模式，似乎是已经足够了。但是这样子做的效率不是非常高，因为当我们创建这个类的时候，无论有没有使用到这个类的实例都会产生这个对象，所以说这样子的单例模式的代码不具有懒加载性，需要改进。不过值得鼓励的是，这样的代码在多线程的模式下，不会产生任何的混乱，这也算是他的一个优点吧。 输出结果： singleton1:1534030866singleton2:1534030866 懒汉式public class SingletonTest02 { public static void main(String[] args) { Singleton02 singleton1 = Singleton02.getInstance(); Singleton02 singleton2 = Singleton02.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton02{ private static volatile Singleton02 INSTANCE; private Singleton02() { } public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } } 代码说明： volatile关键词？ 这个关键词C++中也有使用，但是也是非常的少见，基本上没有人用。 被volatile修饰的共享变量，就具有了以下两点特性： 1.保证了不同线程对该变量操作的内存可见性; 2.禁止指令重排序 volatile这个东西基本上都和多线程有关系，这里就不作深究了。 两个if判断和synchronized(Singleton02.class) 为了实现懒加载，我们要做的是在调用getInstance这个方法的时候才去构建这个对象，不过考虑到多线程的情况下。如果直接是这样子写的话 public static Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 这个代码在单线程的情况下是一点问题都没有的。但如果是多线程的环境下，有多个线程同时进入了if语句就会构建许多的对象，这就不是单例模式了，所以说这样的代码不能够使用。 那是不是加个锁就行了呢？ public static synchronized Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 确实是这样子代码确实就能用了，但是又不出现了一个新的问题。线程的同步是要花很多时间的。你一个线程调用这个函数其他的线程都要等你这个线程，这显然是效率太低了。 那行，咋继续改，不给方法加锁，只是给new语句加锁不就完事了嘛。** public static Singleton02 getInstance(){ if (INSTANCE == null){ synchronized(Singleton02.class){ INSTANCE = new Singleton02(); } } return INSTANCE; } 给整个if语句加锁就相当于是给整个方法加锁，所以说是没有用的。这里给new语句加锁。不能说是效率低的问题了，是直接错误的。事实上，完全有可以多个线程同时进入了if语句内，虽然new加锁了，那几个进入if语句的线程都会执行new语句，破坏了单例模式。 那怎么改呢？这就到了我们代码中的那个双重检查锁了。 public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } 这时虽然也会有多个线程进入if语句，但是里面还有一个带锁的if，这时第一个线程进入创建对象之后，后面的线程因为if的判断就无法创建对象了，实现了单例模式。 要非常注意的是，前面的INSTANCE要声明为volatile（JDK5以后的版本），不然这个模式使用的失败的。这里我去看了极客班的C++的设计模式的教程，如果没有volatile关键词的话，这个是错误的是不能够使用的。为什么呢？在INSTANCE = new Singleton02()这个语句中，正常我们会想这个应该会先分配内存，然后开始构造函数，再然后把地址赋给INSTANCE。但是由于编译器的优化以及各种其他的情况下，任何语言可能都不是这样子的。大多数情况下，可能是先分配内存，然后直接赋地址，最后再构造函数，也可以是先赋地址，然后再怎么怎么样的。这种情况被称为reorder。这是如果有一个线程进入第一个if，发现你已经赋给地址了，已经不是空了，所以直接就返回，但是构造函数还没有开始启动，这是会发生什么错误是不用说了。加上了volatile之后就是告诉编译器，别给我优化，别给我整这些reorder。C++11当中也引入了这个问题的解决方案，不过确实是有点儿复杂，这里就不多说什么了。 输出结果： singleton1:1534030866singleton2:1534030866 静态内部类使用静态内部类的性质来实现线程的同步。静态内部类中的静态数据只有被类第一次被使用到的时候创建，而且这个还是线程安全的，这都是由JVM来保证的。所以说这种方法也是非常好滴。代码也很易懂，不用做什么说明了。 public class SingletonTest03 { public static void main(String[] args) { Singleton03 singleton1 = Singleton03.getInstance(); Singleton03 singleton2 = Singleton03.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton03{ private Singleton03() {} // 使用静态内部类 private static class SingletonInstance { private static final Singleton03 INSTANCE = new Singleton03(); } public static Singleton03 getInstance() { return SingletonInstance.INSTANCE; } } 输出结果： singleton1:664223387singleton2:664223387 枚举式使用了JDK1.5中添加的枚举来实现单例模式。不仅以及避免多线程同步的问题，而且还可以防止反序列化创建新的对象。而且这种方法也是《Effective Java》中推荐的方法。 public class SingletonTest04 { public static void main(String[] args) { Singleton04 singleton1 = Singleton04.INSTANCE; Singleton04 singleton2 = Singleton04.INSTANCE; System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } enum Singleton04 { INSTANCE; } 这个方法可谓是简单而又粗暴，而且枚举类也是类，里面也可以有各种方法，也可以有private数据等。这里就不展开对Java中enum的说明了。 输出结果： singleton1:1534030866singleton2:1534030866 C++中的单例模式// ... class lock { public: lock(); lock(lock const &amp; l); ~lock(); lock &amp; operator =(lock const &amp; l); void request(); void release(); // ... }; lock::lock() { // ... } // ... lock::~lock() { // ... } // ... void lock::request() { // ... } void lock::release() { // ... } // ... // assumes _DATA_TYPE_ has a default constructor template&lt;typename _DATA_TYPE_&gt; class singleton { public: static _DATA_TYPE_ * request(); static void release(); private: singleton(); singleton(singleton&lt;_DATA_TYPE_&gt; const &amp; s); ~singleton(); singleton&lt;_DATA_TYPE_&gt; &amp; operator =(singleton&lt;_DATA_TYPE_&gt; const &amp; s); static _DATA_TYPE_ * pointer; static lock mutex; // ... }; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; template&lt;typename _DATA_TYPE_&gt; lock singleton&lt;_DATA_TYPE_&gt;::mutex; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::request() { if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::pointer = new _DATA_TYPE_; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } return singleton&lt;_DATA_TYPE_&gt;::pointer; } template&lt;typename _DATA_TYPE_&gt; void singleton&lt;_DATA_TYPE_&gt;::release() { if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { delete singleton&lt;_DATA_TYPE_&gt;::pointer; singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } } template&lt;typename _DATA_TYPE_&gt; singleton&lt;_DATA_TYPE_&gt;::singleton() { // ... } // ... int main() { int * s; s = singleton&lt;int&gt;::request(); // ... singleton&lt;int&gt;::release(); return 0; } 这个代码着实有点儿难懂，而且我现在还没有接触到C++中的多线程。所以说，代码先放在这儿吧。C++真的是一门高深莫测的语言！ Java库中的单例模式Java.lang.Runtime /** * Every Java application has a single instance of class * {@code Runtime} that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the {@code getRuntime} method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since 1.0 */ public class Runtime { private static final Runtime currentRuntime = new Runtime(); private static Version version; /** * Returns the runtime object associated with the current Java application. * Most of the methods of class {@code Runtime} are instance * methods and must be invoked with respect to the current runtime object. * * @return the {@code Runtime} object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don&#39;t let anyone else instantiate this class */ private Runtime() {} //..... } 可以看到这个使用的第一个，典型的饿汉式的单例模式。因为这个类不需要多线程，所以也没有必要使用懒汉式，这个饿汉式就是perfect的啦~~ 总结 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须要记住使用对应的获取对象的方法，而不是使用new。 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL Tree]]></title>
    <url>%2F2019%2F07%2F25%2FAVL-Tree%2F</url>
    <content type="text"><![CDATA[AVL TreeAVL Tree的基本介绍AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.来自：GeeksforGeeks 在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。来自：Wikipedia 现在我们看AVL数的中文，自平衡二叉查找树，这个平衡我们从定义中看出来了：任一节点对应的两棵子树的最大高度差为1，那么二叉查找树的概念呢？似乎没有说明，其实二叉查找树(BST)也是一种独立的树结构。那么我们就先来了解一下BST BST的基本介绍二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 比如说上面的这棵树就是一个二叉查找树。 构造BST那么我们该如何构造一颗BST呢？添加节点的时候，当树为空的时候就直接插入节点作为根节点。不然当小于节点且左子树不为空的递归加入左子树，大于节点且右子树不为空的时候加入右子树。左右子树为空的时候就直接插入作为左右子树。 这个思路还是特别的简单的直接按照BST的规则来就完事了。 节点代码实现class Node{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } @Override public String toString() { return &quot;Node [value=&quot; + value + &quot;]&quot;; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } public void add(Node node) { if (node.value &lt; this.value) { if (this.left == null) { this.left = node; return; }else { this.left.add(node); } }else { if (this.right == null) { this.right = node; return; }else { this.right.add(node); } } } //：用于后面的AVT平衡二叉树的操作 public int height() { return Math.max(left == null?0:left.height(), right == null?0:right.height()) +1; } public int leftHeight() { if (left == null) { return 0; } return left.height(); } public int rightHeight() { if (right == null) { return 0; } return right.height(); } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } public Node search(int value) { if (this.value == value) { return this; } if (value &lt; this.value) { return this.left.search(value); }else { return this.right.search(value); } } public Node searchParent(int value) { if (this.left != null &amp;&amp; this.left.value == value) { return this; } if (this.right != null &amp;&amp; this.right.value == value) { return this; } if (value &lt; this.value) { return this.left.searchParent(value); }else { return this.right.searchParent(value); } } /** * 找到左子树上最大的节点的父节点 * @return 左子树上最大的节点的父节点 没有左子树就返回null */ public Node findLeftMaxParentNode() { if (this.left == null) { return null; } Node temp = this.left; if (temp.getRight() == null) { return this; } if (temp.getRight() != null &amp;&amp; temp.getRight().getRight() != null) { temp = temp.getRight(); } return temp; } /** * 找到右子树上最小的节点的父节点 * @return 右子树上最小的节点的父节点， 没有右子树就返回null */ public Node findRightMinParentNode() { if (this.right == null) { return null; } Node temp = this.right; if (temp.getLeft() == null) { return this; } if (temp.getLeft() != null &amp;&amp; temp.getLeft().getLeft() != null) { temp = temp.getLeft(); } return temp; } } 可见由一个数组构造一个BST还是非常容易的。 BST代码实现class BinarySearchTree { private Node root = null; public BinarySearchTree(Node root) { this.root = root; } public BinarySearchTree() { this.root = null; } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; } public void add(Node node) { if (root == null) { root = node; return; } this.root.add(node); } public int height() { return this.root.height(); } public int leftHeight() { return this.root.leftHeight(); } public int rightHeight() { return this.root.rightHeight(); } public void infixOrder() { if (root == null) { return; } this.root.infixOrder(); } /** * 搜索节点 缺点是重复的值会出现问题，值不能重复 * @param value 要查询的值 * @return 返回找到值的当前节点 找不到就返回null */ public Node search(int value) { if (root == null) { return null; } return this.root.search(value); } /** * 搜索父节点 缺点是值不能重复 * @param value * @return 返回找到值的父节点， 找不到就返回null */ public Node searchParent(int value) { if (root == null) { return null; } if (root.getValue() == value) { return null; } return this.root.searchParent(value); } public Node findLeftMaxParentNode() { return root.findLeftMaxParentNode(); } public Node findRightMinParentNode() { return root.findRightMinParentNode(); } /** * 删除节点 * @param value * @return */ public boolean delNode(int value) { Node node = search(value); Node parent = searchParent(value); if (node == null) { return false; } if (parent == null) { if (root == null) { return true; }else { //：要删除的节点就是根节点 Node leftMaxParentNode = findLeftMaxParentNode(); // System.out.println(leftMaxParentNode.getRight().getValue()); if (leftMaxParentNode == null) { root = root.getRight(); return true; }else { if (leftMaxParentNode == root) { this.root.setValue(this.root.getLeft().getValue()); this.root.setLeft(null); return true; }else { this.root.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } } // 是一个叶子节点 if (node.getLeft() == null &amp;&amp; node.getRight() == null) { if (parent.getLeft() == node) { parent.setLeft(null); }else { parent.setRight(null); } return true; } // 只有一个右子节点 if (node.getLeft() == null) { if (parent.getRight() ==node) { parent.setRight(node.getRight()); return true; }else { parent.setLeft(node.getRight()); return true; } } if (node.getRight() == null) { if (parent.getRight() == node) { parent.setRight(node.getLeft()); return true; }else { parent.setLeft(node.getLeft()); return true; } } // 有两个节点的 Node leftMaxParentNode = node.findLeftMaxParentNode(); if (leftMaxParentNode == node) { node.setValue(node.getLeft().getValue()); node.setLeft(null); return true; }else { node.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } 可以看到上面的代码还是特别的多的，因为这个代码都是我学习的时候写的，这里就直接复制过来了。里面很多的方法都是为了AVL来写的。其实里面有几个函数还是比较难写的，比如那个删除节点的那个函数我就写了不少的时间，不过，这里这个问题都不是重点了。我们主要说的是AVL树。 从BST到AVL虽然说BST是蛮好的，中序遍历一个BST我们就能得到一个有序的数组，这个是多么的方便。但是BST也存在了一些问题。比如说我给定的数组是1 2 3 4 5 6使用这个数组构造BST的时候，我们发现构造出来一个非常奇怪的树。 1 2 3 4 5 6一个如同单链表的BST，但是效率比单链表还要低。有些人会说，我们可以使用中位数作为节点来构造二叉树，但是这个依然是有问题的。 4 3 5 2 6 1 7这棵树是效率高的吗？童谣也不是，效率和单链表其实也差不多。 是什么导致这些BST的效率很低的？因为这些树不平衡，这就可以联系到上面的AVL中关于平衡的定义了。左右子树的高度差不大于1。而且是所有的子树的左右子树的高度差都不大于1。所以说上面的两棵树都不是AVL。 An Example Tree that is an AVL Tree The above tree is AVL because differences between heights of left and right subtrees for every node is less than or equal to 1. An Example Tree that is NOT an AVL Tree The above tree is not AVL because differences between heights of left and right subtrees for 8 and 18 is greater than 1. Insertion Examples: AVL代码实现class AVLTree extends BinarySearchTree { public AVLTree() { this.setRoot(null); } public AVLTree(Node rootNode) { this.setRoot(rootNode); } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } //：左旋转， 当左子树的高度小于右子树的高度时候可以降低两者之间的差值，使之成为平衡树 public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } //：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } } 旋转 由BST到AVL左旋转public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } 左旋转是非常的形象的。当右子树的高度大于左子树的高度的时候，我们将树进行左旋转这样就可以平衡左右子树之间的高度之差。 如何左旋转： 以当前节点（根节点）值构造一个新的节点。 新节点的左指针指向根节点的左子树 新节点的右指针指向根节点的右子树的左子树。 根节点的左子树指向新节点。 将根节点的右子树的值赋给根节点 根节点的右指针指向根节点的右子树的右子树 这个看起来可能很懵逼，不过看着下面的图基本上就可以理解了。理解之后你也会发现这个这个左旋转会存在一些问题。 右旋转//：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } 右旋转与左旋转类似，这里不再赘述、 恐怕你已经发现了问题，就是原本是1 3的树经过左旋转之后会变成 3 1。 这是如果再使用右旋转又会变成1 3。这个是非常有问题的。那么问题出在了那么了呢？ 我当我们进行右旋转的时候，们将根节点的右子树树指向的是新的节点，新节点的左子树指向的是根节点的左子树的右子树，那么如果根节点的左子树的左子树的高度小于其左子树的右子树的高度上呢？这时就会引发这个问题。此时我们虽然是想右选择的。但是右子树上的新的节点的左子树连接这那个比较大的根节点的左子树的右子树，这时旋转之后右子树就会变得高，不会形成一个AVL。此时需要平衡一下根节点的左子树，使左子树先来一次左旋转 左旋转也是类似的道理。因此需要将左右旋转结合起来写一个新的函数。 左右旋转结合public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } 这样我们的AVL就完成了，上面的代码都已经做了说明，不想说了。而且这种二叉树的问题，说明是真的难说，还是自己拿一个笔多画一画就完事了，画着画着就可以理解其中的大智慧了。 上面的图可能看起来有点儿懵逼，不过我感觉画的特别的形象。主要讲了旋转的事情。要结合上面的代码一起进行消化理解吸收。 总结这个讲的稍微的敷衍，不过也没有办法，我主要想说的就是AVL的旋转而已，但是又是用语言难以理解的，于是上外网盗了一些图片过来辅助理解，不知道下次这些图片会不会么得了，嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sunday字符串匹配算法]]></title>
    <url>%2F2019%2F07%2F25%2FSunday%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Sunday字符串匹配算法Sunday算法的基本介绍字符串匹配的算法其实之前就已经说过一个KMP算法了，不过现在我还是有点儿不理解KMP算法中next数组中的精髓。其实关于字符串匹配的算法基本有以下的四种。BF算法，这个就是我们在说KMP算法中的那个暴力匹配的那个算法。其次就是KMP算法，也就一种比较难以理解的算法。然后是BM算法，据说是KMP算法的优化，不过实在是恐怖，我看着也十分的复杂，根本没有看的兴趣。最后一个就是Sunday算法，且不论这个算法到底怎么样，就凭这个算法的名字也要努力学习吖。Sunday~多暖的名字吖。关键是我听说Sunday算法简单高效易理解！！！ Sunday算法的基本思路Sunday算法和BM算法稍有不同的是，Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1； 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。 可以说这个思路是非常的亲民了。 下面举个例子来了解一下Sunday算法: 参考文章：字符串匹配之Sunday算法 由此可见在这个例子中，Sunday算法的效率还是非常高的，不过也可以看出来，Sunday算法也是有一点儿不稳定的。如果每次都发现后面的那个元素和最后一个相同，那么这个就变成了BF暴力匹配的算法了。 代码实现这里博主使用的是Java，那我就不使用Java，用C++吧，我还是喜欢我的vscode。。。蛤蛤蛤 /** * Sunday字符串匹配算法 */ #include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; const int ASCII_SIZE = 128; int sunday(string str, string sub) { int strLength = str.size(); int subLength = sub.size(); int move[ASCII_SIZE]{0}; for (size_t i = 0; i &lt; ASCII_SIZE; i++) { move[i] = subLength + 1; } for (size_t i = 0; i &lt; subLength; i++) { move[sub[i]] = subLength - i; } int i = 0; int j = 0; while (i &lt;= strLength - subLength) { j = 0; while (str[i + j] == sub[j]) { j++; if (j &gt;= subLength) { return i; } } i += move[str[i + subLength]]; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABDE&quot;; int index = sunday(str, sub); // cout &lt;&lt; sub &lt;&lt; endl; // cout &lt;&lt; str.substr(index, sub.length()) &lt;&lt; endl; cout &lt;&lt; (sub == str.substr(index, sub.length()) ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 代码说明： ACSII_SIZE和move是什么意思？ ACSII_SIZE常用的字符有128个（键盘上可以找得到的），还有另外的128个是找不到的，所以这里我们只使用128而不是256。说到Sunday算法规则的时候我们也提到了。每次匹配失败往后移动多少位完全是取决于匹配失败时子串对应的后一个字符。（可以看上面的图进行理解），所以说每个字母都对应了一个移动的位数。我们可以用一个数组来存储移动的位数。比如说字母a要移动六位就是——move[‘a’] = 6 也就是 move[97] = 6（a对应的ascii值是97） 第一个for循环？ 当字母没有出现的时候，移动位数 = 模式串长度 + 1 第二个for循环 当字母出现的时候， 移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。不过上面说的是最右出现的位置，这里没有考虑啊。此言差矣，其实考虑了，i是从左到右进行覆盖的，如果出现了重复的字符，move数组里面存放的肯定是最右面的那个字符对应的移动位数。 i, j与while循环 i表示的指向主串的开始的位置。j表示的指向字符正在匹配的字符的位置。注意：这里i并不是指向当前正在比较的字符的位置。当前主串中正在匹配的字符的位置是i+j。每次匹配失败的时候，i向后面移动相对应的位置。j重置为0重新进行比较。 总结不得不说，这个Sunday算法真的简单易理解，关键代码还很好写，效率也非常高。这特喵的谁还看那个什么KMP算法啊。那个啥BM算法反向比较致敬韦神我是更不可能去看的了。不管了，反正Sunday算法赛高就完事了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与回溯]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[递归与回溯关于递归与回溯其实之前我们已经遇到了好多的递归的问题了，比如说动态规划里面的就用到了不少的递归，那种递归也可以转换成为递推。但是这里我们讲的是递归与回溯。何为回溯？ 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 可以看出来递归其实是回溯的一个实现条件，一个算法既然和递归联系起来了，那免不了麻烦的事情，回溯法也是如此，需要我们对递归有着深层次的理解，才能够游刃有余的掌握。 看一下网上对回溯法的一些说明： 回溯法一般都用在要给出多个可以实现最终条件的解的最终形式。回溯法要求对解要添加一些约束条件。总的来说，如果要解决一个回溯法的问题，通常要确定三个元素： 选择。对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列。 条件。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。 结束。当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。 对于回溯法来说，每次递归调用，很重要的一点是把每次递归的不同信息传递给递归调用的函数。而这里最重要的要传递给递归调用函数的信息，就是把上一步做过的某些事情的这个选择排除，避免重复和无限递归。另外还有一个信息必须传递给递归函数，就是进行了每一步选择后，暂时还没构成完整的解，这个时候前面所有选择的汇总也要传递进去。而且一般情况下，都是能从传递给递归函数的参数处，得到结束条件的。 递归函数的参数的选择，要遵循四个原则：1、必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。2、可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。3、最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。 4、要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。 递归与回溯的经典案列迷宫问题基本介绍看到之前回溯的概念我们可以非常轻易的想到迷宫问题。走不通就退回再走的技术为回溯法，迷宫不也是走不通就退回再走吗，非常的符合回溯法的使用条件。 至于迷宫问题的题目我就不多说了，就以下面的数组为例，起始点假如规定在左上角的[1][1]处，目标终点在右下角的[10][25]，请走迷宫，并显示程序所走的路径。下图中0表示路，1表示墙。** map = new int[][] { {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1}, {1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1}, {1,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,0,0,0,1}, {1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1}, {1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1}, {1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1}, {1,0,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1}, {1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1}, {1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} }; 思路分析我们很容易想到回溯但是到底如何回溯呢？我们要告诉程序如何去走这个迷宫，第一点就是，当四条路都可以走的时候我们怎么走？这是最关键的，我们要给程序设定一个初识的目标，遇到多路口先走什么。 0 0 x 0 0这时我们可以规定一个策略就是先走右面，如果右面不通再走下面，如果再不通就走上面，如果还是不通就走上面。 使用→↓←↑的策略进行这一场的迷宫游戏。 那么有没有可能出现这样一种情况，四条路都不通。——怎么可能四条路都不通，四条路都不通你是怎么进来的？？？ 唉~你错了，还真的有四条路都不通的情况，比如如下的图。 ↓ 1 0 1 1 x 1 1 1 1不对啊，这条路上面不是通的吗？往上走不就完事了吗？但是我们是就是从上面下来的，还能再回到上面去吗？所以我们有必要把我们走过的路进行标记比如标记为2。如果走路的这个路确定是死路了，我们还可以将他标记为3，以和我们走过的路正确的路径进行区分。如果四周都是墙或者走过的路，那么这条路的递归就结束，回到选择这个递归的那个路口，开始下一条路的递归。这就是回溯的过程这样说可能很难听懂，不过看到了代码可就算是柳暗花明了。 代码实现处于路口(迷宫的某一个点)时找路的代码// 递归与回溯 private boolean findWay(int i, int j) { // count++; // 只有走到了目标终点的位置这个函数才会返回true if (map[map.length - 2][map[0].length - 2] == 2) { return true; } else { // == 0 代表这条路还没有走过 if (map[i][j] == 0) { // 设为2 假定这条路可以走了 map[i][j] = 2; // 找路的策略是： // 向下 -》 向右 -》 向上 -》 向左 if (findWay(i + 1, j)) { return true; } else if (findWay(i, j + 1)) { return true; } else if (findWay(i - 1, j)) { return true; } else if (findWay(i, j - 1)) { return true; } else { // 四条路都走不通了 map[i][j] = 3; return false; } } else { // 不是0可能是 1 2 3，反正就是不能走这条路 return false; } } } 代码说明： 这个函数的返回值是什么意思？ 函数的返回值是boolean，他只有在一个情况上返回的 是true，那就是走到了目标终点了。虽然下面也有几个return true，但是那些return true都是依靠if里面为真，而if里面为真只是依靠找到终点了。 下面的if为0是什么意思？ 让我们找路给我们的坐标是i，j如果给定的就是一堵墙，走过了的或者死路，当然要返回false，让它进行下一个路口的探索。也就是下右上左的次序进行走路（其实什么顺序都可以啦，没什么太重要的，都可以走到终点的）。 最后的那个else returnfalse是？ 这说明前面的四个递归返回的都是false，说明什么？四条路都是走不通的，那么就把这个点置为死路点，标记为3。 那这个不是只有一个点是3吗？？死路就这是一个点？ 不是的，当这个点被置为死路3的时候，递归会回溯。比如下面的这个路。 1 2 1 1 3 1 1 1 1（1,1）被标记为3之后，可别忘了(1,1)点是从(0,1)点走过来的。走路的顺序是下右上左。(0,1)点的下面返回false，于是走右面，不通，走上面，走过了，走左面，不通，于是(0,1)也被置为了3。 所以说被置为3的是通往死路的那一整条路啦~~递归就是这么神奇。 这个findWay函数写完了，直接调用findWay(1,1)就可以进行迷宫的探索了。（我们规定的是1,1是起点了） 迷宫的输出结果==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # X X X X # # # # # # # # # X # # # X # # X X X X X # # # # # # # # X # # # # # X # # N # # # X # # # # # # # # X # X X X # X X X # # # # X # # # # # # # # # # X # X # X # X X X N N # # X # # # # # # # X X X # X # X # # # N # # X # # # # # # # # # # # X # X # # # # # X # # # # # X X X X X X X # X # # # # # X # # # # # # # # # X # # # # # # X X # # # # X X X X X X X X X # # # X X X X X X X X # # # # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 这里我们使用#表示墙，X表示正确的路径，N表示走过的死路。空白的区域就是没有走过的路。可见这个下右上左的策略还是蛮不错的，走过的死路是比较上的。如果我们换成左上右下，那么结果又是如何呢？ ==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # N N N N X X X X X X # # N N N N N # # N # # # # # X # N N # # X # # N N X X X # # N # N # # N # # # N N X # # # # # X # # N # # # X # # N # N N N N # # # # # X # X X X # X # # # # X # # N # # # # # # # N N # X # X # X # X # # X # # N # N # N N # # N N # X X X # X # X # # # # # X X N N # N # # N # # N # # # # # # X # X # # N # # # X X # # # N N N N # # N X X X X X X X # X # # N # # # X X # # # # # # N # # # X # # # # # # X X # # N # # N N X X X X X X X X # # # X X X X X X X X # # # N N N N # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 可以看出走过的死路是非常多的，但是无论怎么说都是可以到达终点的。毕竟我们这个题目是从左上角到右上角，我们选定的策略肯定是选右下啊。 在不知道起点终点的时候，我们可以四个策略都使用一下，看看哪个策略走的次数是最少的（有效的路，不算死路)。前面我的代码中也使用了count来计数，就是为了这一点。这样我们基本就可以确定走迷宫的最优路径了。 八皇后问题基本介绍这个题目可以说是非常著名了，我学python的时候就在研究这个问题，但是当时怎么研究都研究不出来到底怎么解决这个问题。递归这种事我们都是不敢想的（递归那该有多难啊），回溯根本不知道回溯是什么玩意。不过现在有个递归和回溯这个武器，八皇后问题可以说只用几行代码就完事了。看一下百度百科对八皇后问题的解释 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。 现在有个计算机，什么八皇后，就是八十皇后都么得问题。 思路分析上面也说了，八皇后问题同样是回溯算法的典型案列。那么这个问题该如何回溯呢？迷宫问题是路走不通了我退回去重新走其他的路，那八皇后也很好理解了。皇后放不了了，我换其他地方重新放。 我们可以选择一行一行的放置皇后，这个显然不会对结果产生什么影响，你要是乐意一列一列放也是可以的。 大多数人解决这个问题都喜欢使用二维数组，第一个表示行，第二个表示列，数组的值表示有没有放置过皇后，我承认这样可行。但是真的有必要使用二维数组吗？我们使用一维数组不可以解决这个问题吗？比如使用一个一维数组int[8]。int[0]表示第一行皇后所在的列，我们只要按顺序去放置int[1],int[2]里的值就完事了，这不是很好喵~ 下面就该说说八皇后的回溯了。首先我们也要和迷宫一样确定如何放置皇后，这里其实很容易，直接从第一列开始依次往后尝试呗。（这也是正常人的思想）如果某一列不可以放置皇后(要写个函数进行判断)，就往后放，如果已经是最后一列了。就直接返回false。回到上面的一行(回溯算法)，重新按顺序放置皇后。如果可以放置，就进入下面一行放置皇后，如果第八行的皇后都放置OK了就返回true，这是一种皇后的放置方法已经完成了，不过我们需要循环找到所有的皇后的放置的方法。 代码实现判断是否可以放置皇后private boolean isValid(int n) { ++count2; for (int i = 0; i &lt; n; i++) { // 在同一列或者说是在同一个斜线上 if (map[i] == map[n] || Math.abs(map[n] - map[i]) == Math.abs(n - i)) { return false; } } return true; } 代码说明： count2++ 这个是后面用来统计进行了多少次的皇后判断用的。 map[i] == map[n]? 我们说过了一维数组的值表示的是皇后所在的列，如果map[i] == map[n]那么就说明放置的皇后在同一列，返回的false。 Math.abs(map[n] - map[i]) == Math.abs(n - i)? 这个代表的意义就是列差的绝对值是等于行差的绝对值的。这个我都是使用斜率来理解的。斜率为1或者-1，那么两个 皇后就是在一天斜线上！斜率为其他值的就不算一天直线了吧，国际象棋的规则明白吧老弟~ 这里我们只是和n前面那的皇后进行比较，那么后面呢？ 后面个锤子啊，我们放置皇后的顺序是从第一列一次到第八列，后面的皇后还都没有放呢，当然不用来比较。 在某一行开始放置皇后private void check(int n) { if (n == max) { // 输出解决方案 System.out.printf(&quot;%-3d&quot; + &quot;: &quot; + Arrays.toString(map) + &quot;\n&quot;, ++count); return; } for (int i = 0; i &lt; map.length; i++) { map[n] = i; if (isValid(n)) { check(n + 1); } } } 代码说明： 我只知道System.out.println，那个printf是什么鬼？ 没学过c吗？printf是Java中用于格式化输出的语句，%-3d的意思就是三位数的整数，左对齐。 后面的for循环是？？？ 如果不加上for循环的话我们啥都得不到，而且肯定是前面几个皇后的列值都很小的。比如说没有for循环的时候我们使用check(0)就是放置第一个皇后，第一个皇后置为i(一开始也就是0，因为没有for循环)，然后看在i处放置合不合理。如果合理就开始放置下面一个皇后，但是倘若是不合理呢？？不合理是不是直接就没了，程序也不会尝试其他的路径了。 如果加上这个for循环。合理自然很好，一路往下走。假如遇到了不合理的。（就算是合理的也会往后的）那for循环就会执行给我们尝试后面的列是否可行。如果for循环结束了都是不可行的。那么这一层的递归就结束了。就会返回上一层的递归。（就算这个合理了也是会返回上一层的递归的），在上一层寻找其他的放置皇后合理的地方。就这样一直回溯就可以找到八皇后的所有的解了。递归是真的神奇~~比如之前一直都不理解的归并排序。 测试代码public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;Slove N Queue Problem: &quot;); int num = scanner.nextInt(); Queue8 queue8 = new Queue8(num); System.out.println(&quot;=====THE SOLUTION OF &quot; + num + &quot;QUEUE PROBLEM=====&quot;); long start_time = System.currentTimeMillis(); queue8.check(0); long end_time = System.currentTimeMillis(); System.out.println(); System.out.println(&quot;=====================SUMMARY=====================&quot;); System.out.println(&quot;THE NUMBERS OF &quot; + num + &quot;QUEUE SOLUTIONS IS &quot; + count); System.out.println(&quot;THE NUMBERS OF JUDGES IS &quot; + count2); long time = end_time - start_time; System.out.println(&quot;THE TIME USED IS &quot; + time + &quot;MS&quot;); } 8皇后 =====================SUMMARY===================== THE NUMBERS OF 8QUEUE SOLUTIONS IS 92 THE NUMBERS OF JUDGES IS 15720 THE TIME USED IS 1MS这里的解决方案没有输出，因为太长了，顶不住啊。由此可见是92种，看来天才高斯也有错误的时候啊~~嘤嘤嘤 12皇后 =====================SUMMARY===================== THE NUMBERS OF 12QUEUE SOLUTIONS IS 14200 THE NUMBERS OF JUDGES IS 10103868 THE TIME USED IS 154MS20皇后 ..... 等了好长的时间（20秒）都没有输出，这个判断函数执行的次数我感觉肯定有上百亿次。。。估计我再不退出就可能 会发生栈溢出了。。。还是不等这个输出结果了吧。上面的两个问题都是我亲手完成和研究的问题，不过递归和回溯算法的题目不止如此，下面看几个网上看到的几个题目。 括号排列基本介绍 给出n对括号，求括号排列的所有可能性。 思路分析对于回溯法来说，必须齐备的三要素： 1、选择。在这个例子中，解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号； 2、条件。在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于0才能放入左括号。这里if的顺序会影响输出的顺序，但是不影响最终解； 3、结束。这里的结束条件很显然就是，左右括号都放完了。 回溯法中，参数的设计是一大难点，也是很重要的地方。而递归参数的设计要注意的四个点： 1、用了一个空字符串来作为临时变量存储不完整解； 2、用了一个ArrayList results来存放符合要求的解。在后面可以看到，不一定要这样做，也可以直接打印结果； 3、把leftnum和rightnum传入给递归函数，这样可以用于判断结束条件； 代码实现import java.util.ArrayList; public class BackTracking { public static void main(String[] args) { int n = 3; int leftnum = n, rightnum = n;// 左括号和右括号都各有n个 ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();// 用于存放解空间 parentheses(&quot;&quot;, results, leftnum, rightnum); for (String s : results) System.out.println(s); } public static void parentheses(String sublist, ArrayList&lt;String&gt; results, int leftnum, int rightnum){ if (leftnum == 0 &amp;&amp; rightnum == 0)// 结束 results.add(sublist); if (rightnum &gt; leftnum)// 选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist + &quot;)&quot;, results, leftnum, rightnum - 1); if (leftnum &gt; 0) parentheses(sublist + &quot;(&quot;, results, leftnum - 1, rightnum); } } 代码说明： parentheses函数的参数的说明 @param sublist 尚未完成的括号串 @param results 存放已经完成的括号串的字符串 @param leftnum 左括号的数量 @param rightnum 右括号的数量 回溯算法如何实现的？ 其实这个算法我倒是感觉没有什么回溯的味道，就是单纯的递归而已。当剩下的左括号和右括号的数量都为0的时候，就是一条递归终止，然后将结果放入集合中。 当剩下的右括号的数量比较多的时候（放入的左括号的数量大于放入的右括号的数量）此时就放入右括号。（如何剩下的右括号的数量小于等于左括号的数量放入右括号是非法的） 当还有剩下的左括号，就放入左括号。 这或许有点不好理解，下面的两个条件其实是在同步进行的。比如说 比如要放四个括号，遇到了这样的字符串 (()( 经过第二个条件的判断产生的递归的分支是 (()() 经过第三个条件的判断产生的递归的分支是 (()((通过了上面的说明就可以理解，不存在少了哪一种情形。每一次的递归都是一种结果。不过，这个算法里面是真的没有回溯这个部分，只是递归而已。 不过作者偏说这个有回溯的部分。 4、这个例子不明显。但是事实上也符合这个条件。可以仔细观察代码，可以发现由于使用了两个if，所以当一次递归退出后，例如从第一个if退出，第二个递归直接递归的是leftnum-1和rightnum，这其实是已经恢复状态了（如果没有恢复状态，那就是leftnum, rightnum-1）。因此不需要人为让他恢复状态。但是恢复状态这点是很重要的，因为回溯法，顾名思义要回溯，不恢复状态，怎么回溯呢。 if(rightnum&gt;leftnum)//选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist+&quot;)&quot;, results, leftnum, rightnum-1); if(leftnum&gt;0) parentheses(sublist+&quot;(&quot;, results, leftnum-1, rightnum); 把这个称为是回溯，确实是有点儿牵强。每一个递归都是这样使用的不是吗？因为每一层递归不在一个栈空间，在同一个栈空间的数据当然是相同的，自然不用人为恢复状态。 数字之和基本介绍 给出一个不重复大于0数字的数组和一个目标，求数组中数的组合的和得到该目标（数字不同组合顺序当做一个解）。 这个和leetcode上的第一题两数之和是有点儿像的，不过这个题目似乎是没有规定这些数的个数是2，那么难度就不是一倍两倍的往上涨了。两数之和可以使用排序双指针轻松解决，不过这个题目使用排序双指针似乎有点儿困难。 思路分析代码实现 public class BackTracking { public static void main(String[] args){ int[] num=new int[]{2,3,7,6，4,9,1}; int target=9; find(num, target, &quot;&quot;); } public static void find(int[] num, int target, String temp){ if(issolution(temp,target)){ System.out.println(temp); return; } for(int i=0;i&lt;num.length;i++){ if(num[i]!=-1){//如果取过这个数字了，就置为-1 int k=num[i]; num[i]=-1; find(num, target, temp+k); num[i]=k; // 恢复取出的数据的值。 } } } public static boolean issolution(String temp, int target){ boolean result=false; int count=0; for(int i=0;i&lt;temp.length();i++){ count=count+Integer.valueOf(temp.charAt(i)+&quot;&quot;); } if(count==target) result=true; return result; } } 代码说明： for循环里面？ 其实这一整块的代码只有for循环的里面是需要说明的。首先先记录一下放入组合中的那个数据，然后将之置为0.然后再次递归，这样在那个递归的find里面数组的num[i]就为-1了。在后面将i再次恢复到-1从而不影响其他的递归空间。下面的那个issolution函数也非常的容易理解。 代码存在的问题首先这个代码不是我写的，但是我再研究了多道递归的题目的时候还是看出了一个代码其实还是有不少的问题的。 首先我们看一下这个问题的输出如何： 234 27 261 243 216 324 36 342 72 621 63 612 423 432 9 126 162不得不说这个结果的输出就是非常乱的，首先没有任何的分隔符告诉我是那些数的组合，其次，全是重复！！！这个算法其实就是暴力破解法，效率是特别的低的。可以改进的空间非常大！ 首先输出得改善，第二得去重复，第三要考虑到效率问题。针对这三个点，我重写了这个代码。 重写代码public class BackTracking2 { public static void main(String[] args) { int[] num = new int[] { 2, 3, 7, 6, 4, 9, 1}; Arrays.sort(num); int target = 9; // find(num, 0, target, &quot;&quot;); find(num, target); } public static void find(int[] num, int loc, int target, String temp) { int result = issolution(temp, target); if (result == 0) { System.out.println(temp); return; } if (result &gt; 0) { // 和都已经大于target了， 再增加已经没有任何的意义了 return; } for (int i = loc; i &lt; num.length; i++) { if (num[i] &lt;= target) {// 如果取过这个数字了，就置为-1 find(num, i + 1, target, (temp + num[i]) + &quot; &quot;); } else { return; } } } // 可以重载一下，是调用更加简洁 public static void find(int[] num, int target){ find(num, 0, target, &quot;&quot;); } public static int issolution(String temp, int target) { int count = 0; for (int i = 0; i &lt; temp.length() / 2; i++) { count = count + Integer.valueOf(temp.charAt(2 * i) + &quot;&quot;); } if (count &gt; target) return 1; if (count &lt; target) return -1; return 0; } } 输出结果： 1 2 62 3 42 73 69 可见这个输出结果就是很舒服的 代码说明： 关于输出 输出添加了空格主要就是修改了上面的23,31,32这几行，这个修改起来相对简单容易理解。 关于重复 其实重复这个问题也蛮好解决的，只要好马不吃回头草就行了。你想想看比如2，3，7，6假如我挑选的是已经把所有的包含2的都挑选完了，那么在我挑选3的时候，为何还要继续挑选前面的2呢？我们只需要给函数加上一个参数loc，告诉他从什么位置开始挑选就可以完美地解决这个问题了。 关于效率 原先的真的是暴力算法，一点效率都没有。首先是作为自以为完美的将num[i]置为-1，然后再还原的操作，虽然说的确是很秀但是真的没有必要。还有issoluation函数的返回值，完美可以返回大于小于和等于，然后利用大于可以直接结束递归。还有就是将num数组进行排序，虽然说不排序也可以做，但是排序之后的效率将变得高的多，而且还可以在函数中利用num[i] &gt; target就直接结束这个函数（num数组是递增的），可以说是提高了效率。 不过说修改之后的函数就没有问题了，这也是不可能的，我认为还是可以继续改进的，不过做到这一块已经可以说是基本上差不多了。 字符串排列基本介绍 给一个字符串，给出他的所有排列 什么叫字符串的所有的排列呢？就比如说给定的字符串是abc，他的所有的排列就是 abc acb bac bca cab cba总共有 A33 = 3! = 3 × 2 × 1= 6 种 思路分析这个其实也是一种放东西类型的题目，和上面的那一个题目倒是有一点儿类似，不对，应该说是有点儿儿完全一样，就是上面的那一个题目改进前的那个算法。毕竟这玩意是需要重复的嘛。 代码实现public class StringArrange { public static void main(String[] args) { String s = &quot;abc&quot;; Arrange(s, &quot;&quot;); } public static void Arrange(String s, String temp) {// 参数设计地尽量地简洁 if (s.length() == 0) { System.out.println(temp); return; } for (int i = 0; i &lt; s.length(); i++) { String news = s.substring(0, i) + s.substring(i + 1, s.length());// 去掉String中的某个字母 Arrange(news, temp + s.charAt(i)); } } } // 既然你要说参数设计要简洁的话为啥不给这个函数一个重载呢？ public static void Arrange(String s){ Arrange(s, &quot;&quot;); } // 然后直接这样子调用不就完事了 String s = &quot;abc&quot;; Arrange(s); 输出结果： abcacbbacbcacabcba 代码说明： 这个其实没有什么要说明的地方，不过要注意的一点是java当中substring的第二个参数是结束的位置（不包括），C++中的substr()的第二个参数是子串的长度。关于这一点，我也算是佛了！ 还有一个与之比较类似的题目。 新字符串给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 这个题目可以直接用前面的回溯算法，而且真的特别的简单，至于效率，应该不是很快吧。不过真的是特别容易理解。 代码实现public class NewStr { public static void main(String[] args) { String a = &quot;ak47A&quot;; // newStr(a, 0, &quot;&quot;); newStr(a); } public static void newStr(String a, int i, String temp) { if (i == a.length()) { System.out.println(temp); return; } if (Character.isAlphabetic(a.charAt(i))) { String temp2 = new String(temp); temp += a.charAt(i); newStr(a, i+1, temp); if (Character.isLowerCase(a.charAt(i))) { temp2 += Character.toUpperCase(a.charAt(i)); }else { temp2 += Character.toLowerCase(a.charAt(i)); } newStr(a, i+1, temp2); }else { temp += a.charAt(i); newStr(a, i+1, temp); } } public static void newStr(String a){ newStr(a, 0, &quot;&quot;); } } 输出结果： ak47Aak47aaK47AaK47aAk47AAk47aAK47AAK47a 代码说明： 这个代码实在是太容易理解了，不用说什么了。里面用到了几个库函数，看函数的名字大概就可以知道函数的意思了。 我看到博主使用的代码有点沙雕，不过思路是完全一样子的（我可没有看这个函数起名都花里胡哨的代码，dfs。。。to784To？？？我佛了）。这里就直接说我上面的那个算法就完事了，至于博主的算法直接贴出来就完事了。 public void dfs(String pre, String S, List&lt;String&gt; res, int index) { if (index == S.length()) res.add(pre); else { char ch = S.charAt(index); if (!Character.isLetter(ch)) dfs(pre + ch, S, res, index + 1); else { // 小写字符分支 ch = Character.toLowerCase(ch); dfs(pre + ch, S, res, index + 1); // 大写字符分支 ch = Character.toUpperCase(ch); dfs(pre + ch, S, res, index + 1); } } } public List&lt;String&gt; letterCasePermutation(String S) { List&lt;String&gt; res = new LinkedList&lt;&gt;(); dfs(&quot;&quot;, S, res, 0); return res; } // 测试 public static void main(String[] args) { String S = &quot;a1b&quot;; To784To to784To = new To784To(); System.out.println(to784To.letterCasePermutation(S)); } 子集问题 给定一个集合，求他的所有的子集 就不上什么思路分析了，直接代码 代码实现public class Subsets { public static List&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public static List&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] arr) { ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); subsets(arr, curr, 0); // System.out.println(res); return res; } public static void subsets(int[] arr, ArrayList&lt;Integer&gt; curr, int start) { res.add(new ArrayList&lt;Integer&gt;(curr)); // 如果不这样放，最后就都是空 if (start == arr.length) { return; } for (int i = start; i &lt; arr.length; i++) { curr.add(arr[i]); subsets(arr, curr, i + 1); curr.remove(curr.size() - 1); } } public static void main(String[] args) { int[] arr = { 1, 2, 3 }; subsets(arr); } } 要注意一点的是，放入res的时候，如果不new的话，放入的就是引用，（Java万物都是引用）最后就都会变成空的集合。这一点上C++和Java的区别要尤其的注意。这两门语言名义上说是很像，但是这点差的真的是特别的大。我也是佛了。 总结递归与回溯确实有点儿难以掌握，刚才去leetcode上面看了一题，还是有点儿懵，虽然有了思路 ，但是并不能完全的写下去，唉，还是要多加的训练才能基本掌握这门高深的“通用解题方法”啊。 参考了一点的文章: 回溯算法超通俗易懂详尽分析和例题]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的广度优先和深度优先遍历]]></title>
    <url>%2F2019%2F07%2F23%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的广度优先和深度优先遍历其实之前我们已经学过了二叉树的先序遍历，中序遍历和后序遍历，这些遍历的方式都是几行代码利用递归的方式来实现的。其实这些遍历方式是不怎么符合我们的逻辑的（至少是不符合我的逻辑），不过他们确实的使用简单的算法就可以遍历二叉树的好办法。这不是说这些遍历方式不好（二叉排序树还就是需要中序遍历呢），只是我们还可以学习其他的遍历二叉树的方式。比如下面的广度优先遍历和深度优先遍历。 广度优先 广度优先的基本介绍广度优先遍历（ Breadth-First Search）一般缩写为BFS。 其过程检验来说是对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。对于上面的例子来说，广度优先遍历的 结果是：A,B,C,D,E,F,G,H,I(假设每层节点从左到右访问)。 广度优先的算法实现 先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。 广度优先遍历树，需要用到队列（Queue）来存储节点对象,队列的特点就是先进先出。例如，上面这颗树的访问如下： 首先将A节点插入队列中，队列中有元素（A）; 将A节点弹出，同时将A节点的左、右节点依次插入队列，B在队首，C在队尾，（B，C），此时得到A节点； 继续弹出队首元素，即弹出B，并将B的左、右节点插入队列，C在队首，E在队尾（C,D，E），此时得到B节点； 继续弹出，即弹出C，并将C节点的左、中、右节点依次插入队列，（D,E,F,G,H），此时得到C节点； 将D弹出，此时D没有子节点，队列中元素为（E,F,G,H），得到D节点； 首先构战树节点struct TreeNode { int data; TreeNode* left; TreeNode* right; TreeNode(int val):data(val){ this-&gt;left = nullptr; this-&gt;right = nullptr; } }; 这里就不写二叉树这个类了，就写一个树节点就完事了。 删除树void deleteTree(TreeNode* root){ if (root == nullptr){ return; } if (root-&gt;left != nullptr){ deleteTree(root-&gt;left); } if (root-&gt;right != nullptr){ deleteTree(root-&gt;right); } delete root; } 广度遍历算法vector&lt;TreeNode*&gt; BFSsearch(TreeNode* root) { // 首先将A节点插入队列中，队列中有元素（A） // 队列是先进先出的一种数据结构 queue&lt;TreeNode*&gt; node_queue; // 按广度遍历的算法来保存节点顺序 vector&lt;TreeNode*&gt; result; node_queue.push(root); TreeNode* pop_node; while (!node_queue.empty()) { // 将第一个节点取出，将节点的左右节点放入队列 pop_node = node_queue.front(); result.emplace_back(pop_node); node_queue.pop(); if (pop_node-&gt;left != nullptr) { node_queue.push(pop_node-&gt;left); } if (pop_node-&gt;right != nullptr) { node_queue.push(pop_node-&gt;right); } } return result; } 主方法中的测试代码二叉树的结构： 1 2 3 4 5 6 7 8 int main(int argc, char const* argv[]) { TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;right = new TreeNode(3); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;left-&gt;right = new TreeNode(5); root-&gt;right-&gt;left = new TreeNode(6); root-&gt;right-&gt;right = new TreeNode(7); root-&gt;right-&gt;right-&gt;right = new TreeNode(8); vector&lt;TreeNode*&gt; bfs = BFSsearch(root); for (auto node : bfs) { cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; deleteTree(root); system(&quot;pause&quot;); return 0; } 输出的结果： 1 2 3 4 5 6 7 8 深度优先 深度优先基本介绍深度优先是Depth-First Search（DFS）。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。对于上面的例子来说深度优先遍历的结果就是：A,B,D,E,I,C,F,G,H.(假设先走子节点的的左侧)。 深度优先的算法思路深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。 先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 首先将A节点压入栈中，stack（A）; 将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)； 将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）； 将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）； 将E节点弹出，同时将E的子节点I压入，stack（I,C）； …依次往下，最终遍历完成。 可以看到这个深度优先的算法和广度优先的算法是十分的类似的，一个使用的是队列，一个使用的栈。队列的特点是先进先出，队列的特点是先进后出。 深度优先算法代码实现vector&lt;TreeNode*&gt; DFSsearch(TreeNode* root) { vector&lt;TreeNode*&gt; result; stack&lt;TreeNode*&gt; node_stack; TreeNode* pop_node; node_stack.push(root); while (!node_stack.empty()) { pop_node = node_stack.top(); node_stack.pop(); result.push_back(pop_node); if (pop_node-&gt;right) { node_stack.push(pop_node-&gt;right); } if (pop_node-&gt;left) { node_stack.push(pop_node-&gt;left); } } return result; } 测试代码和上面的基本都是一样的： 二叉树的结构： 1 2 3 4 5 6 7 8 *输出结果: * 1 2 4 5 3 6 7 8 总结二叉树的深度优先及广度优先遍历算法算是二叉树中比较重要的两个算法了。但是深度优先和广度优先这个并不是二叉树中的概念，其实还有其他很多的数据结构及算法都有深度优先和广度优先算法。比如说图的遍历，也有广度优先和深度优先。总之，一点一点去学吧，么得多大的问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法简介]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[贪心算法简介 ​ 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法的基本介绍贪心算法的一般流程Greedy(C) //C是问题的输入集合即候选集合 { S={ }; //初始解集合为空集 while (not solution(S)) //集合S没有构成问题的一个解 { x=select(C); //在候选集合C中做贪心选择 if feasible(S, x) //判断集合S中加入x后的解是否可行 S=S+{x}; C=C-{x}; } return S;贪心算法其实没有一个固定的流程，这点和KMP算法不一样，KMP算法是解决那种特定的问题，但是这个贪心算法是解决那一种问题，适合做出贪心选择的问题： 贪心选择的性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 对于那些不满足贪心选择的问题，我们不可以使用贪心算法来解决。 贪心算法存在的问题 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心算法的例题找零钱问题假如老板要找给我99分钱，他有上面的面值分别为25，10，5，1的硬币数，为了找给我最少的硬币数，那么他是不是该这样找呢，先看看该找多少个25分的，诶99／25＝3，好像是3个，要是4个的话，我们还得再给老板一个1分的，我不干，那么老板只能给我3个25分的拉，由于还少给我24，所以还得给我2个10分的和4个1分。 思路分析这个题目其实非常的简单，估计不学这个贪心算法都是非常容易搞定的，我们想要最少的硬币数，这里存不存在贪心选择呢？其实是很容易看出来的，我们的贪心选择就是尽量找大面额的硬币，能有多少找多少，毕竟有1元的硬币无需担心有早不开这种情况。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; giveMoney(vector&lt;int&gt; m, int target) { int size = m.size(); vector&lt;int&gt; num(size, 0); for (size_t i = 0; i &lt; size; i++) { num[i] = target / m[i]; target = target % m[i]; } return num; } int main(int argc, char const *argv[]) { vector&lt;int&gt; num = {25, 10, 5, 1}; int target = 99; vector&lt;int&gt; result = giveMoney(num, target); std::cout &lt;&lt; target &lt;&lt; &quot;的找钱方案为：&quot; &lt;&lt; std::endl; for (size_t i = 0; i &lt; result.size(); i++) { std::cout &lt;&lt; result[i] &lt;&lt; &quot;枚面值为&quot; &lt;&lt; num[i] &lt;&lt; &quot;的硬币&quot; &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 运行结果99的找钱方案为： 3枚面值为25的硬币 2枚面值为10的硬币 0枚面值为 5的硬币 4枚面值为 1的硬币这个是贪心算法的一个简单的例子，也无需做什么代码说明啦。 活动安排问题设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si&lt; fi。如果选择了活动i，则它在半开时间区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当si≥fi或sj≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。 思路分析其实我有点儿不想认为这个是贪心算法，但是你非要说这个是，我也没办法啦~ 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; arrangeActivity(vector&lt;int&gt; start, vector&lt;int&gt; end) { int total = start.size(); int endFlag = end[0]; vector&lt;int&gt; result; result.push_back(0); for (size_t i = 0; i &lt; total; i++) { if (start[i] &gt; endFlag) { result.push_back(i); endFlag = end[i]; } } return result; } int main(int argc, char const *argv[]) { vector&lt;int&gt; start = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12}; // end数组是有序的 vector&lt;int&gt; end = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; vector&lt;int&gt; result = arrangeActivity(start, end); for (size_t i = 0; i &lt; result.size(); i++) { int index = result[i]; std::cout &lt;&lt; &quot;开始时间：&quot; &lt;&lt; start[index] &lt;&lt; &quot; 结束时间：&quot; &lt;&lt; end[index] &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 我简直不忍心说这个是。。。贪心算法啦~ 背包问题这个问题之前在动态规划的时候说过好像，不过那篇文章中好像没有谈及这个问题，不过我已经写完了好几道背包问题的例题了，下次可以再次写一个动态规划的文章。这里就使用动态规划里面的那个背包问题的题目吧。 0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。 那么问题来了，这个题目可以使用贪心算法来做吗？也就是说这个题目存在贪心选择吗？ 贪心选择1 ： 和找零钱一样，选择最贵的往里面放。 但是这个得到的是最优解吗？很容易得到反例，放入了贵的东西之后，剩余的空间可以会得不到利用。 贪心选择2： 选择轻的往背包里面放。 和上面的选择一样，这个也不能确保是最优解。 由此可见，使用贪心算法无法解决这个问题，还是安心的去选择动态规划吧。。。蛤蛤蛤 均分纸牌有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。 思路分析设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动： 若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆； 若a[i]&lt; v，则将v-a[i]张从第I+1堆移动到第I堆。为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v. 在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？ 我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不变，因此此题使用贪心法可行的。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::cout; using std::endl; using std::vector; int moveCards(vector&lt;int&gt;&amp; cards) { int sum = 0; int count = 0; for (size_t i = 0; i &lt; cards.size(); i++) { sum += cards[i]; } int average = sum / cards.size(); for (size_t i = 0; i &lt; cards.size(); i++) { if (cards[i] != average) { cards[i] += average - cards[i]; cards[i + 1] -= average - cards[i]; count++; } } return count; } int main(int argc, char const* argv[]) { vector&lt;int&gt; cards = {2, 10, 18}; int count = moveCards(cards); cout &lt;&lt; &quot;移动次数：&quot; &lt;&lt; count &lt;&lt; endl; for (size_t i = 0; i &lt; cards.size(); i++) { cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;堆牌：&quot; &lt;&lt; cards[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 代码说明： 乍一看以为这个题目是很难的题目，但是定睛一看，这不是一个沙雕题目吗？特别是有个这个贪心算法的思路之后，这个题目就变得尤为的弱智。 不过，关于这个题目，以及贪心算法还有特别多要注意的地方 一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。 二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。 这个题目找到了合理的贪心选择：如果不等于平均值的话就利用右面的牌堆变成平均值，即使出现了负数问题也不是很大。这个选择很好像，不过要说明这个就可以得到最优解，还是有一点难度的。 加入说这个移动不是限制在相邻的牌堆之间了，这个选择就肯定是一个错误的选择了。所以说贪心算法难，但是代码不是特别的难写，主要就贪心选择有没有选择正确。 最大整数设有n个正整数，将它们连接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 思路分析这个题目我们想要使用贪心算法来做，那么我们就要选择一个正确的贪心选择，那么关于这个题目怎么做贪心选择呢？把大的数放在前面？ 78 123 -&gt; 12378明显不对，把小的数放在前面？这同样都是不对的。对于两个整数 a和b我们要是ab &gt; ba(这里不是乘法)，这样做其实有一个很简单的实现方式，就是利用字符串。和求整数的最大的位数相似(将整数转为字符串然后求得字符串的长度就是整数的长度)我们可以将整数a和b转为字符串然后比较a+b和b+a的大小。 代码实现/** * 设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 * 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。 * 又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 */ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using std::string; using std::to_string; using std::vector; #include &lt;sstream&gt; using std::stringstream; // 也可以使用stringstream来将nums转为string // 将int转为string可以使用stoi， long转为string可以使用stol 转为char* // 就以atoi和atol吧 string maxNum(vector&lt;int&gt;&amp; nums) { // string result = to_string(nums[0]); string result = &quot;&quot;; stringstream ss; ss &lt;&lt; nums[0]; ss &gt;&gt; result; for (size_t i = 1; i &lt; nums.size(); i++) { string plusNum = to_string(nums[i]); if (result + plusNum &gt; plusNum + result) { result += plusNum; } else { result = plusNum + result; } } return result; } int main(int argc, char const* argv[]) { vector&lt;int&gt; nums = {78, 123, 93}; for (auto val : nums) { std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &quot;可以组成的最大的整数为：&quot;; std::cout &lt;&lt; maxNum(nums) &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 也是非常简单的代码不用做什么说明了。 总结贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，(动态规划依赖于子问题的解) 因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。但是不是所有的问题都可以使用贪心算法来解决的，要注意贪心选择是否是正确的，不然太贪心了之后搞得自己人莫得了。贪心算法学了感觉还是有点儿懵，这个算法拓展性真的是太强了，完全就只是一个思路，怎么搞都依赖于你自己的想法。嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-1>0x7fffffff???(黑人问号脸)]]></title>
    <url>%2F2019%2F07%2F22%2F-1%E5%A4%A7%E4%BA%8E0x7fffffff%2F</url>
    <content type="text"><![CDATA[-1 &gt; 0x7fffffff ??? 今天在研究KMP算法的时候，KMP算法研究的一窍不通，完全看不懂这个神仙算法的思路。那想着先照葫芦画瓢，先不管三七二十一，知道KMP要干啥，至于为啥要那样做咋先不管，咋先把这个算法写一遍，然后再去理解，但是这个就出问题了，出了一个莫名其妙的bug，这是怎么找都找不到啊，找的我头大啊！！！ 我先确定了出问题的函数，这个很简单。 然后我又确定了出问题的部分是什么，这不确定不得了，发现是while循环出错了，while循环只是循环了一次就退出了。。。 代码如下： int KMPsearch(string str, string sub, int* next) { int i = 0, j = 0; while (i &lt; str.length() &amp;&amp; j &lt; sub.length()) { if (j == -1 || str[i] == sub[j]) { i++; j++; } else { j = next[j]; } } if (j == subLen) { return i - j; } else { return -1; } } 这个代码看着是十分的没有问题，但是我就是定位到这个函数有问题了而且是while循环一次就退出while循环一次之后i是1，j是-1，str.length()和sub.length()肯定是一直都不会变的啊？那么究竟是1&gt;=26还是-1&gt;=6? 这搞得我非常的懵逼。。。我的编译器出问题了，开始跟我瞎搞了？ // 原因是这样子的 str.length()返回类型是size_t是无符号类型的 // j 是int是有符号类型的，一般情况下还真的没问题，但是问题就在与这里的j可以为-1 // 有符号值与无符号的值进行比较的时候，有符号值会转换成无符号的值 // -1 是 0xffffffff 变成有符号的数还是 0xffffffff 可怕。。。这个比0x7fffffff(MAX_INT)还大！！数据在电脑中的存储和计算都是以补码的形式. -1的原码是 1000 0000 0000 0000 0000 0000 0000 0001 -1的反码是 1111 1111 1111 1111 1111 1111 1111 1110 -1的补码是 1111 1111 1111 1111 1111 1111 1111 1111反码是除了符号位其余的位取反 正整数的补码是就是原码 负整数的补码是反码加1 size_t i = 0x7fffffff; int j = -1; if (j &gt; i){ cout &lt;&lt; &quot;-1 &gt; 0x7fffffff&quot;&lt;&lt;endl; } 当一个有符号数和无符号数进行比较的时候，就不会把-1这个符号位1当成符号位. 也就是说-1 == (unsigned int)0xffffffff &gt; (unsigned int)0x7fffffff 0x7fffffff是啥玩意？是MAX_INT（定义在limits.h中) 0x80000000是MIN_INT，咦这个不是-0的原码嘛？ 0x80000000 -1 = 0x7fffffff 取反就是 0x00000000，这不是0嘛？蛤蛤蛤这也就是为嘛最大的负数的绝对值要比最大的正数大上1. -0的原码是0x80000000 反码是0xfffffff 补码是0x00000000，咦为啥呢？ 因为溢出了1 0000 0000，这个只是取后八位，所以说-0和0的补码都是0。 #include &lt;stdio.h&gt; #include &lt;limits.h&gt; int main(){ if (INT_MIN == 0x80000000 &amp;&amp; INT_MAX == 0x7fffffff){ printf(&quot;INT_MIN: 0x80000000\nINT_MAX: 0x7fffffff\n&quot;); }else{ printf(&quot;No&quot;); } return 0; } 有符号的数和无符号的数时要注意：有符号的数会变成无符号的数。 这不禁又让我想起来我之前遇到的一个大体相同bug for (size_t i = 10; i&gt;=value; i--){ // ... } 这个value是-1，导致这个循环死的了，当时找bug找的我也是头发昏，找到了的原因也是如此 无符号与有符号的数进行比较！！！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 我被坑的已经不止这一次了，嘤嘤嘤~，继续看KMP算法去了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法简介]]></title>
    <url>%2F2019%2F07%2F22%2FKMP%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[KMP 算法 KMP算法是关于字符串匹配的一个算法。 比如说有一个字符串是 “acbabcdabdbacdd” 我们要在这个字符串中寻找是否有子串 “acbdacd”，有就返回下标，没有就返回-1 暴力匹配暴力匹配的思路这个题目我们的思路其实是非常明确的。那就是暴力匹配呗。 如果匹配了我们就返回，如果不匹配我们就重新开始匹配下一个字符。 上面的那个题目，匹配到第四个个字符不匹配了，那么我们把子串往后移后一位，用a和c再比较。。。 这个暴力匹配就是一旦遇到了不匹配的字符，就把子串移后一位，如果都到了主串的末尾了还没有匹配成功，那么就说明这个主串中没有子串，返回-1即可。 代码实现的其实也蛮简单的。 暴力匹配代码实现#include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; /** * 使用暴力算法，就是这么的暴力！！ */ int KMP(string str, string sub) { // 使用i来指向主串，使用j来指向子串 int i = 0, j = 0; // 主串还没有被比较结束 while (i &lt; str.length()) { // 匹配了 继续比较下一位 while (str[i] == sub[j]) { i++; j++; // 匹配成功，在主串中发现了子串 if (j == sub.length()) { return i - j; } } // 匹配失败，将i移动到本次匹配的后一位 i = i - j + 1; // 重置子串， j重新指向子串的开头 j = 0; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABCDE&quot;; int index = KMP(str, sub); if (index == -1) { cout &lt;&lt; &quot;Not Found!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Found!\nT/F: &quot; &lt;&lt; (str.substr(index, sub.length()) == sub ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 这个暴力匹配的算法，就算是个小学生也能一眼看懂吧，不需要做什么代码说明了，重点戏是后面的KMP算法。 暴力匹配：时间复杂度是O(mn) 其中m是子串的长度，n是主串的长度. KMP 算法关于暴力匹配的思考及KMP的思路暴力匹配的算法每次都是后移一位。比如下面 主串: abcdxxxx 子串: abcde我们发现第五位不匹配，暴力匹配的思路是这样子的，移动到下一位 主串：abcdxxxx 子串： abcde但是这个不是很脑残的行为吗？既然第五位是不匹配的，那么主串和子串的前四位不就都是相等的吗？我们再次观察这个子串的前面的四位都是不相同的字符，那么我们完全没有必要让子串a再次和后面bcd比了。我们完全可以直接跳到这一步 主串: abcdxxxx 子串: abcdei直接往前跳了四步，极大的节省了时间。 但是问题就在，你是怎么知道前面的四位都是不相等的? 主串: ababxxxx 子串: ababe这次也是第五位不匹配的，这次我们还是跳四位？？？ 这时有人要抢答了：同学，这里有两个相同的字符，这傻子都可以看出来是跳两位啊！！ 那么这个也是跳两位？ 主串: abbaxxxx 子串: abbae很明显这个是跳三位。我们看起来非常的容易，一看就知道跳几位，但是如何用逻辑描述这个到底应该跳几位了？ 我们到第5位不匹配要跳几位，其实和第五位没有关系，这完全取决与前面的四位。我们来观察一下： abcd -&gt; 4 = 4-0 abab -&gt; 2 = 4-2 abba -&gt; 3 = 4-1或许也许可能观察不出来什么，不过观察一下他们的前缀和后缀。 比如 impossible 前缀就有im 后缀就有ible 但是他们的前缀和后缀不能是他们的本身 字符串 前缀 后缀 前缀后缀共有字符串的最大长度 abcd a, ab, abc d, cd, bcd 0 abab a, ab, aba b, ab, bab 2 abba a, ab, abb a, ba, bba 1 这样就明白了吧，我们往后移动的多少取决于前缀后缀共有字符串的最大的长度。 我们可以来验证一下 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第一步：（找到第一个匹配的位置） 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第二步：(C和空格不匹配) ABCDAB的前缀后缀的共有字符串是2，那么应该向后移动6-2=4位 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD发现找到了 我们可以发现KMP的思路其实还是蛮清晰的。就是这个简答，利用匹配失败已经前面匹配成功的字符的前缀后缀共有字符串的最大的长度来尽可能多的往后移动位置，反观暴力破解，每次就只是往后面移动一位d，效率低下。 KMP寻找的时候的时间复杂度是O(n) 构造部分匹配表上面的那个由前几位前缀后缀共有字符串的最大长度构成的表被称为部分匹配表。那么如果用代码去构造这个部分匹配表呢？ 比如如下的字符串，部分匹配表如下(第三行)，但是如何去构造呢 0 1 2 3 4 5 6 ---(序号) a b c d a b d ---(字符串) 0 0 0 0 1 2 0 ---(部分匹配表) 1 1 2 3 4 4 4 ---(到这一位不匹配的时候向后移动的位数)思路 a b c d a b d 1 j i -&gt;0 2 j i -&gt;0 3 j i -&gt;0 4 j i -&gt;1 5 j i -&gt;2 6 j i 这个第六步发现i位和j位不相等，那么i是肯定不能动的，动的肯定是j那么j怎么变？j变成0？？？ 此时j-1的字符肯定是等于i-1处的字符的。此时我们想要知道是否j还有别的值的前一位是等于i-1的然后跳到这个j 这个例子中没有下面再举一个例子 a b c d a b d a b c d a b d ... a b c d a d b a b c d a b d 0 0 0 0 1 2 此时我们发现d和c不匹配，我们想从a b中找到可能和b相等的值 d处的最大前缀后缀共有的最大长度有可能超过2吗？不可能 假如如下的字符串 x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] 此时又回到了j前面的值和i前面的值再次都相等的情况，再次比较,如果不相等回到 x y d x y c z z z z x y d x y d j i -&gt; x y这个串的前后缀最大已经是0了上面或许讲的有点乱，因为当时我也是有点乱，但是现在我明白了 我们发现当部分匹配表没有1这个值，没有前缀也没有后缀，就给它一个0吧 int* calNext(string sub){ int length = sub.length(); int* next = new int[length]; next[0] = 0; int i=1, j=0; while(i &lt; sub.length){ if (j &gt; 0 &amp;&amp; sub[i] != sub[j]){ j = next[j-1]; } if (sub[i] == sub[j]){ j++; } next[i++] = j; } } 代码说明： 这里面最难以理解的估计就是那一句话，就是j = next[j-1]到底是什么含义 比如 0 1 2 3 4 a b a b c j i 0 0 1 2 0j = next[j-1]之后就是 j =0; j = next[j-1]的含义就是回到上一个时刻 sub[j-1] == sub[i-1]不仅如此，他们前面的值都是相等的！ 这个例子中这样的数不存在 x d x y x d x d j i 这时 j = next[j-1] x d x y x d x d j i 此时j前面的数和d前面的数又都是相等的了，再次进行比较！如果还是不相等 j = next[j-1]这样应该很好理解了吧。 这样我们的next数组也就构造好了，KMP算法也就好实现了 KMP 代码int KMPsearch(string str, string sub, int* next){ int strLength = str.length(); int subLength = sub.length(); int i=0, j=0; while (i &lt; strLength &amp;&amp; j &lt; subLength){ // KMP核心，不匹配向后移动 if (j &gt; 0 &amp;&amp; str[i] != str[j]){ j = next[j-1]; } if (str[i] == sub[j]){ i++; j++; } if (j == 0 &amp;&amp; str[i] != str[j]){ i++; } } // 找到了子串 if (j == subLength){ return i-j; }else { return -1; } } 代码说明： 其实需要说明的就只是KMP的核心那一块代码。我们一直说什么往后移动，其实这也不是往后移动啊？ 其实这只是我们想象中的往后移动，实际上是这样子的 abcdabcde abcde -&gt; 上面的a匹配失败 -&gt; abcdabcde abcde -&gt; 让下面a和上面a进行比较当匹配到第五位的时候，i其实没有变，变的只是j而已我们直接让sub[next[j-1]]和str[i]进行比较 上面那个next[j-1]就是a abacabab abab -&gt; 上面的c匹配失败 -&gt; abacabab abab -&gt; 让下面b和上面c进行比较再次重申一下，i没有变，变的只是j而已。 总结写到了这儿KMP算法基本上就写完了，写完了之后我对KMP算法的理解算是有涨了一个层次，至少能基本理解这个算法该如何用了而不是单纯的被代码。其实网上关于KMP算法的博客特别多，每个人使用的方法都是不一样的，我看了很多人的next[0] = -1，还有构造了其他各种各样的数组，我基本上都没怎么看，我看的不是代码是怎么写的，主要是KMP的思路是如何的，理解了这个思路之后，什么样的实现KMP算法的代码基本上都能看懂了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法简介]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[动态规划算法简介动态规划基本介绍动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 适用情况 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如下图所示： 初始状态→│决策1│→│决策2│→…→│决策n│→结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征。 递归的定义最优解。 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 根据计算最优值时得到的信息，构造问题的最优解 算法实现动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 上面的这些内容都是从百度百科中抄来的，虽然是百度百科讲的也不是很烂，我感觉除了不是很形象，其他讲的还是不错的。现在还是直接从leetcode动态规划算法的题目开始吧！ leetcode 动态规划爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶这个题目我之前就已经是做过了的，不过似乎是没有使用到动态规划的算法。 class Solution { public: map&lt;int, int&gt; result; int climbStairs(int n) { if (n == 1 || n == 2) return n; if (result.find(n) != result.end()) return result[n]; int res = climbStairs(n-1)+climbStairs(n-2); result[n] = res; return res; } }; 执行结果：通过 显示详情 执行用时 : 0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 : 8.7 MB, 在所有 C++ 提交中击败了10.62%的用户 由此可见，程序运行的速度是飞快的，但是因为使用了map进行记忆，程序消耗了太大的内存，所以说算法值得优化。这是一个典型的动态规划型的题目，和斐波那契数列有点儿相似，那么如何使用动态规划算法呢？ 其实我上面用的map已经是一种动态规划算法了，就是记住原来算过的结果，极大的提高了效率，不过int， int类型的map如果是使用数组的话，还是更好一些。 class Solution { public static int memo[]; public int climbStairs(int n) { memo = new int[n+1]; return climbStairs(n, memo); } public static int climbStairs(int n, int memo[]){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗 :33 MB, 在所有 Java 提交中击败了73.01%的用户 内存消耗反而变大了，，这个是语言的原因，你懂得~ 改成C++代码 int climbStairs(int n){ int* memo = new int[n+1]{0}; return climbStairs(n, memo); } int climbStairs(int n, int* memo){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.6 MB, 在所有 C++ 提交中击败了19.38%的用户 内存的消耗还是特别多，这。。。只能求助于题解了。可以不使用递归的方式，不过说实话，时间复杂度都是一样的，空间复杂度感觉也没多少改善啊。。。 int climbStairs(int n){ if (n &lt;= 2) return n; int* memo = new int[n+1]{0}; memo[1] = 1; memo[2] = 2; for (int i=3; i&lt;=n; ++i){ memo[i] = memo[i-1] + memo[i-2]; } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.4 MB, 在所有 C++ 提交中击败了43.73%的用户 算了，不纠结这题了，这只是一个简单题罢了，请看下一题。 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int sum = 0; int max_sum = nums[0]; for (auto i : nums){ if (sum &gt; 0){ sum += i; }else { sum = i; } max_sum = max(sum, max_sum); } return max_sum; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了92.04%的用户 内存消耗 :9.2 MB, 在所有 C++ 提交中击败了80.50%的用户 代码说明： ​ 别看着这个代码好像很简单似的，但是其中动态规划的算法还是不好理解的。 sum max_sum的含义是什么？ sum表示的当前选定的序列的和，max_sum值的是遇到的最大的序列的和。 sum &gt;0 -&gt; sum += i ? 这其实很好理解，前面的sum是正的，而且最大值已经被记录过了，加上前面正的序列对i有促进的作用，所以说新的序列就是前面的正的那一块加上当前的i. else sum = i? 前面的序列是负的，加上i无论i正负也好都不会有前面的序列大，所以直接从i开始一条新的序列就好了。 那万一i前面的那个值是正的，为什么不从i前面的那个正数开始呢？ 不可能的，i前面的那个值既然被加入了序列中就说明，i前面的前面的序列的和是正数，而i前面的序列和是一个负数，这就可以肯定i前面的数是一个负数。所以从i开始新的序列的最对的。 max_sum = max(sum, max_sum); 每次我们生成新的序列的，和都要和之前获取到的最大的数列的和进行比较以确保我们保存的的确是最大的子序列的和。 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。我一开始是这样子写的(纯暴力破解法，时间用的差不多是一千多ms吧，能AC我也是佛了) int maxProfit(vector&lt;int&gt;&amp; prices) { int profit = 0; int size = prices.size(); for (int i=0; i&lt;size-1; ++i){ for (int j=i+1; j&lt;size; ++j){ if (prices.at(j) - prices.at(i) &gt; profit) profit = prices.at(j) - prices.at(i); } } return profit; } 其实这个题目一眼看过去就知道是动态规划的算法，和前面的那个题目是类似的 int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size &lt;= 1) return 0; if (size == 2) return max(prices.at(1) - prices.at(0), 0); vector&lt;int&gt; buy(size, 0); vector&lt;int&gt; sell(size, 0); buy.at(0) = -prices.at(0); for (int i=1; i&lt;size; ++i){ buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); } return *max_element(sell.begin(), sell.end()); } 执行结果：通过 显示详情 执行用时 :20 ms, 在所有 C++ 提交中击败了25.61%的用户 内存消耗 :9.8 MB, 在所有 C++ 提交中击败了5.10%的用户 这个问题的解决方案是动态规划当中比较经典的填表的方法。之前的那个百度百科中也都已经介绍了这个公式。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 与之比较类似的还有背包问题，待会可以一并解决。 代码说明： 上面的代码主要就是两行比较重要： buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); 第一个就是我在第i天买，比不比我在昨天买上算，如果今天比昨天还要贵那么我今天肯定是不买的。 第二个就是我在第i天卖有没有我在第i-1天卖上算，如果昨天卖比较好那还不如昨天卖。 但是光凭以上两点能解决什么问题呢？ 仔细看的话，你会发现，其实你每一天买的都是相对来说最优的。而每天卖的也是最好的。 我们可以这样想，如何只有三天的话，我们是不是就可以获得在第三天卖的最高的价格？ 假如是 1 2 5 只有buy[1] = 1 sell[1] = 2 第三天的价格是5，那buy[2] = 1，肯定还是延续在只有两天时的买法 sell[2] = max(sell[1], -1 + 5) ，这个卖就是sell[1]肯定是只有i两天的时候最优的利润，buy[1]也是最优的买法，现在加入就在第三天的时候，我们在第三天卖一下，我们看一看这个利润有没有之前的高。然后存入数组。 加上第四天的话还是这样子考虑。就这样其实sell数组里面放的就是有第n天的最大利润，sell数组后面值肯定也都是一样的。 于是取得最大值就行了。 return *max_element(sell.begin(), sell.end()); 注意：max_element返回的是迭代器，所以要加上*取值。 leetcode给出的官方题解是这样子的 public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minprice) minprice = prices[i]; else if (prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; } return maxprofit; } 使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。 这两个算法的思路其实都是一样的，不过官方的题解更加的清晰明了。不过我上面的那个更像是一个动态规划算法，把一个问题拆分成他的子问题。要取得第七天的最大的利润，我们需要利用第六天的数据，这就是一步一步往后推的过程。 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。额~这个好像有点儿复杂，不过如果想到转换的话，一步头就完事了。 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size == 1 || size == 0){ return 0; } int profit = 0; for (int i= 1; i&lt;size; ++i){ if (prices[i] &gt; prices[i-1]){ profit += prices[i] - prices[i-1]; } } return profit; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了89.37%的用户 内存消耗 :9.5 MB, 在所有 C++ 提交中击败了48.29%的用户 感觉这个和动态规划已经扯不上边了，算了叭说了，反正我也不会。。。。 转载两篇文章，这个动态规划有点儿难，我特喵现在也有点儿懵逼了，算了不研究了，下次研究透彻了再说吧。 文章阅读教你彻底学会动态规划——入门篇 算法-动态规划 Dynamic Programming–从菜鸟到老鸟]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本的增删改查操作]]></title>
    <url>%2F2019%2F07%2F19%2FMySQL%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MySQL基本的增删改查 JDBC MySQL的连接 使用工具：Eclipse and Visual Studio 2019 这里其实无论是使用Java还是C++，使用的都是jdBC的操作。当然这里的Java相对来说更加的正宗一点，C++中的jdBC库我用了关于string那一块还有bug，兼容性还不行。所以这里就使用eclipse Java来举例吧。至于如何连接MySQL，这个倒是简单的很，也是不必再说了。 Driver的初始化try { //Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。 // 首先加载驱动包 com.mysql.cj.jdbc.Driver Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } mysql::MySQL_Driver* driver; driver = sql::mysql::get_mysql_driver_instance(); Connection连接数据库, 初始化 Statement// 连接的地址 localhost就是127.0.0.1就是本机的地址 world 代表的是要使用的数据库的名字 String url = &quot;jdbc:mysql://localhost:3306/sher?useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&amp;serverTimezone=UTC&quot;; // 建立和数据库的连接 url account password try { con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); stmt = con.createStatement(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } 其实上面的变量的声明都在类中的静态变量中，为了方便以后数据库的关闭 static ResultSet rs = null; static Statement stmt = null; static Connection con = null; static PreparedStatement pstmt = null; Connection* con; Statement* state; ResultSet* result; const char* accout = &quot;root&quot;; const char* passwd = &quot;root&quot;; con = driver-&gt;connect(&quot;tcp://127.0.0.1:3306&quot;, accout, passwd); state = con-&gt;createStatement(); 这里C++代码中要注意一个问题，account和passwd不能直接写driver-&gt;connect中，而且也不可以使用string类，不然会出现莫名其妙的bug，我也是求助了好长时间才知道这个地方出了问题，我也是醉了。 数据库的关闭private static void close() { try { if (rs!=null) { rs.close(); } if (stmt!=null) { stmt.close(); } if (con!=null) { con.close(); } if (pstmt!=null) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } } C++代码当中没有使用异常处理的机制，而且C++代码中异常处理也不是很好，反正使用体验极差。不过C++11中对于异常机制的改良，我也没学过不知道怎么样。 数据库的增删改查数据库增加数据private static void addData(int id, String username, String passwd) throws SQLException { String sql = String.format(&quot;insert into shertable(id, username, passwd) values(&#39;%d&#39;, &#39;%s&#39;, &#39;%s&#39;)&quot;, id, username,passwd); stmt.execute(sql); } 上面定义的时候我们使用了两种Statement。Statement和 PreparedStatement，这两种之间有什么区别呢？其实是建议使用PreparedStatement的，Statement容易被SQL注入，是不怎么安全的，不过为了介绍这里就都使用了。 stmt.execute(sql) 一般这种insert语句还有用的就是executeUpdate()。还有一个是executeQuery().这三者是有区别的 ResultSet executeQuery(String sql); 执行SQL查询，并返回ResultSet 对象。 int executeUpdate(String sql); 可执行增，删，改，返回执行受到影响的行数。 boolean execute(String sql); 可执行任何SQL语句，返回一个布尔值，表示是否返回ResultSet 。 不过这个execute也不是万能的。 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 至于这个？占位符是PreparedStatement中使用的，等到下面再说。 数据库查询数据private static void queryData(String sql) throws SQLException { rs = stmt.executeQuery(sql); while (rs.next()){ System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot; Username: &quot;+rs.getString(&quot;username&quot;)+&quot; Password: &quot;+rs.getString(&quot;passwd&quot;)); } System.out.println(); } state-&gt;execute(&quot;use world&quot;); // 查询 result = state-&gt;executeQuery(&quot;select * from city order by id desc limit 10&quot;); // 输出查询 cout &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot;; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; &quot;Id&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Name&quot; &lt;&lt; setw(15) &lt;&lt; &quot;CounryCode&quot; &lt;&lt; setw(15) &lt;&lt; &quot;District&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Population&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; while (result-&gt;next()) { int id = result-&gt;getInt(&quot;id&quot;); // 关于getString()这一块这个写的真的是全都是bug， 不过现在好像已经可以运行了。 string name = result-&gt;getString(&quot;name&quot;).c_str(); string countrycode = result-&gt;getString(&quot;countrycode&quot;).c_str(); string district = result-&gt;getString(&quot;district&quot;).c_str(); int population = result-&gt;getInt(&quot;population&quot;); cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; setw(15) &lt;&lt; id &lt;&lt; setw(15) &lt;&lt; name &lt;&lt; setw(15) &lt;&lt; countrycode &lt;&lt; setw(15) &lt;&lt; district &lt;&lt; setw(15) &lt;&lt; population &lt;&lt; endl; } cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; delete state; delete con; 看这个Java和C++中jdBC的操作基本上都是一样的。不过这里C++代码需要注意一下，我又被坑惨了。在使用result-&gt;getString()之后要加上.c_str()使其变成C风格的字符串。都说了string类在jdBC for C++中真的全是bug。C++其实也有C风格的MySQL数据库连接的库，不过那个已经不在这次介绍的范围之内了。 PreparedStatement 添加数据private static void setPstmtSql(int id, String username, String passwd) throws SQLException { pstmt = con.prepareStatement(&quot;insert into shertable(id, username, passwd) values(?,?,?)&quot;); pstmt.setInt(1, id); pstmt.setString(2, username); pstmt.setString(3, passwd); pstmt.executeUpdate(); } 这里就是pstmt的代码的使用。我们先使用占位符来创建一个SQL语句，然后使用setInt()，setString()的方法，来填入占位符中的内容，这是既简便了stmt字符串连接的操作，也可以防止SQL注入，很安全~ 注意上面说的： 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 数据库删除数据private static void delData(int id) throws SQLException{ pstmt = con.prepareStatement(&quot;delete from shertable where id=?&quot;); pstmt.setInt(1, id); pstmt.executeUpdate(); } 数据库修改数据private static void modifyPasswd(String username, String old_passwd, String new_passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;update shertable set passwd = ? where username = ? and passwd = ?&quot;); pstmt.setString(1, new_passwd); pstmt.setString(2, username); pstmt.setString(3, old_passwd); int flag = pstmt.executeUpdate(); if (flag!=0) { System.out.println(&quot;Successfully!&quot;); }else { System.out.println(&quot;Unsuccessfully, please try again!&quot;); } } 本列中其他的操作根据名字查询 private static void queryByName(String name) throws SQLException { pstmt = con.prepareStatement(&quot;select * from shertable where username = ?&quot;); pstmt.setString(1, name); rs = pstmt.executeQuery(); if (rs.next()) System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot;\nUsername: &quot;+rs.getString(&quot;username&quot;)+&quot;\nPassword: &quot;+rs.getString(&quot;passwd&quot;)); else System.out.println(&quot;Not Found!&quot;); } 登陆系统 private static void sign(String name, String passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;select * from shertable where username = ? and passwd = ?&quot;); pstmt.setString(1, name); pstmt.setString(2, passwd); rs = pstmt.executeQuery(); if (rs.next()) { System.out.println(&quot;Sign Up Successfully!&quot;); }else { System.out.println(&quot;Worng UserName or Password!&quot;); } } 总结上面都只是MySQL中的基础中的基础中的基础的操作，作为从来没有学过MySQL的看看基本就行了。对于MySQL中进阶一点的操作，SQL命令的更加高阶的使用可以下次写写看，现在暂时MySQL用得还是比较少滴，不急着学。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数]]></title>
    <url>%2F2019%2F07%2F19%2F0.1%2B0.2%20%3D%3D%200.3%20%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数0.1 + 0.2 == ？ 0.1 +0.2 是等于0.3的吗？这个问题似乎有点儿弱智，但是估计大多数人回答的都是错误的。在我们的认知当中，即使是在计算机当中，0.1+0.2也应该是等于0.3的啊，不然那不就乱套了嘛。不过现在你可以打开你的编译器来测试一下。 System.out.println((0.1+0.2 == 0.3)); // false 确实是不等的。。。那是不是Java的原因？我们可以使用C++，python测试一下. std::cout&lt;&lt;(0.1+0.2 == 0.3)&lt;&lt;std::endl; // 0 print( (0.1+0.2 == 0.3)) // False 我们发现无论是哪一种语言来说0.1+0.2都是不等于0.3的，这说明了这不是语言的问题了。那么0.1+0.2到底是多少呢？ std::cout&lt;&lt;std::setprecision(20)&lt;&lt;std::setiosflags(std::ios::fixed)&lt;&lt;0.1+0.2&lt;&lt;std::endl; 我们取了小数点二十位。输出的结果是0.30000000000000004441。这个结果果然不是0.3，后面为什么带了几个4呢？这是为什么呢？ 计算机中浮点数的储存众所周知计算机当中数据的存储都是二进制的。比如说2就是10,8就是100。如果有一个数带有小数的话，在计算中是如何存储的呢? 我们可以先来想想看如何把一个十进制小数表示成二进制。这个其实是和整数是一样的。二进制的小数点后的第一位是2-1=0.5，小数点后的第二位是2-2=0.25…以此类推。那么如何把0.1用二进制表示？和把一个整数转为二进制有点相似，小数转为二进制是使用乘以2的方式。 整数转为二进制：（除以2取余） 100/2 = 50 ……0 50/2 = 25 ……0 25/2 = 12 ……1 12 /2 = 6 ……0 6/2 = 3 ……0 3/2 = 1 ……1 1/2 = 0 ……1 然后将这些余数倒着写出来。100(10) = 1100100(2) 小数转为二进制：(乘以二取整) 0.1 * 2 = 0.2 ——0 0.2 * 2 = 0.4 ——0 0.4 * 2 = 0.8 ——0 0.8 * 2 = 1.6 ——1 0.6 * 2 = 1.2 ——1 0.2 * 2 = 0.4 ——0(开始重复了) 这次是将这些小数正写出来。0.1(10) = 0.0 0011 0011 0011 …… 可见二进制表示0.1是一个无限循环的数，可以float就占4个字节，double就占用8个字节。计算机是不可能使用这种方式来储存浮点数的。其实0.1~0.9999这9999个数中只有15个数可以用二进制精确的表示。 我们可以看一下Java当中基本类型表示的数的范围是多少 Java中基本类型的表示范围 数据类型 字节数 二进制位数 范围 规律 byte 1 8 -128～127 -27～27-1 short 2 16 -32768～32767 -215～215-1 int 4 32 -2147483648～2147483647 -231～231-1 long 8 64 -9223372036854775808 ~ 9223372036854775807 -263～263-1 float 4 32 1.4E-45~3.4028235E38 double 8 64 4.9E-324~1.7976931348623157E308 char 2 16 0～65535 0~216-1 boolean 1 8 true或false true或false float的大小是和int一样的，但是float表示的范围和int表示的范围比起来那可是一个天文数字。这就肯定说明了浮点数的储存是异于整型变量的。而且也必定说明浮点数是不精确的，不然如果float是绝对精确的，int还有存在的意义吗？这浮点数不也太能干了吗？ 其实浮点数为什么叫浮点数就是因为浮点数是浮动的，是不确定的。(量子力学？？)为什么浮动就要剖析一下浮点数存储的原理了。 浮点数的存储浮点数的存储分为一下四个部分。Java中浮点数的存储符合IEEE754标准。浮点数使用符号位、指数域和有效位数域来存储。 类型 符号位 指数域 有效位数域 float 1位（第31位） 8位（第23~30位） 23位（第0~22位） double 1位（第63位） 11位（第52~62位） 52位（第0~51位） 作用 表示浮点值的正负 存储指数位 存储小数值 浮点数的符号位和整型变量是一样的。0表示正数，1表示负数。 指数使用了偏移量的方式来表示。偏移量为2x-1(比实际值大2x-1)，x表示的是指数域的位数。 任何一个非0且非无穷大的浮点数都可以表示为 v = s × m × 2e的形式。 s为-1或1，m为有效位数(小数)，e为指数。 根据m和e的不同，我们可以将浮点数分为三类： 正规化浮点数 ——指数域不全为0且不全为1. 如99.5f在计算机中存储为：0 10000101 10001110000000000000000 有效位数是0.1000111，加上1为1.1000111转为十进制为1.5546875. 指数部分减去偏移量(01111111)就是110也就是6. 符号位为0，表示这是一个正浮点数。 99.5f = 1 × 1.5546875 × 2 6 = 99.5（就是这么完美） 16进制表示为 0x1.8ep6 (1.8e-&gt;1.10001110) p:代表指数位，因为e在16进制中已经被使用了。 6代表26 非正规化浮点数 ——指数域全为0且有效位数域不全为0 如5.877472E-39f在计算机中存储为：0 00000000 1000000000000000000000 有效位数为0.1此时不再加上1，转为十进制为0.5 指数位为 1-127为-126 符号位为0，表示这是一个正浮点数。 5.877472E-39f= 1 × 0.1 × 2-126 = 2-127(误差有点打好像。。。) 16进制表示为0x1.0p-127 特殊浮点数 浮点数 符号位 指数域 有效位数域 0 0 全是0 全是0 负0 1 全是0 全是0 正无穷大 0 全是1 全是0 负无穷大 1 全是1 全是0 NaN 任意 全是1 不全为0 所谓NaN就是 Not a Number 上面我们就基本了解了浮点数在计算机中是如何存储的了。 我们也可以使用Float和Double类中的中如下两个方法来查看对应浮点数在计算机中的存储情况。 public static int floatToIntBits(float value); // Float类中 public static long doubleToLongBits(double value); // Double类中 // 不过以上的两个方法输出的都是十进制的值我们可以使用 Integer (Long)类中的转为二进制 public static String toBinaryString(int i); public static String toBinaryString(long i); // 不过还是有问题，就是前面如果有0的话，0是不会输出的，我们可以根据输出的长度进行补0 浮点数比较需要注意的地方扯了那么多有点没的，其实还是要回到之前的那个问题上——浮点数之间的比较。0.1 + 0.2 == 0.3怎么才能让他返回true呢？ 设置绝对误差public static int compareFloat(float a, float b, double realError){ if (Math.abs(a-b) &lt;= realError){ return true; }else { return false; } } 不过这样真的合理吗？设置realError为 10-6 10-6好2 × 10-6返回的也是true。不过，平心而论他们的确不应该返回true。 而1000000000和1000000000.1应该返回true的却返回了false 设置相对误差public static int compareFloat(float a, float b， double absError){ if (Math.abs(a-b)/(a+b)*2 &lt;= absError){ return true; } return false; } 不过这种相对误差其实也是有点儿问题的。 其实对于浮点值精度的丢失的解决方法是非常复杂的，而且是没有一个固定的方法的。我们只能考虑到我们 自己的需求，设置合理的误差的范围进行合理的比较。 设置绝对误差和相对误差public static compareFloat(float a, float b, double realError, double absError){ if (a == b){ return true; } if (Math.abs(b-a) &lt;= realError){ return true; } if (Math.abs(b-a)/a+b*2 &lt;= absError){ return true; } return false; } 设置好合理的realError和absError就可以确保0.1+0.2 == 0.3啦 其实关于浮点数的转换也有很多的问题，不过这里就不多说啦。。。 总结浮点数是条蛇，别有事没事就玩它！尤其是这种代码就別写出来丢人了。。。蛤蛤蛤 for (double i = 0.1 ; i != 1.0; i += 0.1){ // ... } 之前看到没啥的，现在看到总是想笑~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的equals与==陷阱]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84equals%E4%B8%8E%3D%3D%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[浅谈Java中的equals与==陷阱 Java当中最常用的一个类便是String，对于C++程序员来说这个string也是非常熟悉的。到了Java这一块，咦，仅仅是变了一个大小写一样，还不是一样的用。不过用着用着就发现了一个天大的问题。这也是我实际写Java的时候发生的问题，程序莫名其妙死了，就是因为使用了Java的== std::string a = &quot;abc&quot;; std::string b = &quot;abc&quot;; if (a == b){ std::cout&lt;&lt;&quot;a is equal to b&quot;&lt;&lt;std::endl; } else { std::cout&lt;&lt;&quot;a is not equal to b&quot;&lt;&lt;std::endl; } String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } 对于一个C++程序员来说上面的代码输出什么估计想都不用想都知道是输出a is equal to b，但是如果是一个Java程序员他肯定会说肯定输入a is not equal to b。C++程序员在想：Java程序员这么弱智的嘛，这个a和b明显相等的啊！Java程序员在想：C++程序员这么智障的吗，这个明显不相等的啊！先不管这两个程序员骂来骂去的了，先看看为什么会发生这种情况。 这时候一般就会有一个大神跳出来说，你们这群蠢蛋，Java当中==比较的是地址，equals()方法才是比较的内容。C++程序员其实是在做这样的事 String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } C++程序员一测验，果然输出了a is equal to b。哇这个人果然是大神，晓得了晓得了，又学到了一个知识点，==比较地址，equals比较内容。不过C++程序员转念一想1 + 1 == 2难道在Java中都不对吗？于是反问大神，大神说：你是沙雕吗？这个肯定是true啊。那我加个限制吧，对于非基础类型而言，==是比较地址, equals()方法是比较内容。 但是C++程序员都是比较喜欢test瞎测验的。这一侧不得了了。 StringBulider a = new StringBulider(&quot;abc&quot;); StringBulider b = new StringBulider(&quot;abc&quot;); if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } C++程序员发现这两个输出的都是a is not equal to b。鬼鬼，这还得了啊。问了一下大神，大神也是哑口无言了。说起什么，你这个类不算，肯定是你的类出了问题。 那么问题到底出在了哪儿呢？ 首先我们要清楚为什么为什么每个类都会有一个equals方法。比如如下写了一个类 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } // 这里省略了setter public int getId(){ return this.id; } public String getName(){ return this.name; } } 我们发现这个类中没有写equals方法，但是我们仍然是可以调用的。原因就在于Java中的每个类都是默认继承Object的，也就是说equals是从Object中继承过来的方法。那就好办了，直接看看Object中equals()方法是怎么写的不就行了。 public boolean equals(Object obj){ return (this == obj); } 我靠！这个equals和==不就是一样的嘛。有个屁的区别啊。这大神不是在耍我完的吗？那为什么上面的String类中==和equals呈现的结果不同呢？那是因为String中是Override(覆盖)了equals方法的。 以上面的这个Student举例，判断两个人是不是相等，肯定不能用name(光是我听到的名字叫张旭的就至少五个，据说有一次考试按姓名分班，全校的张旭都坐一排，到了张旭，有来了两个张旭，感觉张旭这个名字比张伟还强，至少张伟这个一个都不认识)。所以我们应该用id来重载一下equals()方法。 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == obj.id; } return false; } } 哈，现在已经都完事了吧。这样这个类也算是完美了。 至于重写equals方法是有五个规定的，不过那五个规定估计傻子都不会违反的，这里就叭说了。 重写了这个equals难道这就完美了吗？不尽然。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == this.id; } return false; } } 你说此时，难道作为人的小明和作为学生的小明不是一个人吗？所以说这个equals还是有不足，没有考虑到可能有的父类。或者说这个equals可以直接在父类中重载，而不用在子类中重载。 把这一点也考虑到了，哇哈哈，这个equals已经完美了，不是么？ 嗯。。还真的不是，你以为你又能了，其实不然。尤其是在HashMap的使用上。 Student a = new Student(123, &quot;sher&quot;); Student b = new Student(123, &quot;sher&quot;); System.out.println(a.equals(b)); // true Map&lt;Student, Integer&gt; scoreMap = new HashMap&lt;Student, Integer&gt;(); scoreMap.put(a, 99); System.out.println(scoreMap.get(a)); // 99 System.out.println(scoreMap.get(b)); // null 你看，又出问题了。即使你a和b是完全一样的。但是放入HashMap中之后你却只能通过a来获取成绩了。这是因为HashMap使用的是哈希表。HashMap在判断你是否相等的时候是这样子的. if (a.equals(b) &amp;&amp; a.hashCode() == b.hashCode()){ .... } 前面虽然是相等的，但是后面是不相等的。那么后面那玩意是啥啊？其实他也是所有类都从Object继承的方法。当我们重写equals而不重载hashCode的话，就会在这些使用哈希表的集合中出现问题。所以api文档规定我们: 如果两个对象调用equals()是true，那么他们的hashCode必须是相等的。(hashCode返回一个int) 如果两个对象调用equals()是false，我们建议他们的hashCode不要相等。 所以我们还要Override一下hashCode方法。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Person){ Person p = (Person)obj; return p.getId() == this.id; } if (obj instanceof Student){ Student s = (Student)obj; return s.id == obj.id; } return false; } @Override public int hashCode(){ // int类型的hashCode系统已经替我们写好了 return Integer.hashCode(this.id);// 其实就写return id;好像也没什么问题，毕竟是整型变量。 } } 至此，是不是就没有问题了呢？其实，可能还有问题，不过还有什么问题，我也是不晓得的了，等学到了更多的知识，有了丰富的经验之后看这一小段代码，还是会有很多的问题。不过，这个问题，现在就叭说了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（八）堆排序]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（八）堆排序 堆排序算是里面最比较难懂的算法了，因为堆排序需要二叉树的基础。不过虽然说靠的是二叉树但是实际上并没有生成一个二叉树而是利用了顺序存储二叉树，来构造大顶堆和小顶堆来实现的。 堆排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 是 我感觉这个算法牛不牛逼已经是不言而喻的了。时间复杂度是交换法的巅峰，空间复杂度还是O(1)，这个算法实在是神奇。赶紧如果是学会了这个算法就可以去装逼了。别人排个序是 好几秒，你排个序是几毫秒。关键是你们用的还是同样的内存，这谁能顶得住啊！不过，要说明的是，堆排序是一种不稳定的算法。 堆排序的基本思路 上面也提到了，堆排序是用顺序存储二叉树来实现的。那什么是顺序存储二叉树呢？ 且看下图 我们大多数时候所了解到的二叉树都是上面的链式结构的二叉树，直观而且容易理解和操作。但是二叉树也可以用数组来表示。可以说一个数组就对应了一个二叉树。右面的图展示的是非完全二叉树的顺序存储，这里是我们不需要的。因为堆排序的时候要构造大顶堆(从小到大排序)。如果要是从小到大排序的话就要构造小顶堆。大/小顶堆就是一种完全二叉树。所谓完全二叉树所有的叶子节点(也就是没儿子的节点)都必须出现在最后两层，而且叶子节点在左面要连续。 按照上面的顺序存储的关系，上面的大顶堆可以转换成为一个数组来表示。 观察这个数组和二叉树，我们可以得出如下的结论。arr[n]的左子结点是arr[2n+1]，右子节点是arr[2n+2]，父节点是arr[(n-1/2)] 大顶堆的每个一个节点的值都大于他的左子结点和右子节点。但是左右节点之间的大小是不用限制的。 根据大顶堆的定义我们就可以知道大顶堆的根节点的值一定是所有节点当中最大的。如果我们把根节点去掉，然后利用剩下的节点再构造一个大顶堆。我们又可以找到第二大的节点，如此循环。我们就可以让数组变得有序。但是，如何构造大顶堆呢？ 看到上面的动图其实是有一点儿傻眼的，这不是数组排序吗？为什么搞这个一个二叉树在这？其实我们实际上并没有构造这个一个二叉树，只是把数组想象为一个完全二叉树罢了。要想把一个二叉树变成大顶堆，首先我们要看他的非叶子节点，因为叶子节点没有子节点，对于构造大顶堆是没有意义的。对于一个顺序存储二叉树，他的叶子节点是哪几个呢？答案是从0到arr.length/2-1。蛤？为什么是这几个节点啊？如果你仔细观察的话，叶子节点的个数永远是比非叶子节点多一个的，一棵树要么是叶子节点，要么是非叶子节点，所以非叶子节点个数 arr.length/2个。而非叶子节点都是存储在数组的前面的，所以说非叶子节点的下标是0到arr.length-1。 对于一个非叶子节点来说，要满足大顶堆的条件，就要使他大于他的子节点。而所有的非叶子节点都大于他们的子节点的话，这棵树就是一个二叉树了。 堆排序的代码实现 将数组调整为大顶堆代码实现 /** * 将一个数组（二叉树）调整成一个大顶堆 * @param arr 待排序数组 * @param i 非叶子节点在数组中的索引 * @param length 数组的大小(逐渐减小的) */ private static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; //：2*i+1 左子节点的索引 2*i+2 右子节点的索引 for (int k = 2*i+1; k &lt; length; k=2*k+1) { if (k+1&lt;length &amp;&amp; arr[k] &lt; arr[k+1]) { k++; } if (arr[k] &gt; temp) { //：子节点大于父节点， 两者交换位置 arr[i] = arr[k]; i = k; // 继续循环比较 }else { break; //：为什么break？ 以i为父节点的下面的都已经排序过了，都是大顶堆了 } } arr[i] = temp; } 代码说明： for循环里面的k, temp是干什么的 ? k的初始值是给定的非叶子节点的左子结点。每次循环都要到下一个左子结点。arr[k] &lt; arr[k+1]就是比较左右子节点哪个大。k++就是定位到右子节点，因为一开始k是指向左子结点的，右子节点的下标比左子结点大1。 temp保存的是给定的非叶子节点中的值。 arr[k] &gt; temp 说明左右子节点中较大的那个要比他要大，那么就把他赋给当前给定的非子节点。 为什么 i = k。为什么要循环比较？ 非叶子节点不是只有叶子节点，他们的子节点也会有子节点。假定我们让子节点的值变成非叶子节点的那个值，而非叶子节点的值又是很小的。那么那个子节点构成的岂不是大顶堆了？所以还是要递归下去继续构造大顶堆。 为什么else break？ 其实这个问题应该在第二个问题的前面的。我们构造大顶堆其实是从下往上构造的。也就是说从arr.length/2-1到0这个顺序来构造的。也就是说我们在构造非叶子节点i的过程中就知道他的左子树和右子树其实都是大顶堆。如果我们没有进行交换也就没有破坏左子树和右子树的大顶堆结构，如果进行交换了就有可能破环了他们的大顶堆结构了。毕竟如果交换了，说明非叶子节点的值要小一点嘛。你不能确保他比子节点的子节点的值要大。 arr[i] = temp 是什么意思？ 你或许发现了，我们始终没有说交换，这就有点像移位法的味道了。我们只是给i找到合适的位置，（第二个问题中的i = k 就是在做这个事情）当for循环退出了，意味着i的位置就找到了，这时给之前保存好的temp安上去就行了。 堆排序代码public static void heapSort(int[] arr) { int temp = 0; // 将其变成大顶堆 for (int i = arr.length/2-1; i &gt;=0; i--) { adjustHeap(arr, i, arr.length); } // ：将大顶堆上面的元素交换到末尾，然后对大顶堆最上面的元素排序 for (int j = arr.length-1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } } 代码说明： 第一个for循环? 其实第一个for循环就是我们上面说过的，大顶堆是从下往上构造的。只有这样我们才能确保要构造的非叶子节点的左子树和右子树都是大顶堆。 第二个for循环？ 将构造好的大顶堆的根的值(arr[0])放到数组的最后面，然后把数组最后面的元素移动到根处。并且还要将要进行构造大顶堆的 length-1，因为已经最大的那个数已经不用再去构造大顶堆了，安心在数组后面躺着吧。 adjustHeap(arr, 0, j)，这次构造大顶堆为什么没有循环了，而一开始需要循环？ 因为一开始的数组对应的二叉树的根节点的子树不是大顶堆。而此时，将一个大顶堆的根节点移走，然后取他的一个叶子节点作为新的根，这个新的二叉树虽然不再是大顶堆，但是根节点的左右子树依然是大顶堆。所以说不用再循环了。 堆排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); heapSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 9ms Time : 0ms Time : 15ms 8,000,000数据时： Time : 1686ms Time : 1703ms Time : 1672ms 总结 什么这个0ms你是认真的吗？我测试了几次，有好几次0ms，但是全写0ms有点太高调了，所以还是让你大一点，防止你骄傲。不过说实话处理八百万个数据的时候，堆排序处理的并不快。毕竟是空间复杂度O(1)的算法，对于海量数据的处理还是略显疲软。不过这并不然掩盖这个算法的光辉之处，能想到这样的排序算法，图灵奖获得者——弗洛伊德是真的牛逼。这个人好像写了不少有名的算法。QwQ]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（七）基数排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（七）基数排序 这里说的是基数排序(Radix Sort)而不是计数排序(Counting Sort)，计数排序也是另外的一种比较高效的排序算法，但是这个算法不在我近阶段要讲的算法之列。说起和基数排序类似的算法，桶排序(Bucket Sort)其实就是和基数排序是有点儿相似的，不过桶排序也不在近阶段介绍之列，蛤蛤蛤~~(⊙o⊙)… 基数排序的的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 一般 我们发现这个基数排序的时间复杂度似乎是比O(nlogn)要低的，但是这个O(nlogn)是比较类的排序算法的下限，基数排序是一种典型的使用空间来换取时间的算法，不属于比较类排序算法。另外要说的是，基数排序是一个稳定的算法。 基数排序的基本思路 基数排序的基本思路是准备十个桶。从0号桶到9号桶。第一次我们使用个位数进行排序，然后把数据从桶中依次取出来。第二次使用百位数进行排序。。。以此类推就这样这个数组就是有序的了。这个思路还是比较容易理解的。 下面直接上图吧。 再来一个图片看一下子 这个算法算是一般流弊算法吧。因为特别容易理解，没啥需要理解的，搞得我都不知道要说什么啦。。。 直接来上代码看代码的实现吧。 基数排序的代码实现 public static void radixSort(int[] arr) { int[][] backet = new int[10][arr.length]; int[] backetElementsCounts = new int[10]; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } // 下面两种方法都可以选择 转为字符串求数字的长度 int maxLength = (max+&quot;&quot;).length(); // int maxLength = Integer.toString(max).length(); for (int i = 0, t=1; i &lt; maxLength; i++, t*=10) { // 数据放入桶中 for (int j = 0; j &lt; arr.length; j++) { int which_backet = arr[j]/t%10; backet[which_backet][backetElementsCounts[which_backet]++] = arr[j]; } // 把数据从桶中取出 for (int j = 0, k=0, m=0; j &lt; 10; j++) { while (backetElementsCounts[j] != 0) { arr[k] = backet[j][m]; backetElementsCounts[j]--; k++; m++; } m=0; } } } 代码说明： 第三行代表的含义是什么？ 第二行代码其实就是在造桶子，十个桶子，每个桶子的大小的都是arr.length，因为万一所有的数的某一位都是相同的，那个桶子不就爆了喵？？而第三行的数组是存放每个桶子中的元素的个数。因为下面还是要取出元素的，不知道放了几个元素，怎么取，玩蛇皮的嘛。 为什么要求最大的数字的长度？ 这个把数字转为字符串来求长度还是非常的妙的。不过你问为啥要求最大的数字的长度？？因为后面我们要从个位数开始根据每个位置开始排序啊。 t的作用是什么？ 第一次取到个位数就是 num/1%10。取百位数就是 num/10%10。我们通过每次t /= t就可以依次取到各个位数了。每次放入一个元素之后，对应的用来计数的数组中的值也要增加1. 如何取出数据的？ 这恐怕是更容易理解的。找到桶里有数据的桶，看看桶中有几个数据取出来放到原来的数组中不就完事了。 唉~，这个算法是实在简单，搞得我是真的没话说了。我也是醉了吖。。。 基数排序的测试 测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); radixSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 12ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 423ms Time : 397ms Time : 404ms 总结 可以清楚的看到排八万个这种小数据的时候，几种高效的算法几乎没有区别。不过排八百万个数据的时候，基数排序就发挥出了他的优势。快啊！不过要说明的是，基数排序极其占用内存，如果是排序八千万个数耗费的就是4个G左右的内存，所以说在内存不足的情况下，这个算法是不适合考虑的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（六）归并排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（六）归并排序 归并排序算法是分治算法的一个典型。所谓分治算法就是把一个复杂的问题分成多个子问题。这些子问题如果都解决了，这个复杂的问题也就解决了，这是典型的先分后治的思路。归并排序也算得上是一个比较复杂的算法了，说实话原理容易看懂，但到底是如何解决的可要大费脑筋了。 归并排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 是 你或许看到了，是否牛逼那一块我写的是是，那这个算法也就是我们第一个接触到的，流弊的排序算法，因为速度是很快的。同时你也可以看到空间复杂度是O(n)，要知道很多复杂的算法以及各种各样的缓存机制，数据库等等都是使用空间来换取时间的，不过这样也并不意味着排序算法的时间复杂度可以变成O(1)，算法导论中有证明，排序算法的最低时间复杂度是O(nlogn)。 归并排序的基本思路归并排序的思路很难将明白，但是举个列子就很好说了。假如有待排序的数组4 1 2 5 8 7 6 0.我们找到mid((left+right)/2)先将其分为两个数组4 1 2 5和8 7 6 0（实际上我们并没有真的的分为两个数组，操作的始终是原来的那个数组）,然后再分为 4 1，2 5,8 7,6 0，然后继续分成 4,1,2,5,8,6,7,0.到这儿你或许会说，卧槽你这不是玩我的嘛，分了半天就是把数组之间加上逗号？玩蛇皮？其实我们的目的不在于分，而在于治。将 4 和 1 排成一个有序的数组简单不？就是 1 4 同理第一轮治理数组就变成了1 4 2 5 7 8 0 6然后再将1 4 和 2 5排序 7 8 和0 6排序。数组变成了1 2 4 5 0 6 7 8最后对1 2 4 5 和0 6 7 8 排序。数组变成了0 1 2 4 5 6 7 8，这样就变得有序了。 你或许在想，卧槽！这什么垃圾算法？这个速度也能快？这能叫流弊算法？ 但是人家是真的快啊，而且你没有注意到的是，我们始终在做一件事情，把两个有序的数组合并为一个有序的数组。这就是这个问题的子问题，我们只有解决了这个问题也就解决了排序这个复杂的问题了。把两个有序的数组合并为一个有序的数组真的是一件简单的事情，只需要一个额外的临时的数组的帮助就可以轻松的解决。 看了下面的这个图，应该就很容易理解了。把数组中的元素往下放就是下面有一个临时数组。 归并排序的代码实现首先我们先来完成治的过程，两个有序数组的合并 “治”的代码实现public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left;// 左边有序序列的初识索引 int j = mid+1;// 右边有序序列的初识索引 int t = 0;// 指向temp临时数组当前的序列 // 将左面和右面的值按照大小放入到临时的数组当中去 while (i &lt;= mid &amp;&amp; j&lt;=right) { if (arr[i] &lt;= arr[j]) { temp[t] = arr[i]; ++t; ++i; }else { temp[t] = arr[j]; ++t; ++j; } } // 如果左面还剩下数据的话，直接放入临时数组中，此时右面的已经都放入了临时数组中。（上面while退出就是一个已经放完了） while(i &lt;= mid) { temp[t] = arr[i]; ++t; ++i; } // 同理，左面为空，右面还有数据，直接放入临时数组当中 while (j &lt;= right) { temp[t] = arr[j]; ++t; ++j; } // 将temp拷贝到原始的数组当中去。注意放入临时数组的范围是从left到right t = 0; int tempLeft = left; while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; ++t; ++tempLeft; } } 代码说明： 函数的参数是？？ 首先需要说明的是，数组其实是没有分的，只是逻辑上分为了几个数组，待合并的数组也还都是相邻的。 left是左边有序数组的开始 mid是中间的那个数，也就是(left+right)/2，需要注意的是，mid这个位置的值是属于前面的那个数组的，所以说右边有序数组的开始是mid+1。right是待合并的数组的结束。也就是说这个函数操作的只是数组的arr[left]到arr[right]而已。 temp 是用来辅助排序的临时数组 第一个while循环在干啥？ 很好理解第一个while循环是不停的把两个有序数组中的元素放入临时数组中去，直到有一个数组为空了，就退出while循环。这时，我们就可以直接把不为空的那个数组放入到临时数组的后面。于是便有了后面的两个while循环。 最后一个while循环是? 把临时数组中的元素拷贝到待排序数组的left到right上。我前面说过，数组其实并没有真正分为两个，只是逻辑上分为两块而这一个函数操作的就只是数组的left到right。也就是说一个函数只是解决了一个子问题。 “分”的代码实现public static void mergeSortHelper(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right)/2; // 找到中间值，开始分治 mergeSortHelper(arr, left, mid, temp); mergeSortHelper(arr, mid+1, right, temp); merge(arr, left, mid, right, temp); } } public static void mergeSort(int[] arr) { int[] temp = new int[arr.length]; mergeSortHelper(arr, 0, arr.length-1, temp); } 代码说明： 这我咋有点看不懂？ 虽然治才是分治法的核心但是这里的分确实是有点不好理解。不好理解的主要原因是你对递归的了解还不够透彻。上面将数组分为了两个部分，然后合并。 一开始左右不是无序的吗？怎么能合并呢？ 这就是我所说的递归的理解了。执行到第一个mergeSortHelper时会一直递归，递归到left == right退出递归。执行下面的第二个mergeSortHelper，需要注意的是此时位于的是退出的那个栈的前一个栈，也就是right - left == 1的那个栈。回到那个栈之后又是一直递归。又到了left == right又退出了递归。那么执行到第三个合并的时候位于那个栈呢？此时第一个mergeSortHelper的栈都位于底部。最上面的那个栈是left = 0，mid =0， right=1。为什么呢？因为退出的那个栈是left == right而这个right就是上一层的mid 也就是说mid = (left + right)/2是为0的。而这个栈是没有退出的也就是说left &lt; right。所以right =1；。。。。我特喵的再将什么。算了不说这个递归过程是如何的了。直接通俗的将一下吧。 我听不懂你乱七八糟的说辞，可以讲的简单一点吗？ 双递归函数本来就有点乱，况且后面还带了一个函数，我理解的也不是很透彻。简单的将就是mergeSortHelper的作用是left到right变得有序，第一个mergeSortHelper因此就是使左面有序，第二个是使右面有序，第三个是使左右两个有序的合并。 这也行？讲的也太敷衍了吧。。。 其实一点都不敷衍，你看看其他的两次递归算法。比如斐波那契数列，汉罗塔问题。不都是这样解决的吗？ 斐波那契数列代码public static int fibonacci(int n){ return (n==1 || n==2)?1:fibonacci(n-1)+fibonacci(n-2); } 汉罗塔问题代码public static void hanoi(int n,char a, char b, char c){ if (n == 1){ System.out.println(a+&quot;-&gt;&quot;+c); } hanoi(n-1, a, c, b); System.out.println(a+&quot;-&gt;&quot;+c); hanoi(n-1, b, a, c); } 上面的两串代码都是即兴瞎写的不保证对，但是思路是一样的。你说这些递归问题都是如何解决的呢？如果说斐波那契数列比较容易理解，这个肯定是可以算出的啊。那么汉罗塔问题呢？？这个问题够复杂了吧。将n个盘借助b从a移动到c，我们只需要分析子问题是什么——子问题是将n-1个盘借助c移动到b，然后将最大的那个盘从a移动到c，然后再借助a把n-1盘从b移动到c。这里我们只需要知道1个盘怎么移动，那么2个盘，3个盘就是999999个盘我们都可以知道。（如果有64个盘，有一个人知道如何移盘，假设他一秒移动一个盘子，那么移动到太阳系没了也不会移完的。）归并排序也是如此。当right只比left大一的话(此时不用多次递归)就可以合并这个数组，那么当right比left大得多的时候呢？不就是根据先把左右有序然后合并一样的道理吗？这就是递归解决问题的神奇之处。 归并排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Randon.nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); mergeSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 11ms Time : 12ms Time : 16ms 8,000,000数据时： Time : 1029ms Time : 1024ms Time : 1007ms 总结可能是测试的时候电脑的问题，为啥归并排序排8,000,000还比快速排序慢啊，这个其实很意外，按照时间复杂度来说应该是归并排序快一点啊。不过再我多次测量了之后，速度稳定在1000ms，放弃了。唉~，只能说一句，快速排序牛逼！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（五）快速排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（五）快速排序 希尔排序是插入排序的升华，这里说的快速排序其实就是冒泡排序的升华？（啥？冒泡排序终于有了出人头地的机会了。。）不过我反正是很难看出来快速排序和冒泡排序之间的关系多的。冒泡排序是相邻的两个值之间进行比较然后进行交换，而快速排序是一种递归的过程。。真心发现不了其中的关系。 快速排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) 一般 之前也已经说过了，快速排序是一种不稳定的排序算法，是冒泡排序的一种优化，至于是如何优化的，后面一起看一下子吧。 快速排序的基本思路希尔排序是将数据分组进行插入排序，那莫非快速排序就是把数据分组进行冒泡排序？其实并不是。 快速排序的思路是： 以当前的数组中的一个元素(一般取第一个元素也就是arr[0])作为基准值，然后将数组变换为左面的数都比基准值小，右值的值都比基准值大，然后对左面的那一块和右面的那一块进行同样方式的快速排序。直到发现待排序的数组的大小只有1的时候就退出。此时数组也就变得有序起来了。 下图中是将数组的最后一个作为基准值的，其实都是一样滴~ 这张图是以最左面的值作为基准值的，讲解的也蛮不错的，就是画质太渣了。 可以清楚的看到上面两个快速排序的实现思路是有一点不同的。第一张采用的是移位法，第二张采用的是交换法。所以说，和插入排序，希尔排序一样，快速排序也有两个实现的思路。 快速排序——交换法代码实现public static void quickSort(int[] arr, int left, int right){ // 这个是后面的递归的退出的条件 if (left &gt;= right){ return; } int temp = arr[left];// 最左面的值作为基准值 int l = left; int r = right; int t;// 用于下面的数据的交换 // 其实交换用不着额外的变量可以使用异或的操作来进行 a^=b^=a^=b 就可以对整型变量的值进行交换 while(l &lt; r){ // 从右面找到比基准值小的下标 while(l &lt; r &amp;&amp; arr[r] &gt;= temp){ --r; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; // 从左面找比基准值大的下标 while(l &lt; r &amp;&amp; arr[l] &lt;= temp){ ++l; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; } // 退出的时候 l == r 这是肯定的毕竟每次都是只走一步l和r必定会相遇。相遇的时候arr[l] == temp! // 对数组的左面和右面进行同样操作，也就是递归.其实两个if是多余的，上面已经有了退出递归的条件了。不过加上if就可以减少一次递归的次数，何乐而不为呢？ if (left &lt; l-1){ quickSort(arr, left, l-1); } if (l+1 &lt; right){ quickSort(arr, l+1, right); } } public static void quickSort(int[] arr){ quickSort(arr, 0, arr.length-1); } 代码说明： 基准值为什么选第一个数？ 其实你要是乐意的话，left到right之间的任意一个值都是可以取的。只要你有本事写出对应的算法就完事了。一般情况下我们是取第一个值(arr[left])或者最后一个值(arr[right])的。 基准值的选择会影响后面的代码？ 这肯定的啊。要不然选个锤子的基准值的。后面我们做的事情就是不停的交换使得基准值位于这样一个位置——左面的值都比他小，右面的值都比他大 这个到底是如何做到的，我看只是只是l和r不停的交换的啊？ 如果你仔细留意我上面的倒数第一张图的话，你会发现虽然是l和r的交换，实际上每次都有基准值的参与。一开始基准值位于arr[l]，我们从右面找到了第一个小于基准值的数，经过第一次的交换我们就可以确定当时r右面的值都是比基准值大的。此时基准值位于arr[r]。我们又从左面找到第一个比基准值大的数，进行第二次交换，基准值的位置又到了arr[l]，此时我们依然可以确定l左面的值都是比基准值小的。如此一来循环往复。我们始终可以确信的是，left到l-1上的值都是比基准值小的，r+1到right上的值都是比基准值大的。直到l和r相遇，基准值位于arr[l]处，他左面的值都比他小，右面的值都比他大。 为什么一开始先从右面开始，也就是说为什么先从右面找第一个小于基准值的数？ 因为一开始选定的基准值是位于arr[left]的吖，如果你选定的是arr[right]作为基准值的话，你就要先从左面开始找大于基准值的数了。如果你选定的是其他位置的话。。你为什么要那么欠呢？如果你不嫌麻烦的话，当我没说。。。 快速排序——移位法代码实现public static void quickSortPlus(int[] arr, int left, int right) { if (left &gt;= right) return; // 此时不用排序 int temp = arr[left];// 记录基准值。 左面的数都比基准值小，右面的都比基准值大 int l = left; int r = right; while (l &lt; r) { // 从右面找到比基准值小的数 while (l &lt; r &amp;&amp; arr[r] &gt;= temp) { --r; } // 移动到左面， 此时第一轮的时候基准值被覆盖 arr[l] = arr[r]; // 从左面找到比基准值大的数 while(l &lt; r &amp;&amp; arr[l] &lt;= temp) { ++l; } // 将大的数移动到后面，此时后面的那个比基准值小的数被覆盖了 arr[r] = arr[l]; } // 退出循环的时候l==r 此时这个位置就是temp这个基准值应该插入的位置 arr[l] = temp; // 递归下去对左右两边进行排序 if (left &lt; l-1){ quickSortPlus(arr, left, l-1); } if (l+1 &lt; right){ quickSortPlus(arr, l+1, right); } } public static void quickSortPlus(int[] arr){ quickSortPlus(arr, 0, arr.length-1); } 移位法其实说的已经蛮多的了，这里就不再赘述了。其实代码也就改了几行而已。也么得什么好说的。 快速排序的测试public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); quickSortPlus(arr); // quickSort2(arr, 0, arr.length-1); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 80,000数据时： Time : 14ms Time : 23ms Time : 25ms 8,000,000数据时： Time : 836ms Time : 804ms Time : 772ms 移位法 80,000数据时： Time : 14ms Time : 13ms Time : 15ms 8000000数据时： Time : 734ms Time : 848ms *Time : 832ms 总结 感觉也没啥好说的，这个快速排序是真的蛮快的了。不过这还并不是最快的，虽然他名字是快速排序。。。至于我一开始提到的那个快速排序是冒泡排序的改进，我是真的没怎么发现这两个算法之前的联系有多么的紧密。你说希尔排序是插入排序的改进，这个我能看出来，快速排序和冒泡排序。。。额，还是我太蠢了吗？看不粗来啊！至少速度上，是看不出来，，，蛤蛤蛤，冒泡排序哭死~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（四）希尔排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（四）希尔排序 之前说的是插入排序，虽然插入排序的效率嘛已经说是可以的了，但是插入排序有一个明显的漏动。比如说给定的数组如果是 1 2 3 4 5 6 7 8 9 0使用插入排序要将这个0移动到数组的最前面还是非常费力的。也就说是如果有很多小数据位于数组的末端，插入排序的效率就会极大的降低。而这次要说的希尔排序就是插入排序的一种，也就死来解决这个问题的。 希尔排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 希尔排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 一般 希尔排序虽然是插入排序的一种优化，但是希尔排序是不稳定的，插入排序是稳定的。于此类似的是快速排序是冒泡排序的优化，但是快速排序不稳定，冒泡排序稳定。不过。。稳定性这个玩意我到现在还没有用到过。 希尔排序的基本思路希尔排序的基本思路就是分组进行插入排序。就还比如说上面的那个数组 1 2 3 4 5 6 7 8 9 0，我们将其分为五组，1 6 ，2 7.3 8.4 9.5 0。对这五组数据进行插入排序，那么清晰的可以看见0到前面却。然后将数据分为两组，继续插入排序。再将数据分为一组(此时就是插入排序了)进行排序就完事了。既然希尔排序中包含这插入排序那为啥希尔排序的速度还比插入排序快啊，希尔排序的前面的几次分组将小的数据往前面进行了移动，最后的那次插入排序移动的次数是很少的。所以说希尔排序是一种较为高效的算法。 下面的图片基本上就讲的比较清楚了。 再来一个图片演示一下 希尔排序和插入排序一样，都有交换法和移动法的实现，我们就分别都用代码演示一下。 希尔排序——交换法代码实现//这也是插入排序的一种 ,因为插入排序是 ,如果小的数在后面的话 插入排序的效率特别的低,所以出现了希尔排序，是插入排序的一种改进 public static void shellSort(int[] arr) { int temp = 0; // System.out.println(&quot;原来的数组：&quot;+Arrays.toString(arr)); // 这里的gap指的是不同的组数据之间的距离。 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { for (int j = i; j &gt;= gap; j -= gap) { // 交换的次数太多了 太浪费时间 if (arr[j] &lt; arr[j - gap]) { temp = arr[j]; arr[j] = arr[j - gap]; arr[j - gap] = temp; }else break; // 分组进行插入排序，如果上面的条件不成立就说明已经插入到了指定的位置。 } } // System.out.println(&quot;第x次排序：&quot; + Arrays.toString(arr)); } } 代码说明： gap是什么？ gap指的是同一组当中相邻的元素之前的距离。初始值是arr.length/2，以后每次都除以2，这就是为什么我在一开始的那个数组中先分为五组再分为两组最后再分为一组。等到gap等于1也排序完成了之后，gap/2变成了0，此时排序完成，就可以退出循环了。 i和j代表着什么含义？ i从gap开始是为什么？ i代表的是每组元素的后面无序元素，从每组第二个元素开始。这就好比插入排序，每一组的第一个元素是有序的，而后面的元素是无序的，我们要将后面的无序的数据插入到前面的有序的数据中。其实我们完全可以写了个函数insertSort(int arr[], int gap)。gap等于1的时候就是上面篇博客当中的插入排序的算法。 j就是要插入的元素所在的位置，只不过这一次他前面的那个元素不再是j-1，而是j-gap， 如果理解了上篇博客的插入排序的思路的话，这个希尔排序也是非常容易理解的。 有三层for循环，效率为什么高？ 有三层for循环并不代表这时间复杂度就是O(n^3^)，第一层for循环每次都除以2，时间复杂度是O(log2n)。第二层的for循环每次都加1，时间复杂度是O(n)，第三层for循环的每次都减去gap，复杂度也在O(logn)左右。所以这个算法的时间复杂度是O(nlog^2^n)。数据量越大，越是比O(n^2^)的排序算法来的优越。 希尔排序——移位法代码实现 // 和插入排序法相似，希尔排序也有两种实现的方式，一个是上面的那个交换法，另一个就是下面的移动法。 // 采用移动法 对交换式的希尔排序进行改进 思路与之前的插入排序是相似的 public static void shellSortPlus(int[] arr) { for (int gap = arr.length/2; gap &gt; 0; gap/=2) { for (int i = gap; i &lt; arr.length; i++) { int insertIndex = i; int insertVal = arr[i]; while (insertIndex-gap &gt;=0 &amp;&amp; insertVal &lt; arr[insertIndex-gap]) { arr[insertIndex] = arr[insertIndex-gap]; insertIndex -= gap; } arr[insertIndex] = insertVal; } } } 代码说明： 其实这个代码也没有什么要说明的，这就是插入排序的套了个gap嘛。不懂的可以去看看插入排序的那个算法去。嘤嘤嘤~ 希尔排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80,000个和8,000,000个[0, 800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random() * 800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); shellSort(arr); // shellSortPlus(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot; + (end_time - start_time) + &quot;ms&quot;); } 交换法 80,000数据时： Time : 14ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 2008ms Time : 2018ms Time : 1973ms 移位法 80,000数据时： Time : 17ms Time : 17ms Time : 15ms 8000000数据时： Time : 1868ms Time : 1824ms Time : 1873ms 总结希尔排序虽然只是对冒泡排序的一个小小的改进，但是看到了这个希尔排序的速度后，这肯定是要惊呆了！！什么！！！排序八百万个数据也就和插入排序法排序八万个差不多！什么！！冒泡排序法，，它。。要寻短见？ 这不能喽，程序员需要冒泡排序法！你排七八个数据难道还要写归并排序，堆排序嘛，还不是一个冒泡排序写的舒服~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（三）插入排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法(三) 插入排序法插入排序算法，冒泡排序算法，和选择排序算法三个合称三大基本排序算法，因为都是相对比较简单易懂的算法，相对来说算法的效率也是比较低的。但是这个插入排序算法比起冒泡选择来说难度还是高一点的，而且在学校中教授的也只有冒泡排序和选择排序，插入排序是没有教授的。 插入排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 插入排序法 O(n^2) O(n) O(n^2) O(1) 否 插入排序算法是一种稳定的算法，和冒泡排序是一样的，相同的数据经过插入排序之后相对位置是不变的。 插入排序的基本思路插入排序的思路是将待排序的数组分为两个数组，左面是有序的数组，右面是无序的数组，（一开始左边的第一个元素就自成一个有序数组，毕竟只有一个元素，怎么说都是有序的）然后将无序数组的第一个数据插入到有序的数组当中去。于是有序的数组越来越大，等到无序的数组中的所有的元素都插入到了有序的数组中的时候，排序就完成了。 对于无序的数据如何插入到有序的数组当中去有两个实现的办法。一个是交换法，另一个是移位法。上面的动图实现的就是交换法。让我们先从简单的交换法讲起。 插入排序——交换法的代码实现感觉这个算法看一下上面的那个动图就能清楚的明白。就是如同冒泡排序法一样，如果要插入的数据被前面的数据小的话，两者交换数据，然后继续比较，直到插入的数据大于前面的那个数据(此时便插入到了合适的位置了)退出循环即可。 // 插入排序， 使用直接交换的方法，这样交换的次数就非常多了，效率就变低了 public static void insertSort(int[] arr) { int temp;// temp用于下面的交换 // 左面有一个数据是有序的，无序的数据是从第二个开始的，所以i的初始值为1 for (int i = 1; i &lt; arr.length; i++) { for (int j = i; j &gt; 0; j--) {// 使用交换的方式来插入当前的数据 if (arr[j] &lt; arr[j-1]) { temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; }else { // 如果上面的if不成立就说明这个数已经到达了指定的位置，因为左面的数组是有序的。 break; } } } } 代码说明： i 为什么从一开始？ ​ 因为插入的值是从无序开始的，而一开始arr[0]就是有序的，无序的从arr[1]开始，所以i是从1开始的。 j。。。好像没啥好说明的。这个代码还是非常容易理解的。还是叭说了QwQ 插入排序——移位法的实现移位法不是交换数据来实现数据的插入，而是先把待插入的数据保存起来。然后依次与前面的有序的值进行比较。如果前面的值比待插入的值大的话，直接将前面的值赋给后面的值(就好像移动位置一样，前面的值将后面的值覆盖了)。然后继续比较。如果小于的话，直接将当前的位置赋予之前保存的那个待插入的值，然后退出本次循环。 // 采用的是移位法不是交换法，极大的提高了插入排序的效率 public static void insertSortSgg(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { int insertVal = arr[i];// 保存要插入的值 int insertIndex = i; // 要插入的位置。。。 // while循环找到了当前值应该插入的位置 while (insertIndex &gt; 0 &amp;&amp; insertVal &lt; arr[insertIndex-1]) { arr[insertIndex] = arr[insertIndex-1];// 将大的数据后移 insertIndex--; } arr[insertIndex] = insertVal; // 插入数据 } } 代码说明： insertVal和insertIndex是干什么用的？ insertVal用于保存当前要插入的值，也就是后面的无序的数组的第一个元素。如果不保存的话，根据移位法，要插入的值将可能被前面的值覆盖，那还玩个蛇皮！ insertIndex是保存要插入的位置，初识值就是要插入的值的原本的位置（即没有发生移位）。 while循环写的是什么玩意，我为啥看不懂？？ while循环里面的第一个条件是保存你不能插到数组的外面去（咋滴，你是想飞还是干啥，想插入到数组的外面去？），第二个条件是要插入的位置的前面的位置的值要比要插入的值大。刚才也分析过了，如果比要插入值小的话，就说明要插入值放在这个位置是正确的。（前面的位置比他小，后面的位置比他大）注意：此时要插入的值后面的那个值是和当前位置的值相同的。insertIndex是因为满足了insertVal &lt; arr[insertIndex-1]（上一层循环的条件,因为insertIndex–同时由于数据右移了，所以，在本层循环应该是 insertVal&lt; arr[insertIndex+1]）这个条件才来到这个位置的。所以说，如果不满足这个条件，insertVal就应该放在insertIndex上。 while循环里面是干啥？ 进入while循环就意味着满足 insertVal &lt; arr[insertIndex-1]这个条件也就是说如果insertVal放在insertIndex这个位置是 arr[insertIndex] &lt; arr[insertIndex-1]，后面比前面小，这不满足条件啊，所以说要移动位置继续向前探索！ 插入排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*80000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); insertSort(arr); // insertSortPlus(arr); // insertSortPlusPlus(arr); // insertSortSgg(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 Time: 2531ms Time: 2340ms Time: 2376ms 移位法 Time: 1580ms Time: 1580ms Time: 1540ms 总结和冒泡排序，选择排序比起来插入排序有一定的优势，毕竟是基本算法中既有稳定性，速度还可以的算法啦。移位法的速度比选择排序快一点，交换法虽然慢一点但是容易理解。这个移位法其实蛮容易理解的，可能是我没有画图，所以讲的不清楚吧，下次我把图补上(网上没找到合适的图)，应该就好多了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（二）选择排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（二）选择排序法选择排序算法和冒泡排序算法算是难兄难弟了，都是以其简单而闻名，也是在学校中我们主要学习的排序算法。但是不是不说，这个选择排序算法除了不稳定，其他都可以吊打冒泡排序算法。那现在难兄没了，只剩下这个难弟冒泡排序算法了。 选择排序法的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 选择排序法 O(n^2) O(n^2) O(n^2) O(1) 否 选择排序法是一种不稳定的算法，也就是说相同的数据经过选择排序法之后不一定会保持原来的顺序。 选择排序法的基本思路每次使用第一个位置的（不一定是arr[0]）和之后的数据比较，找到最小的那个数据然后两者交换。如此一来，小的数据就往数组的前面去了，数组也就变得有序了。不是我说，这个排序一看就比冒泡排序法好，因为每一轮排序只需要进行一次的交换。当然比较节省时间了。 从上图可以看出来，选择排序似乎和冒泡排序有点相似，一个是把大的数据往后边沉，一个是把小的数据往前面搬。 代码实现 public static void selectSort(int[] arr) { int temp; for (int i = 0; i &lt; arr.length-1; i++) { int minIndex = i; for (int j = i+1; j &lt; arr.length; j++) { if (arr[minIndex] &gt; arr[j]) { minIndex = j; } } if (minIndex != i) { temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } } } 代码的几点说明： i，j的作用： i变量指的是数组开始排序的位置，因为每排一个序，前面就多一个数字变得有序，所以我们就没有必要动那些已经变得有序的数组了。所以说需要排序的范围就是 i 到 arr.length -1 j变量值的是i后面的那些数据，所以从i+1开始一直到数组的结束。i的结束的数组的倒数第二数，如果i到最后一个数的话后面已经没有数据，一个数怎么说都是有序的，所以说i没有必要到最后一个数。每次arr[i]也就是当前循环的第一个数都会与后面的arr[j]进行比较，一轮之后和最小的数进行交换然后i移动到下一个数 为什么只有一次交换？ 因为minIndex变量的存在（minIndex被初始化为了i），我们可以存储找到的最小的值的下标，而不是一味的交换i与j的数据。当我们发现arr[j] &lt; arr[minIndex]时，就把minIndex = j；因为他的值更小嘛，如此一来，我们就可以得到后面的最小值的下标了。一轮循环结束之后再进行交换（i != minIndex 如果i == minIndex那就说明if语句一直都是假的，arr[i]处的值就是最小的，没有必要和谁交换啦)。 选择排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); selectSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 测试结果： Time: 1629ms Time: 1417ms Time: 1606ms 总结选择排序法虽然和冒泡排序深处基本排序算法之列，但是选择排序的速度比冒泡排序法快的不是一点半点。虽然说冒泡排序法有稳定性上面的优势，但是同处基本排序算法的插入排序法也是稳定的，而且插入排序法的效率也蛮高的。冒泡排序。。。很危险吖~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(一） 冒泡排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（一） 冒泡排序法冒泡排序法可谓是我们学到的第一个排序算法了，以其简单易懂而闻名，但是这个算法又是特别的垃圾，因为效率及其的低下。 下面是一些经典的排序算法的时间复杂度： 别看这个冒泡排序法的时间复杂度和选择，插入是一样的，但是效率却远远比选择，插入低，尤其是数据量很大的时候。 冒泡排序的思路冒泡排序的思路就是每次把最大的数挑出来放到数组的最后面(排序皆是从小到大)。如下图所示 每一次将最大的元素移动到数组的后面，移动了5次，这个数组就是从大到小有序的了。 代码的实现冒泡排序比较容易理解，代码也是比较好写的。 public static void bubbleSort(int[] arr) { boolean flag = false; int temp; for (int i = 0; i &lt; arr.length-1; i++) { for (int j = 0; j &lt; arr.length-i-1; j++) { if (arr[j] &gt; arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = true; } } if (!flag) { break; }else { flag = false; } } } 代码的几点说明： i和j的含义 可以清除的看到在两个for循环的循环体中是没有i变量的，也就是说i变量只是用来计量有几个大数被移动到了数组的末尾。 j变量是用于交换. j &lt; arr.length - 1-i的作用是后面的几个变量已经排过序了，他们就是最大的那几个数，j变量可以不用对他们进行比较交换啦。j从0开始每次和j+1进行比较，如果arr[j]大，也就是前面的数大，就把他往后面移动。如此一来，前面的几个数中最大的那个数就被移动到当前j所比较的末尾arr.lenght-1-i处。 flag的作用是什么？ flag这个是对冒泡排序法的一个优化，虽然优化过后这个算法还是一样的垃圾。。。flag所代表的含义是该次循环中有没有发生过交换。一开始我们将其置为flag(不初始化也是可以的，boolean型的变量的初始值就是false).当本次循环进行过交换的时候，将flag置为true。然后再将循环置为false。当有某次的循环中没有进行过交换，这个也就是意味着此时数组前面的那几个数已经是有序的了，而数组后面的数同样也是有序的，所以退出循环排序结束。 冒泡排序的测试：测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); bubbleSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 测试结果： Time： 8786ms Time： 8706ms Time： 8661ms 总结哇！！！八万个数据的排序才花了八秒，这个算法好厉害啊！！！我是不会告诉你后面的堆排序，归并排序排序八万个数只是用了10ms，排序八百万个也用不了一秒的。。 冒泡排序算法中有着大量的数据的交换，这就注定了这是一个低效的算法。但是还好的是，冒泡排序算法是一个稳定的算法。所谓稳定的算法就是拥有相同的值的数据在排序完之后的顺序保持不变. 比如说 8 3 4 5 3 6 排序后是 3 3 4 5 6 8，排序完的第一3仍然是原来数组中的第一个3]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用赫夫曼编码来压缩数据]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%88%A9%E7%94%A8%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[利用赫夫曼算法来压缩数据压缩文件是我们经常碰到的文件类型，一般在windows上 rar zip 7z这几种格式是最常见的。因为格式的不同他们的原理也同样不同。这里介绍的是使用赫夫曼算法进行简单的压缩数据。 首先要来了解一下赫夫曼树是什么。 赫夫曼树 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 简单的来说赫夫曼树就是WPL最小的树。 WPL计算WPL首先要知道这个树的权值，然后还要知道这个树的高度(所谓高度就是到根节点的经过的节点的个数)。 想要一个树是最优二叉树(WPL最小的树)，我们就要尽量把权值较大的数据放在靠近跟节点的地方，把权值较小的数据放在远离根节点的地方。 如何构造赫夫曼树首先我们要新建一个节点，因为赫夫曼树要比较权值的大小，所以这个节点类还要实现Comparable接口. // ：让Node是实现Comparable接口，使之可以排序 class Node implements Comparable&lt;Node&gt;{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } @Override public String toString() { return &quot;[value=&quot; + value + &quot;]&quot;; } //：返回 -1 0 1 @Override public int compareTo(Node o) { //： 表示从小到大排序 return this.value - o.value; //： 表示从大到小的排序是 return o.value - this.value } } 这样一个节点就创建好了。 接下来就可以来生成一个赫夫曼树了 class HuffmanTree { public static Node createHuffmanTree(int[] arr) { List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int val : arr) { nodes.add(new Node(val)); } while(nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // ：最小的那个节点 Node rightNode = nodes.get(1); //：第二小的那个节点 Node parentNode = new Node(leftNode.getValue() + rightNode.getValue()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } //：实现了Comparable，可以进行排序 return nodes.get(0); } } 由代码可见，上面的算法的步骤是： 1. 先将所有的节点放入到一个ArrayList中。 2. 先将这个ArrayList排序，找到最小两个节点，同时new一个新的节点，使其左节点指向稍微小的那个节点，右节点指向稍微大的那个节点。 3. 从ArrayList中去除刚才取出的两个节点，放入新的节点。 4. 循环第二步和第三步，知道ArrayList中就剩下最后一个节点。这个节点就是赫夫曼树的根节点这个算法还是蛮容易理解的，刚才所有的节点都是赫夫曼树的叶子节点，所有的非叶子节点都是我们新生成的。通过上面的这个算法，我们就能轻松的得到一个赫夫曼树。 赫夫曼编码计算机中的文件都是以二进制的格式存放的。我们先以字符串来举例。 java java java is good good but cpp cpp is best best 上面的这段话，在计算机中储存也是以二进制的文件进行储存的。我们知道一个字符对应了一个八位的byte，也就是一个ascii。那上面的数据在计算机中储存就是n*8bit。 这就是最直接的编码，每8位对应一个字符。 但是不难发现上面的字符串中存在不少的重复的字符。 j出现了3次，a出现了六次，空格出现了11次。 如果我们按照这些字符出现的顺序对其重新进行编码，不是就节省了不少的内存了吗？ 空格编为0，a编为1， o编为10， p编为11.。。。 但是这样也带来了更大的问题，比如说计算机中的11解码成aa还是p呢？？也就是说这样的编码会代码混乱，这样的编码不是一个前缀编码。前缀编码需要满足这样的条件，任何一个码不能是另外的码的前缀。 这些字符出现的顺序对其重新进行编码这种思路是对的，但是如何采取最优的措施呢？ 这不难想到上面说的赫夫曼树，字符出现的顺序就是字符的权重，构造一颗赫夫曼树或许能够解决我们的问题。 利用字符串来构造赫夫曼树首先我们要构造一个新的节点 class NewNode implements Comparable&lt;NewNode&gt;{ private Byte data;// 字母 private int weight;// 出现了多少次 private NewNode left; private NewNode right; public NewNode(Byte data, int weight) { this.data = data; this.weight = weight; } public Byte getData() { return data; } public void setData(Byte data) { this.data = data; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public NewNode getLeft() { return left; } public void setLeft(NewNode left) { this.left = left; } public NewNode getRight() { return right; } public void setRight(NewNode right) { this.right = right; } @Override public String toString() { return &quot;[data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;; } @Override public int compareTo(NewNode o) { return this.weight - o.weight; } public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } } 然后我们还需要统计每个字符出现的次数，将结果放入一个ArrayList中 /** * 由原始字节数组生成对应的集合 * @param bytes 原始字节数组 * @return 数值加权重的对应集合 */ public static ArrayList&lt;NewNode&gt; getNodes(byte[] bytes){ ArrayList&lt;NewNode&gt; nodes = new ArrayList&lt;NewNode&gt;(); //：使用map[key, value]遍历统计每个字符出现的次数 HashMap&lt;Byte, Integer&gt; counts = new HashMap&lt;Byte, Integer&gt;(); for (byte b : bytes) { Integer count = counts.get(b); if (count == null) { counts.put(b, 1); }else { counts.put(b, count+1); } } //：把键值对转为NewNode对象，并放入ArrayList中 for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) { nodes.add(new NewNode(entry.getKey(), entry.getValue())); } return nodes; } 这样这个ArrayList中就存放了字符和他的权重了。 然后我们可以利用上面的方法来构造一颗胡夫曼树。 /** * 生成一个赫夫曼树 * @param nodes 由原始字节数组形成的集合 * @return 赫夫曼数的根节点 */ public static NewNode createHuffmanTree(ArrayList&lt;NewNode&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); NewNode leftNode = nodes.get(0); NewNode rightNode = nodes.get(1); NewNode parentNode = new NewNode(null, leftNode.getWeight() + rightNode.getWeight()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } return nodes.get(0); } 这样一颗赫夫曼树就构建好了，但是如何得到我们之前说的那个最优的前缀编码呢？？？ 很简单当我们从一个节点走向他的左节点的时候，我们为编码加上0，向右走的时候加上1，因为赫夫曼树中的所有的非叶子节点都是null，有意义的仅仅是叶子节点。叶子节点是没有子节点的，所有这样生成的赫夫曼编码就是一种前缀编码。而且他也是最优的前缀编码。 获取赫夫曼编码/** * 获取赫夫曼编码表 * @param node 赫夫曼树的根节点 * @param huffmanCodes 用来储存赫夫曼编码的map * @param code 左走是0 右走是1 * @param stringBuilder 用来连接0和1 */ public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); stringBuilder2.append(code); if (node != null) { if (node.getData() == null) { getCodes(node.getLeft(), huffmanCodes, &quot;0&quot;, stringBuilder2); getCodes(node.getRight(), huffmanCodes, &quot;1&quot;, stringBuilder2); }else { huffmanCodes.put(node.getData(), stringBuilder2.toString()); } } } 可以给这个方法一些默认的参数 public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes){ getCodes(node, huffmanCodes, &quot;&quot;, new StringBuilder()); } 这样我们就得到了赫夫曼编码表。得到了赫夫曼编码我们就可以对数据进行压缩了。 压缩字符串/** * 使用赫夫曼编码压缩字符数组的长度 * @param contentBytes 要进行压缩的字符数组 * @param huffmanCodes 传入一个哈希Map，传出的就是 对应的赫夫曼表Map。可用于之后的解压！ * @return 返回压缩后的字节数组 */ public static byte[] zip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { ArrayList&lt;NewNode&gt; nodes = HuffmanTree.getNodes(contentBytes); NewNode root = HuffmanTree.createHuffmanTree(nodes); HuffmanTree.getCodes(root, huffmanCodes); String codes = HuffmanTree.huffmanCodes(contentBytes, huffmanCodes); // System.out.println(codes); int len = (codes.length() + 7)/8; byte[] by = new byte[len]; for (int i = 0, index=0; i &lt; codes.length(); i+=8) { String strBytes; if (i+8 &gt; codes.length()) { strBytes = codes.substring(i); }else { strBytes = codes.substring(i, i+8); } by[index] = (byte) Integer.parseInt(strBytes, 2); index++; } return by; } 上面的代码需要注意的是code（10100010011….)的长度不一定是8的倍数，最后的一个字符串可能是没有8位的，所以我们要进行一次判断。 至此，我们已经完成了压缩的所有的工作。进入主方法进行一次测试。 压缩前的长度：52 压缩后的长度：24 压缩率：53.84615384615385% 解压数据： java java java is good good but cpp cpp is best best 是否解压成功：true 赫夫曼编码表如下所示，可见确实是前缀编码。 {32=00, 97=010, 98=0110, 99=10101, 100=11100, 101=11101, 103=11110, 105=11111, 106=0111, 111=1011, 112=1100, 115=1101, 116=1000, 117=10100, 118=1001}生成的二进制补码如下所示，这个一看就比原来的少多了，毕竟这个字符中我估计加入了不少重复的字符。 01110101001010000111010100101000011101010010100011111110100111101011101111100001111010111011111000001101010010000010101110011000010101110011000011111110100011011101110110000001101110111011000解压字符串首先我们需要将一个byte转为一个二进制补码类型的字符串 /** * 将一个byte转为一个二进制的字符串 * @param flag 是不是最后一个不满8位的byte 看是否需要按位与来补位 true代表需要补高位， false代表不需要补高位 * @param b * @return 按补码返回的 正数的补码就是原码，负数的补码是反码+1 */ private static String byteToBitString(boolean flag, byte b) { int temp = b; if (flag) { temp |= 256;// 256: 1 0000 0000 } String str = Integer.toBinaryString(temp);//:返回二进制的补码 if(flag) { return str.substring(str.length()-8);//：只是取得后面的八位 }else { return str; } } 同样的，我们要考虑到最后几位的问题。还有补码的有关的操作我也在上面注释清楚了。 下面就可以来解压了 /** * 解压之前使用赫夫曼编码的数据 * @param contentBytes 压缩之后的字节流 * @param huffmanCodes 之前压缩的时候使用的赫夫曼编码map * @return 解压之后的字节数组 */ public static byte[] unzip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; contentBytes.length; i++) { byte b = contentBytes[i]; boolean flag = (i != contentBytes.length-1); stringBuilder.append(byteToBitString(flag, b)); } // System.out.println(stringBuilder.toString()); HashMap&lt;String, Byte&gt; reverseMap = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte, String&gt; val : huffmanCodes.entrySet()) { reverseMap.put(val.getValue(), val.getKey()); } int i=0; int count = 1; ArrayList&lt;Byte&gt; arrayList = new ArrayList&lt;Byte&gt;(); while (i &lt; stringBuilder.length() &amp;&amp; i+count&lt;=stringBuilder.length()) { Byte b = null ; while (i+count &lt;= stringBuilder.length()) { String str = stringBuilder.substring(i, i+count); b = reverseMap.get(str); if (b == null) { count++; }else { i += count; count = 1; break; } } arrayList.add(b); } byte[] resultBytes = new byte[arrayList.size()]; for (int j = 0; j &lt; resultBytes.length; j++) { if (arrayList.get(j) == null) { break; } resultBytes[j] = arrayList.get(j); } return resultBytes; } 上面将赫夫曼编码进行了对调键值，这样更有利于后面的解压。通过扫描的方式逐个进行配对。 至此，压缩和解压字符串的操作就都已经完成了。。。 等等，，不是将压缩和解压文件的吗，怎么只讲了字符串？？？ 其实刚才我们处理时并不是字符串，而是一个byte[]数组，我们只是把字符串转为了一个byte[]数组进行处理了。而任何文件都是以字节进行储存的，所以说这个解压和压缩的方法不仅适用于这个字符串还适用于各种各样的文件。如文本文件，视频，图片等，不过压缩的效率怎么样就不能保证了。只能说重复的越多，压缩的效率越高。对于文件的处理就是简单的加上Java当中IO流罢了。 直接上代码吧。 /** * 使用赫夫曼编码来压缩文件 * @param srcFile 要压缩的文件的原地址 * @param dstFile 压缩后的文件的地址 */ public static void zipFile(String srcFile, String dstFile) { FileInputStream is = null; FileOutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); byte[] b = new byte[is.available()]; is.read(b); HashMap&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); byte[] zipcontent = zip(b, huffmanCodes); // System.out.println(huffmanCodes); // System.out.println(new String(zipcontent).substring(1,10)); os = new FileOutputStream(dstFile); oos = new ObjectOutputStream(os); //：以对象流的形式写入， 方便之后的解码 oos.writeObject(zipcontent); oos.writeObject(huffmanCodes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { is.close(); os.close(); oos.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 需要注意的是：使用ObjecOutpuStream使用对象流的方式将对象写入文件中,利于后面解压的时候提取数据。注意：赫夫曼编码表需要写入到文件中,不然就没办法解压了！ /** * 使用赫夫曼编码来解压文件 * @param srcFile 需要解压的文件地址 * @param dstFile 解压后的文件地址 */ @SuppressWarnings(&quot;unchecked&quot;) public static void unzipFile(String srcFile, String dstFile) { FileInputStream is = null; ObjectInputStream ois = null; FileOutputStream os = null; try { is = new FileInputStream(srcFile); ois = new ObjectInputStream(is); byte[] zipBytes = (byte[]) ois.readObject(); HashMap&lt;Byte, String&gt; huffmanCodes = (HashMap&lt;Byte, String&gt;) ois.readObject(); // System.out.println(huffmanCodes); // System.out.println(new String(zipBytes).substring(1,10)); byte[] unzipBytes = unzip(zipBytes, huffmanCodes); os = new FileOutputStream(dstFile); os.write(unzipBytes); } catch (Exception e) { System.out.println(e.getMessage()); e.printStackTrace(); // System.out.println(e.getStackTrace()); } finally { try { if (is!=null) { is.close(); } if (ois!=null) { ois.close(); } if (os!=null) { os.close(); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 小结总的来说，上面所提供的压缩和解压文件的方式还是非常简陋的，不过还是足以让我们来了解压缩文件的本质是什么。所谓的zip 7z rar无损压缩都是采用的这个思路，利用重复！如果没用大量的重复，而是杂乱无规则的话，就是神仙来了都压缩不了1kb… ​ ———— Hony Sher 7/17/2019]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown的基本使用]]></title>
    <url>%2F2019%2F07%2F17%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown的基本语法MarkDown的基本介绍之前写笔记什么的基本上用的都是win10电脑上自带的oneNote 来写笔记的，总有点感觉写的没用那种程序员味，比起用 word 来说也好像差不了多少。 之后通过一个Up主了解到了 markdown这种语言，才明白原来程序员也用自己写笔记的专门的语言，hiahiahia。 *Markdown和HTML** 是兼容的，但是*markdown 要html的语法简单的多。下面就花几分钟的时间来熟悉一下Markdown这门语言。这里我使用的markdown编辑器是 vscode和typora，这两个编辑器都蛮好用的。 标题感觉这个标题就是最简单的了。标题和html一样分为7个大小 h1标题就是#， h2就是##，以此类催，没多加一个#标题就会变小一号。但是有要注意的是 打完#之后需要打一个空格才行，不然不会被markdown解析为标题。 # 这是一级标题 ## 这是二级标题 ... 上面我的那个标题用的是 ### 标题字体加粗语法：**加粗**; 我被加粗啦！ 斜体语法：*斜体* 我怎么斜了？？？ 删除线语法：~~删除线~~ 我不要被划线!，嘤嘤嘤 斜体加粗语法： ***斜体加粗** 就是这么强大的我！ 引用语法：&gt; &gt;&gt; &gt;&gt;&gt; 引用&gt; 再来一个&gt; 直接两个&gt; 这玩意好像真的没什么用。。 分割线语法：--- *** 三个或者三个以上的-和*都可以代表一个分割线，效果是一样的 图片语法：![图片的说明](图片的地址 &quot;移动到图片处显示&quot;) 这个图片着实令我有些头疼， 因为好像本地的图片不能弄到博客上面去。这里就去找一些网络图片吧。 ![来自我github上的一张图片](https://raw.githubusercontent.com/sheriby/cdn/master/img/custom/head.jpg ”我的头像“)超链接语法[超链接的文字](超链接的地址 &quot;超链接的说明&quot;) [我的博客](https://sheriby.github.io) 我的博客 列表无序列表语法：- + * 任意一种都可以, 注意都要有空格 - 列表内容 + 列表内容 * 列表内容 列表内容 列表内容 列表内容 有序列表语法：1. 2. 3. 数字加上点就行了 1. 列表内容 2. 列表内容 3. 列表内容 列表内容 列表内容 列表内容 多重的列表进行嵌套的时候加上三个空格就行了 内容 内容 内容 内容 内容 内容 内容 内容 表格表格的语法比较复杂一点，但是也容易理解和记忆 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码这个应该是最有用的了，虽然上面一直都在用但是现在才说。 语法 用``引入的内容就是代码。。。虽然可能并不是代码使用三个成对的```可以引入多行的代码，也可以在代码块中规定语言，有对应的语法高亮。 template &lt;typename T, typename U&gt; auto add(const T&amp; t, const U&amp; u) -&gt;decltype(t+u){ return t+u; } 结语基本上就上面的这些内容了，所以说蛮简单的，似乎五分钟都不需要就可以上手了。 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个博客 HelloWorld]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2HelloWorld%2F</url>
    <content type="text"><![CDATA[第一个博客 HelloWordpythonprint(&quot;Hello World!&quot;) c++#include &lt;iostream&gt; int main(){ std::cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;std::endl; return 0; } javapublic class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;Hello World!&quot;)； } } 友情链接Learn from codeSheep]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
