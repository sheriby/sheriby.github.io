<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO应用——文件分割]]></title>
    <url>%2F2019%2F09%2F27%2FIO%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[IO应用——文件分割介绍很多下载软件下载的速度飞快是因为使用了多线程下载（至于多线程的知识，后面还是会学习的），将文件分割成不同的小块，然后不同的小块同时下载，最后再将这些小块的文件进行合并，这样下载就完成了，这样可以显著的提高下载的速度。这里我们显然不是做一个这样的下载器，而是做其中的一部分，将文件分割成许多小块，然后再将这些小文件合并。 思路其实之前没有看过任何人的思路或者写法，我就自己就我之前学过的IO流的知识来实现这个功能。其实说简单也不简单。能用就行其实确实是可以用，不过代码中的漏洞或者交互性应该是很差的。 我的代码public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; try { File file = new File(src); fis = new FileInputStream(file); byte[] buff = new byte[(int) file.length() / num + 1]; fis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest + a)); fos.write(buff); fos.flush(); a++; fis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; int a = 1; try { fos = new FileOutputStream(new File(dest)); while (a &lt;= num) { File file = new File(src + a); fis = new FileInputStream(file); fos.write(fis.readAllBytes()); a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/test.jpg&quot;, &quot;D:/dst&quot;, 10); merge(&quot;D:/dst&quot;,&quot;D:/merge.jpg&quot;,10); } } 这个思路故事是个人都会做。不过这个代码的问题也是非常的大的。在分割图片你的时候或许我们察觉不到分割后然后合并的文件和之前的文件有什么区别，但是分割文本文件额时候，不一样的地方就非常的明显了。我们可以轻易的发现，文本的最后会多出一点儿的内容，而且这一点儿的内容非常的奇怪，我也不清楚这一小块的内容是从哪儿来的。现在也非常的惆怅。我真的是喵了个咪了！ 为什么会出现最后多出了一部分你的内容呢？是因为我们没有考虑到最后一块的大小，一般来说最后一块的大小肯定是要比前面的几块都要小的，所以说在写入最后一块的时候不能再用前面的大小。 经过修改后的代码 如下所示 package com.sher.ioinjava; import java.io.*; /** * @author SHeR * @time 9/27/2019 8:36 PM * @describe */ public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; try { File file = new File(src); if (!file.isFile()) { throw new IllegalArgumentException(&quot;Src must be a file&quot;); } File dst = new File(dest); if (!dst.exists()){ if (!dst.mkdir()){ return; } } fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[(int) file.length() / num + 1]; int cot = bis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest +&quot;/&quot;+ a)); bos = new BufferedOutputStream(fos); bos.write(buff, 0, cot); bos.flush(); a++; cot = bis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[1024]; int cot = -1; while ((cot = bis.read(buff))!=-1){ bos.write(buff, 0, cot); } a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/SimpleInput.java&quot;, &quot;D:/dst&quot;, 3); merge(&quot;D:/dst&quot;,&quot;D:/hello.java&quot;); } } 经过我的测试，上面的代码基本上是没什么错误的地方了。那么这个题目我们就算是完成了。思路大概就是分割的时候一个输入流多个输出流，合并的时候一个输出流多个输入流。 不过这个代码并不能说是很完善的，我们看一下别人写的代码。 package com.sher.ioinjava; import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.Vector; /** * @author SHeR * @time 9/28/2019 11:30 AM * @describe */ public class SplitFile { //源头 private File src; //目的地(文件夹) private String destDir; //所有分割后的文件存储路径 private List&lt;String&gt; destPaths; //每块大小 private int blockSize; //块数: 多少块 private int size; public SplitFile(String srcPath,String destDir) { this(srcPath,destDir,1024); } public SplitFile(String srcPath,String destDir,int blockSize) { this.src =new File(srcPath); this.destDir =destDir; this.blockSize =blockSize; this.destPaths =new ArrayList&lt;String&gt;(); //初始化 init(); } //初始化 private void init() { //总长度 long len = this.src.length(); //块数: 多少块 this.size =(int) Math.ceil(len*1.0/blockSize); //路径 for(int i=0;i&lt;size;i++) { this.destPaths.add(this.destDir +&quot;/&quot;+i+&quot;-&quot;+this.src.getName()); } } /** * 分割 * 1、计算每一块的起始位置及大小 * 2、分割 * @throws IOException */ public void split() throws IOException { //总长度 long len = src.length(); //起始位置和实际大小 int beginPos = 0; int actualSize = (int)(blockSize&gt;len?len:blockSize); for(int i=0;i&lt;size;i++) { beginPos = i*blockSize; if(i==size-1) { //最后一块 actualSize = (int)len; }else { actualSize = blockSize; len -=actualSize; //剩余量 } splitDetail(i,beginPos,actualSize); } } /** * 指定第i块的起始位置 和实际长度 * @param i * @param beginPos * @param actualSize * @throws IOException */ private void splitDetail(int i,int beginPos,int actualSize ) throws IOException { RandomAccessFile raf =new RandomAccessFile(this.src,&quot;r&quot;); RandomAccessFile raf2 =new RandomAccessFile(this.destPaths.get(i),&quot;rw&quot;); //随机读取 raf.seek(beginPos); //读取 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=raf.read(flush))!=-1) { if(actualSize&gt;len) { //获取本次读取的所有内容 raf2.write(flush, 0, len); actualSize -=len; }else { raf2.write(flush, 0, actualSize); break; } } raf2.close(); raf.close(); } /** * 文件的合并 * @throws IOException */ public void merge(String destPath) throws IOException { //输出流 OutputStream os =new BufferedOutputStream( new FileOutputStream(destPath,true)); Vector&lt;InputStream&gt; vi=new Vector&lt;InputStream&gt;(); SequenceInputStream sis =null; //输入流 for(int i=0;i&lt;destPaths.size();i++) { vi.add(new BufferedInputStream(new FileInputStream(destPaths.get(i)))); } sis =new SequenceInputStream(vi.elements()); //拷贝 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=sis.read(flush))!=-1) { os.write(flush,0,len); //分段写出 } os.flush(); sis.close(); os.close(); } public static void main(String[] args) throws IOException { SplitFile sf = new SplitFile(&quot;Exercise/src/SimpleInput.java&quot;,&quot;dest&quot;) ; sf.split(); sf.merge(&quot;aaa.java&quot;); } } 里面使用了两个新的流RandomAccessFile和SequenceInputStream。我们可以稍微学习一下这个流，然后对我们直接的代码进行一些改进。 不过我发现使用上面的第一个类好像更加的繁琐，而且我完全没有必须去随机读取，所有说使用上面的第一个流就是没事找事干的。而上面的第二个流是将多个输入流合成一个输入流，使用后面操作更加的简单，我感觉这个功能还是稍微可以的。所以说这个可以有！ 原来的分割文件的代码我没有进行修改，合并文件的方法我使用了SequenceInputStream进行了修改。修改后代码如下所示： public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; SequenceInputStream sinput = null; Vector&lt;InputStream&gt; vector = new Vector&lt;&gt;(); int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); vector.add(bis); a++; } sinput = new SequenceInputStream(vector.elements()); int cot = -1; byte[] buff = new byte[1024]; while ((cot = sinput.read(buff))!=-1){ bos.write(buff, 0, cot); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } if (sinput != null) { sinput.close(); } } catch (IOException e) { e.printStackTrace(); } } } 其实修改的地方并不多，只是将多个输入流整合成一个输入流了而已。 总结上面的虽然是一个简单的应用，不过也会出不少的细节上面的小问题。所以说，解决了这个问题，对我们对IO的理解还是有一定的帮助的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons IO简介]]></title>
    <url>%2F2019%2F09%2F26%2FApache%20Commons%20IO%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Apache Commons IO简介 之前一直学的都是Java中IO的知识，使用起来基本上都是那个一个样，说实话我确实是有点儿感到厌倦了。于是世界上著名的开源组织阿帕奇(Apache)将Java中的IO进行了封装写了Commons IO这个玩意。这个是需要从阿帕奇的光网上面去下载的，因为这个并不是jdk自带的库。下载完之后还自带了源码以及官方文档，不过都是英文的，，这就非常考验我的能力了。 先看一下这个Commons IO 由哪些东西组成。 org.apache.commons.io // This package defines utility classes for working with streams, readers, writers and files. org.apache.commons.io.comparator // This package provides various Comparator implementations for Files. org.apache.commons.io.filefilter // This package defines an interface (IOFileFilter) that combines both FileFilter and FilenameFilter. org.apache.commons.io.input // This package provides implementations of input classes, such as InputStream and Reader. org.apache.commons.io.monitor // This package provides a component for monitoring file system events (directory and file create, update and delete events). org.apache.commons.io.output // This package provides implementations of output classes, such as OutputStream and Writer. org.apache.commons.io.serialization // This package provides a framework for controlling the deserialization of classes. 上面的这所只言片语，说实话我是什么都看不懂的，如果不是对Commons IO的体系有足够的了解，是肯定看不懂的。就像给我们一开始看那个Java io的体系图，我们也肯定是看的一脸懵逼的吖~~ 而且上面的并不是一些类而已，只是一些包，每个包中还有非常多的类，每个类中又有非常多的方法。所以说不可能一个一个去学习的，只能寻找自己需要的去学，这里就看一下别人的博客,毕竟我对这个玩意是一点也不了解。 Apache Commons IO入门教程 这个博客写了一点，但是我感觉写的并不怎么样，看了也没什么收获。下面我就直接上一些这个类的常用方法的代码吧。 文件或者文件夹的大小public class TestCommonIo { public static void main(String[] args) { long len1 = FileUtils.sizeOf(new File(&quot;test&quot;)); long len2 = FileUtils.sizeOf(new File(&quot;./Exercise/src&quot;)); System.out.println(len1); System.out.println(len2); } } 上面的第一个就是文件的大小，第二个是文件夹的大小，使用的方法是一样的。对于计算一个文件的大小，这还是非常简单的，使用length()方法就可以了，不过计算文件夹的代码确实要进行递归的操作，可以说要考虑的东西很多，而且也很繁琐。 我们可以看一下这个方法的源码 public static long sizeOf(final File file) { if (!file.exists()) { final String message = file + &quot; does not exist&quot;; throw new IllegalArgumentException(message); } if (file.isDirectory()) { return sizeOfDirectory0(file); // private method; expects directory } else { return file.length(); } } 可以看到源码中专门写了一个函数来计算文件夹的大小 private static long sizeOfDirectory0(final File directory) { final File[] files = directory.listFiles(); if (files == null) { // null if security restricted return 0L; } long size = 0; for (final File file : files) { try { if (!isSymlink(file)) { size += sizeOf0(file); // internal method if (size &lt; 0) { break; } } } catch (final IOException ioe) { // Ignore exceptions caught when asking if a File is a symlink. } } return size; } private static long sizeOf0(final File file) { if (file.isDirectory()) { return sizeOfDirectory0(file); } else { return file.length(); // will be 0 if file does not exist } } 简单的看一下确实也是使用递归的方法来计算文件夹的大小的。 列出文件static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, null); for (File file : files) { System.out.println(file.getName()); } } listFiles函数的第一个参数是待列的文件夹，第二个参数是文件过滤器（这里使用的是非空过滤器），第三个参数是文件夹过滤器（使用null就是表示不列出文件夹） static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 使用这个方法就可以列出所有的文件，包括文件夹以及文件夹里面的内容。还有一种常用的文件过滤器是后缀名过滤。比如说我只想要后缀为Java的非空的文件，可以这样写。 static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), FileFilterUtils.and(new SuffixFileFilter(&quot;java&quot;), EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 可以使用FileFilterUtils.and,FileFilterUtils.or或者FileFilterUtils.or来组织过滤器之间的逻辑，比如上面的就是以java为后缀名的并且非空的文件。 读取内容static void test3() { try { String msg = FileUtils.readFileToString(new File(&quot;hony&quot;), StandardCharsets.UTF_8); System.out.println(msg); byte[] b = FileUtils.readFileToByteArray(new File(&quot;hony&quot;)); System.out.println(new String(b, StandardCharsets.UTF_8)); List&lt;String&gt; lines = FileUtils.readLines(new File(&quot;hony&quot;), StandardCharsets.UTF_8); for (String line : lines) { System.out.println(line); } LineIterator lineIterator = FileUtils.lineIterator(new File(&quot;hony&quot;), &quot;UTF-8&quot;); while (lineIterator.hasNext()) { System.out.println(lineIterator.nextLine()); } } catch (IOException e) { e.printStackTrace(); } } 读取文件中的内容主要有上面的四种方式，无论哪一种都是比我们使用原始的Java IO流方便多了。 第一种是直接将文件中的内容读取到一个String对象中。第二种则是读取到字节数组中。 第三种是将文件的每一行都放入到一个List中。第四种方式倒是有点儿特殊，是使用迭代器的方式进行遍历文件的。 写出内容static void test4() { try { FileUtils.write(new File(&quot;happy.txt&quot;), &quot;I am happy1!&quot;, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;happy.txt&quot;), &quot;I am happy2!&quot;, StandardCharsets.UTF_8, true); FileUtils.writeByteArrayToFile(new File(&quot;happy.txt&quot;), &quot;I am happy3!&quot;.getBytes(StandardCharsets.UTF_8), true); List&lt;String&gt; datas = new ArrayList&lt;&gt;(); datas.add(&quot;sher&quot;); datas.add(&quot;hony&quot;); datas.add(&quot;sherhony&quot;); FileUtils.writeLines(new File(&quot;happy.txt&quot;), datas, &quot;\r\n&quot;, true); } catch (IOException e) { e.printStackTrace(); } } 写出到文件中同样有以上的好几种方式。上面函数的第四个参数都是代表是否一追加的形式写入到文件当中，在Java原始流当中也是使用的这种方式。不过下面的FileUtils.writeLines方法的第三个参数不再是编码了，而是分隔符，也就是说写入的这些data之间用什么隔开，这里我是用的是windows下的换行符。 拷贝拷贝包括拷贝文件或者说的是拷贝文件夹，拷贝文件的操作我们已经做过了，但是拷贝文件夹的操作是有点儿复杂，需要递归的操作。不过这个commons io提供给我们一个十分方便地方法。 static void test5() { try { FileUtils.copyFile(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;Exercise/src/test-copy.jpg&quot;)); FileUtils.copyFileToDirectory(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;D:/&quot;)); FileUtils.copyDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/out-copy&quot;)); FileUtils.copyDirectoryToDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/src&quot;)); String url = &quot;http://i1.hdslb.com/bfs/archive/9cc5e3fcc7d6c48e5a0d8d3dd8bbb6ed11937f89.jpg&quot;; FileUtils.copyURLToFile(new URL(url), new File(&quot;Exercise/src/miaonei.jpg&quot;)); String baidu = &quot;http://www.baidu.com&quot;; String wangyi = &quot;http://www.163.com&quot;; String bd = IOUtils.toString(new URL(baidu), StandardCharsets.UTF_8); String wy = IOUtils.toString(new URL(wangyi), &quot;GBK&quot;); FileUtils.writeStringToFile(new File(&quot;Exercise/src/baidu.txt&quot;), bd, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;Exercise/src/wangyi.txt&quot;), wy, &quot;GBK&quot;); } catch (IOException e) { e.printStackTrace(); } } 上面是拷贝的常见的操作。可以看到这个方法是什么的方便的。不过需要注意的是，从网络流中拷贝东西（也就是下载东西）的时候，如果是文字的话（也就网页的代码），可以使用IOUtils.toString方法，这个方法可以指定字符的编码。 总结上面就是Commons IO中简单的常用的一些操作，不过Commons IO这么强大的库怎么可能就这么一点点功能，只不过其余的功能太过与强大，而且并不是经常用到，所以现在可以不用了解。现在就是简单的看看这个类，知道有这么个玩意就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-06]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E4%B8%AD%E7%9A%84IO-06%2F</url>
    <content type="text"><![CDATA[Java 中的IO-06回顾其实之前我们已经学过了Java IO中的主要的一些流，剩下来的流基本上都是一个套路没有必要一个一个再去研讨。下面是Java IO中的一个体系图。 Java IO中主要分为了四大抽象类，然后各种流都是继承于这些抽象类，实现这些抽象类的方法。下面的图中有的是我每次学过的，有的是我们没看过的，有的还是Java中已经废弃了的，不过其实我们也完全没有必要按照这个图再去将其余的流再去学习一次，我们学习java IO其实是学习的Java IO 的思路。即使我们遇到一个陌生的流，我们也完全可以应付的来。 回到Hello World我们对IO流的学习其实是源于Hello world的输出，当时我们不知道，现在我们知道了System.out其实就是一个流对象，调用println()方法就是向控制台中输出信息。而当我们想要获取键盘的输入的时候我们使用的是System.in这个流，一般情况下，我们使用的方式是 Scanner in = new Scanner(System.in); String str = in.next(); int num = in.nextInt(); 这个Scanner就是Java为了方便我们处理键盘的输入而产生的类。不过我们也可以使用我们之前的方式读取键盘的输入。 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String s = bufferedReader.readLine(); int a = Integer.parseInt(bufferedReader.readLine()); System.out.println(s + a); 不过可以清晰的看到这个方法是有一点儿烦的，所以说使用Scanner在读取控制台的输入还是非常的方便而且简单的。 不过这个Scanner并不是只可以读取控制的输入的，也可以读取文件。只要是流都是可以读取的。更好的是这个类有hasNext等一系列的方法，所以说上面的scanner代码可以修改一下。 Scanner in = new Scanner(System.in); if (in.hasNext()){ String str = in.next(); } if (in.hasNextInt){ int num = in.nextInt(); } 下面来演示一下使用Scanner来读取文件的操作，其实是一样的，文件流和控制台的标准流都是流。 private static void scannerReadFile() { // Use Scanner to read file! final String path = &quot;C:/Users/SHeR/IdeaProjects/Exercise/src/com/sher/corejava/hello/file.txt&quot;; Scanner scanner = null; try { scanner = new Scanner(Path.of(path), StandardCharsets.UTF_8); while (scanner.hasNextLine()) { System.out.println(scanner.nextLine()); } } catch (IOException e) { e.printStackTrace(); } finally { if (scanner != null) { scanner.close(); } } } System.in是一个OnputStream，但是System.out并不是OutputStream而是一个叫PrintWriter的玩意，这就是很好奇了。现在我们来看一看这个PrintWriter是一个什么玩意。 PrintWriter看到这个类是以Writer结尾的，我们立马就知道了，这是一个字符流。不过也对，我们想控制台输入的肯定是字符啊。输入字节我们也是看不懂的，这是没必要的。先观察一下这个类的官方文档再说。 java.lang.Object java.io.Writer java.io.PrintWriter public class PrintWriter extends Writer 将对象的格式表示打印到文本输出流。这个类实现了全部在发现print种方法PrintStream 。它不包含用于编写原始字节的方法，程序应使用未编码的字节流。 不像PrintStream类，如果启用自动刷新，它只会在调用的println，printf，或format方法来完成，而不是当一个换行符恰好是输出。 这些方法使用平台自己的行分隔符而不是换行符。 这个类中的方法不会抛出I / O异常，尽管它的一些构造函数可能。 客户可以通过调用checkError()查询是否发生错误。 PrintWriter(File file) // 使用指定的文件创建一个新的PrintWriter，而不需要自动的线路刷新。 PrintWriter(File file, String csn) // 使用指定的文件和字符集创建一个新的PrintWriter，而不需要自动进行线条刷新。 PrintWriter(OutputStream out) // 从现有的OutputStream创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(OutputStream out, boolean autoFlush) // 从现有的OutputStream创建一个新的PrintWriter。 PrintWriter(String fileName) // 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新。 PrintWriter(String fileName, String csn) // 使用指定的文件名和字符集创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(Writer out) // 创建一个新的PrintWriter，没有自动线冲洗。 PrintWriter(Writer out, boolean autoFlush) //创建一个新的PrintWriter。 PrintWriter append(char c) // 将指定的字符附加到此作者。 PrintWriter append(CharSequence csq) // 将指定的字符序列附加到此作者。 PrintWriter append(CharSequence csq, int start, int end) // 将指定字符序列的子序列附加到此作者。 boolean checkError() // 如果流未关闭，请刷新流并检查其错误状态。 protected void clearError() // 清除此流的错误状态。 void close() // 关闭流并释放与之相关联的任何系统资源。 void flush() // 刷新流。 PrintWriter format(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 PrintWriter format(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 void print(boolean b) // 打印布尔值。 void print(char c) // 打印一个字符 void print(char[] s) // 打印字符数组。 void print(double d) // 打印双精度浮点数。 void print(float f) // 打印浮点数。 void print(int i) // 打印一个整数。 void print(long l) // 打印一个长整数。 void print(Object obj) // 打印一个对象。 void print(String s) // 打印字符串。 PrintWriter printf(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 PrintWriter printf(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 void println() // 通过写入行分隔符字符串来终止当前行。 void println(boolean x) // 打印一个布尔值，然后终止该行。 void println(char x) // 打印一个字符，然后终止该行。 void println(char[] x) // 打印字符数组，然后终止行。 void println(double x) // 打印双精度浮点数，然后终止行。 void println(float x) // 打印一个浮点数，然后终止该行。 void println(int x) // 打印一个整数，然后终止该行。 void println(long x) // 打印一个长整型，然后终止行。 void println(Object x) // 打印一个对象，然后终止该行。 void println(String x) // 打印一个字符串，然后终止行。 protected void setError() // 表示发生错误。 void write(char[] buf) // 写入一个字符数组。 void write(char[] buf, int off, int len) // 写一个字符数组的一部分。 void write(int c) // 写一个字符 void write(String s) // 写一个字符串 void write(String s, int off, int len) // 写一个字符串的一部分。 可以看到这个类虽然方法很多，不过基本上都是重载的方法。也就是print,printf,println这三个方法。 下面来个代码来演示一下这个流的使用。 private static void printWriterFile() { PrintWriter printWriter = null; try { printWriter = new PrintWriter(&quot;Hello.txt&quot;, StandardCharsets.UTF_8); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world\nhello core java&quot;); } catch (IOException e) { e.printStackTrace(); } finally { if (printWriter != null) { printWriter.close(); } } } 从上面的构战函数可以得知，也可以从现有的OutputStream的基础上创建PrintWriter。所以上面的代码等价于 private static void printWriterFile() { FileOutputStream fileOutputStream = null; PrintWriter printWriter = null; try { fileOutputStream = new FileOutputStream(new File(&quot;hello.txt&quot;)); printWriter = new PrintWriter(fileOutputStream); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world&quot;); printWriter.println(&quot;hello hello&quot;); printWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileOutputStream != null) { fileOutputStream.close(); } if (printWriter != null) { printWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } 注意：上面代码的第十行代码是必须的，不然文件中不会产生任何的数据。其实每次输出都可以刷新一下缓冲的。 上面说了PrintWriter那么是否有PrintReader呢？答案是没有的，，，至于为什么，好好想想去伐。。。 总结到此为此，对IO的学习基本上已经结束了。下面的一个将会讲一讲Commons IO这个玩意，那时候也就是IO真正的结束了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-05]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-05%2F</url>
    <content type="text"><![CDATA[Java中的IO-05引言上一篇文章中我们谈及了字节数组流以及字符数组流，这些流虽然不常见，但是在一定时候却能发挥巨大的作用。这里我们要学习的不是和数组有关的了，而是和Java中的数据类型有关的流。众所周知，Java中的数据分为基本数据类型还有对象，那么我就从基本数据类型开始说起吧。 DataInputStream, DateOutputStream这两个流的使用方式也是非常简答的。简单的看看官方文档就行了。 java.lang.Object java.io.InputStream java.io.FilterInputStream java.io.DataInputStream public class DataInputStream extends FilterInputStream implements DataInput 数据输入流允许应用程序以独立于机器的方式从底层输入流读取原始Java数据类型。应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。 DataInputStream对于多线程访问来说不一定是安全的。 线程安全是可选的，是本课程中用户的责任。 DataInputStream(InputStream in) // 创建使用指定的底层InputStream的DataInputStream。 int read(byte[] b) // 从包含的输入流中读取一些字节数，并将它们存储到缓冲区数组 b 。 int read(byte[] b, int off, int len) // 从包含的输入流读取最多 len个字节的数据为字节数组。 boolean readBoolean() // 见的总承包 readBoolean的方法 DataInput 。 byte readByte() // 见的总承包 readByte的方法 DataInput 。 char readChar() // 见 readChar方法的总合同 DataInput 。 double readDouble() // 见 readDouble方法 DataInput的总体合同。 float readFloat() // 见 readFloat法 DataInput的一般合同。 void readFully(byte[] b) // 见的总承包 readFully的方法 DataInput 。 void readFully(byte[] b, int off, int len) // 见的总承包 readFully的方法 DataInput 。 int readInt() // 见 readInt方法 DataInput的一般合同。 String readLine() /*已弃用 此方法无法将字节正确转换为字符。 从JDK 1.1开始，读取文本行的BufferedReader.readLine()方法是通过BufferedReader.readLine()方法。 使用DataInputStream类读取行的程序可以转换为使用BufferedReader类替换以下形式的代码： DataInputStream d = new DataInputStream(in); 与： BufferedReader d = new BufferedReader(new InputStreamReader(in)); */ long readLong() // 见的总承包 readLong的方法 DataInput 。 short readShort() // 见 readShort方法 DataInput的一般合同。 int readUnsignedByte() // 见的总承包 readUnsignedByte的方法 DataInput 。 int readUnsignedShort() // 见 readUnsignedShort法 DataInput的一般合同。 String readUTF() // 见 readUTF法 DataInput的一般合同。 static String readUTF(DataInput in) // 从流in读取以modified UTF-8格式编码的Unicode字符串的表示; 这个字符串然后作为String返回。 int skipBytes(int n) // 见 skipBytes法 DataInput的一般合同。 这些方法倒也是非常容易理解的。下面直接给出代码举例吧。 代码举例public class DataStreamDemo { public static void main(String[] args) { DataOutputStream out = null; BufferedReader br = null; byte[] a= &quot;sheriby\nsheriby\nhonysher&quot;.getBytes(StandardCharsets.UTF_8); try { DataInputStream in = new DataInputStream(new ByteArrayInputStream(a)); out = new DataOutputStream(new FileOutputStream(&quot;./Exercise/src/sher2&quot;)); br = new BufferedReader(new InputStreamReader(in)); String line; while ((line = br.readLine()) != null) { String temp = line.toUpperCase(); out.writeChars(temp); out.writeChar(&#39;\n&#39;); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (out != null) { out.close(); } if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实上面的这个代码的示例并不是非常的典型，所谓的典型的用法其实是下面的这个用法。 public class DataStreamDemo2 { public static void main(String[] args) { DataOutputStream out = null; DataInputStream in = null; try { out = new DataOutputStream(new FileOutputStream(&quot;test&quot;)); out.writeInt(2); out.writeDouble(3.1415926); out.writeUTF(&quot;sher is the best boy!&quot;); out.writeBoolean(false); in = new DataInputStream(new FileInputStream(&quot;test&quot;)); System.out.println(in.readInt()); System.out.println(in.readDouble()); System.out.println(in.readInt()); System.out.println(in.readUTF()); System.out.println(in.readBoolean()); } catch (Exception e) { e.printStackTrace(); } finally { try { if (in != null) { in.close(); } if (out != null) { out.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 我们通过DataOutputStream将我们需要的数据按顺序写入到了文件当中，然后使用DataInputStream来读取文件中的基本类型的数据，不过需要注意的是我们读取时的顺序必须要和写入是的顺序是相同的，不然代码就会抛出一个异常。还要注意的是，此时那个文件test并不是一个可读的文件(是我们有点儿看不懂的文件)。比如 @ !�M�J sher is the best boy! 可以看到前面的数据都是不可读的，只有后面的是writeUTF()写入的是可读的，但是如果只是用writeUTF()方法的话也是会出现不可读的字符的，那是因为使用wrteUTF()方法会在前面的两个字节储存长度信息。 上面基本上就是这两个流的基本的用法了。 ObjectInputStream, ObjectOutputStream上面的流是进行基本数据类型的读写，下面要说的下Java当中最为重要的对象类型的读写流。用法与上面的基本数据类型流基本是类似的。不过也有一些需要注意的地方。下面就看一下ObjecOutputStream的官方文档吧。 java.lang.Object java.io.OutputStream java.io.ObjectOutputStream public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants 官方文档中对这个类的说明非常的长而且复杂，所以我们先看看构造器还有他的成员方法吧。 protected ObjectOutputStream() // 为完全重新实现ObjectOutputStream的子类提供一种方法，不必分配刚刚被ObjectOutputStream实现使用的私有数据。 ObjectOutputStream(OutputStream out) // 创建一个写入指定的OutputStream的ObjectOutputStream。 第一个构造方法是protected的，所以我们大可不必看这个玩意。 protected void annotateClass(类&lt;?&gt; cl) // 子类可以实现此方法，以允许类数据存储在流中。 protected void annotateProxyClass(类&lt;?&gt; cl) // 子类可以实现这种方法来存储流中的自定义数据以及动态代理类的描述符。 void close() // 关闭流。 void defaultWriteObject() // 将当前类的非静态和非瞬态字段写入此流。 protected void drain() // 排除ObjectOutputStream中的缓冲数据。 protected boolean enableReplaceObject(boolean enable) // 启用流来替换流中的对象。 void flush() // 刷新流。 ObjectOutputStream.PutField putFields() // 检索用于缓冲要写入流的持久性字段的对象。 protected Object replaceObject(Object obj) // 该方法将允许ObjectOutputStream的可信子类在序列化期间将一个对象替换为另一个对象。 void reset() // 复位将忽略已写入流的任何对象的状态。 void useProtocolVersion(int version) // 指定在编写流时使用的流协议版本。 void write(byte[] buf) // 写入一个字节数组。 void write(byte[] buf, int off, int len) // 写入一个子字节数组。 void write(int val) // 写一个字节。 void writeBoolean(boolean val) // 写一个布尔值。 void writeByte(int val) // 写入一个8位字节。 void writeBytes(String str) // 写一个字符串作为字节序列。 void writeChar(int val) // 写一个16位的字符。 void writeChars(String str) // 写一个字符串作为一系列的字符。 protected void writeClassDescriptor(ObjectStreamClass desc) // 将指定的类描述符写入ObjectOutputStream。 void writeDouble(double val) // 写一个64位的双倍。 void writeFields() // 将缓冲的字段写入流。 void writeFloat(float val) // 写一个32位浮点数。 void writeInt(int val) // 写一个32位int。 void writeLong(long val) // 写一个64位长 void writeObject(Object obj) // 将指定的对象写入ObjectOutputStream。 protected void writeObjectOverride(Object obj) // 子类使用的方法来覆盖默认的writeObject方法。 void writeShort(int val) // 写一个16位短。 protected void writeStreamHeader() // 提供了writeStreamHeader方法，因此子类可以在流中附加或预先添加自己的头。 void writeUnshared(Object obj) // 将“非共享”对象写入ObjectOutputStream。 void writeUTF(String str) // 此字符串的原始数据写入格式为 modified UTF-8 。 可以看到这个类的成员方法是非常多的，但是我们可以发现的是，这个类不仅仅是可以写入对象，也可以写入基本数据类型，甚至原始数组(原始数组其实也是一个对象)。DataStream的功能基本上都是被ObjectStream说涵盖了的。 下面就来看看官方文档对这个类的一些说明。 ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。 只有支持java.io.Serializable接口的对象才能写入流中。 每个可序列化对象的类被编码，包括类的类名和签名，对象的字段和数组的值以及从初始对象引用的任何其他对象的关闭。 方法writeObject用于将一个对象写入流中。 任何对象，包括字符串和数组，都是用writeObject编写的。 多个对象或原语可以写入流。 必须从对应的ObjectInputstream读取对象，其类型和写入次序相同。 原始数据类型也可以使用DataOutput中的适当方法写入流中。 字符串也可以使用writeUTF方法写入。 对象的默认序列化机制写入对象的类，类签名以及所有非瞬态和非静态字段的值。 引用其他对象（除了在瞬态或静态字段中）也会导致这些对象被写入。 使用引用共享机制对单个对象的多个引用进行编码，以便可以将对象的图形恢复为与原始文件相同的形状。 例如，要写一个ObjectInputStream中的示例可以读取的对象： FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeInt(12345); oos.writeObject(&quot;Today&quot;); oos.writeObject(new Date()); oos.close(); 在序列化和反序列化过程中需要特殊处理的类必须采用具有这些精确签名的特殊方法： private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException; private void writeObject(java.io.ObjectOutputStream stream) throws IOException private void readObjectNoData() throws ObjectStreamException; writeObject方法负责为其特定的类编写对象的状态，以便相应的readObject方法可以恢复它。 该方法不需要关心属于对象的超类或子类的状态。 通过使用writeObject方法或通过使用DataOutput支持的原始数据类型的方法将各个字段写入ObjectOutputStream来保存状态。 序列化不会写出任何不实现java.io.Serializable接口的对象的字段。 不可序列化的对象的子类可以是可序列化的。 在这种情况下，非可序列化类必须有一个无参数构造函数，以允许其字段被初始化。 在这种情况下，子类有责任保存并恢复不可序列化类的状态。 通常情况下，该类的字段是可访问的（public，package或protected），或者可以使用get和set方法来恢复状态。 可以通过实现抛出NotSerializableException的writeObject和readObject方法来防止对象的序列化。 异常将被ObjectOutputStream捕获并中止序列化过程。 实现Externalizable接口允许对象完全控制对象的序列化表单的内容和格式。 调用Externalizable接口writeExternal和readExternal的方法来保存和恢复对象的状态。 当由类实现时，他们可以使用ObjectOutput和ObjectInput的所有方法来写入和读取自己的状态。 对象处理发生的任何版本控制都是有责任的。 枚举常数与普通可序列化或外部化对象不同的是序列化。 枚举常数的序列化形式仅由其名称组成; 不传输常数的字段值。 要序列化一个枚举常量，ObjectOutputStream会写入常数名称方法返回的字符串。 像其他可序列化或可外部化的对象一样，枚举常量可以作为随后在序列化流中出现的反向引用的目标。 枚举常数序列化的过程无法定制; 在序列化期间，将忽略由枚举类型定义的任何类特定的writeObject和writeReplace方法。 类似地，任何serialPersistentFields或serialVersionUID字段声明也被忽略 - 所有枚举类型都有一个固定的serialVersionUID为0L。 原始数据（不包括可序列化字段和外部化数据）在块数据记录中写入ObjectOutputStream。 块数据记录由报头和数据组成。 块数据头由标记和跟随标题的字节数组成。 连续的原始数据写入被合并成一个块数据记录。 用于块数据记录的阻塞因子将是1024字节。 每个块数据记录将被填充到1024个字节，或者每当块数据模式终止时都被写入。 调用ObjectOutputStream方法writeObject，defaultWriteObject和writeFields最初终止任何现有的块数据记录。 第二点是非常重要的，只有支持java.io.Serializable接口的对象才能写入流中，如果没用实现这个接口，写入的时候会报错。至于什么叫Serializable呢。这个被称为是可序列化的。就是可以被写入到文件当中。要使类实现这个接口，这需要implement Serializable不需要实现任何的函数。也就是说这个接口这是起了一个标记的作用，其母的是告诉编译器这个类可以被序列化写入到文件当中去。不过如果有一些数据我们不想其被写入到文件当中去，我们就要加上transient关键词，表示这个属性不会被写入到文件中去。关于序列化还有一点要说的是，序列化不只是对象的一个简单的复制，和此对象有关的所有的有关的对象都会被写入到文件当中去，如果其中有不可序列化的对象也会报错。假如序列化只是写入链接，当我们反序列化的时候码举例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java Io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-04]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-04%2F</url>
    <content type="text"><![CDATA[Java中的IO-04回顾之前已经介绍过很多的IO流了。比如四大抽象流InputStream，OutputStream，Reader,Writer。前面的两个是字节流，后面的两个是字符流。所谓的字节流与字符流之间的最大的区别就是，字节流是写给计算机看的，而字符流写写给我们人看的。Java当中所有的IO流基本上都继承于这个四大抽象流，而且基本上都以他们结尾。之前还说过一个特殊的流OutputStreamWriter，InputStreamReader。这两个流却是有点儿特殊，他们的前面是字节流，后面却是字符流。之前我们说他是处理字符相关的流，不过实际上他是将字节流转换成字符流的特殊流。因而我们可以指定编码(字节流转换成为字符流的一种方式)来进行字节到字符的转换。如果我们要处理一些字符文件的话，之前学的FileReader，FileWriter无疑是一个最合适的选择。如果要是处理一些字节文件比如图片或者视频什么的，我们需要使用字节流FileInputStream，FileOutputStream。不过单独使用这些流的话，效率可能是一个问题。所以缓冲区是必须的，Java IO 中给我们提供了缓冲的包装流。BufferedInputStream,BufferedOutputStream,BufferedReader,BufferedWriter。这四个流是对前面的四个基本的抽象流的包装，如果不是什么特殊情况的话，我们可以每次都加上这个缓冲层。 ByteArrayInputStream, ByteArrayOutputStream字节流我们只是介绍了一种，也就是从文件中读取字节。不过并不是所有的情况下我们都要从文件中读取字节的。比如说我们获取一个字节数组，我们想使用流来处理一下这个字节数组，好像我们现在学过的流中没有这样的功能。 于是现在我们引入了处理数组的新的流，ByteArrayInputStream和 ByteArrayOutputStream。 下面就是我们正常的官方文档的学习环节。 java.lang.Object java.io.InputStream java.io.ByteArrayInputStream public class ByteArrayInputStream extends InputStream A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。 关闭ByteArrayInputStream没有任何效果。 在关闭流之后，可以调用此类中的方法，而不生成IOException 。 ByteArrayInputStream(byte[] buf) // 创建一个 ByteArrayInputStream ，使其使用 buf作为其缓冲区数组。 ByteArrayInputStream(byte[] buf, int offset, int length) // 创建 ByteArrayInputStream使用 buf作为其缓冲器阵列。 int available() // 返回可从此输入流读取（或跳过）的剩余字节数。 void close() // 关闭 ByteArrayInputStream没有任何效果。 void mark(int readAheadLimit) // 设置流中当前标记的位置。 boolean markSupported() // 测试 InputStream是否支持标记/复位。 int read() // 从该输入流读取下一个数据字节。 int read(byte[] b, int off, int len) // 将 len字节的数据读入此输入流中的字节数组。 void reset() // 将缓冲区重置为标记位置。 long skip(long n) // 从此输入流跳过 n个字节的输入。 其实上面的这些方法，和这些属性都是可以一眼就看懂的，和其他的流是没什么区别的。 看一下官方文档的第一点，我们可以知道使用ByteArrayInputStream内部有一个缓冲区，那是否可以使用BufferedInputStream来包装呢？这个肯定是可以用的，毕竟这个也是InputStream的子类吖。 第二点是关于这个流的关闭的，官方文档告诉我们，这个流的关闭是不会做任何事情的，也就是说我们可以选择不关闭。但是为了IO流中操作的有机的统一和规范。虽然关闭没有用，我们还是推荐来关闭一下子的。 代码举例public class ByteArrayInputStreamDemo { public static void main(String[] args) { byte[] b = &quot;sher is a wonderful boy!&quot;.getBytes(); ByteArrayInputStream bais = new ByteArrayInputStream(b); StringBuilder sb = new StringBuilder(); int temp = 0; while ((temp = bais.read()) != -1){ sb.append((char) temp); } System.out.println(sb.toString()); } } 其实上面的我的用法不没有是把这个作为一个IO流来使用，所以也没有使用IO流的try catch finally的标准操作。而且这个流也是不会抛出IOException的。 下面随便写一个有关ByteArrayOutputStream的代码举例 public class ByteArrayOutputStreamDemo { public static void main(String[] args) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); while (baos.size() &lt;= 10){ try { baos.write(System.in.read()); } catch (IOException e) { e.printStackTrace(); } } byte[] b = baos.toByteArray(); System.out.println(new String(b)); } } 这里也没有使用标准的IO流操作方式，毕竟这个流是有点儿特殊了。 CharArrayWriter, CharArrayReader和上面的字节数组类似的，字符流中也有相应的流是和字符数组相关的。其实他们之间的道理是一样的，这里就不再赘述了。 public class CharArrayWriterDemo { public static void main(String[] args) { char[] ch = &quot;sher is the best boy!&quot;.toCharArray(); CharArrayWriter c = new CharArrayWriter(); try { c.write(ch); c.flush(); } catch (IOException e) { e.printStackTrace(); } System.out.println(c.toString()); } } public class CharArrayReaderDemo { public static void main(String[] args) { char [] ch = &quot;abcdefg&quot;.toCharArray(); CharArrayReader char1 = new CharArrayReader(ch); StringBuilder sb = new StringBuilder(); int temp = 0; while (true){ try { if (((temp = char1.read()) == -1)) break; } catch (IOException e) { e.printStackTrace(); } sb.append((char)temp); } System.out.println(sb.toString()); } } 总结其实这些流都不是常见的流，基本上我们是用不到的。不过稍微做一下了解也是好的呢、]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-03]]></title>
    <url>%2F2019%2F09%2F24%2FJava%E4%B8%AD%E7%9A%84IO-03%2F</url>
    <content type="text"><![CDATA[Java中的IO-03缓冲流BufferedReader和BufferedWriter在之前我们讲OutputStreamWriter中，官网文档给了我们三个建议。其中第二条是我们有点儿看不懂的。现在我们再来看一遍试试看。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。 例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 为了提高更高的效率，我们要用一个包装类BufferedWriter，减少频繁调用转换器。这个到底是什么意思呢？众所周知，buffer是缓冲区的意思，那么这个BufferedWriter的作用大概率就是给OutputStreamWriter添加了一个缓冲的地方。 我们来看一下原来的OutputStreamWriter的代码。 public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, &quot;GBK&quot;); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个是如何写入的呢？里面好像只有那一行的代码。。。osw.write(content)，这个我们怎么看写入的方式呢？我们可以再来看一看OutputStreamReader的代码。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个读取的过程就看的非常的清晰了，每次我们都读取了一个字符，然后判断是否为空，然后输入那一个字符。也就是说读取和输出之间没有缓冲区。其实我们可以每次读取1024（比如）个字符，然后一次性写入。然后再去读取1024个字符。这个buffer数组其实就是所谓的缓冲区。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int cot; byte[] buffer = new byte[1024]; // 缓冲区 while ((cot = is.read(buffer)) != -1){ System.out.println(new String(buffer, 0, cot)); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面只是我们简单的实现了一个缓冲的原理。Java IO中专门给我提供了这样的包装类（所谓的包装类就是设计模式中的装饰模式，简单的说就是给原有的类添加一些新的功能）。就是BufferedXXX，后面的XXX就是指的就是我们之前学过的Reader, Writer和InputStream和OutputStream这些流。 下面来看一下官方的文档是怎么说的。 public class BufferedReader extends Reader 从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取。 可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途。 通常，由读取器做出的每个读取请求将引起对底层字符或字节流的相应读取请求。 因此，建议将BufferedReader包装在其read（）操作可能昂贵的读取器上，例如FileReaders和InputStreamReaders。 例如， BufferedReader in = new BufferedReader(new FileReader(&quot;foo.in&quot;)); 将缓冲指定文件的输入。没有缓冲，每次调用read（）或readLine（）可能会导致从文件中读取字节，转换成字符，然后返回，这可能非常低效。 使用DataInputStreams进行文本输入的程序可以通过用适当的BufferedReader替换每个DataInputStream进行本地化。 看一下他的构造函数。 BufferedReader(Reader in) // 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) // 创建使用指定大小的输入缓冲区的缓冲字符输入流。 非常的简单，他是一个包装流，就是为了来包装Reader这个类的子类的，其中我们可以使用第二个参数来指定缓冲区的大小，不过也看了上面的说明其实一般情况是我们是不用指定的。 下面该看的就是这个类的方法了。其实这个流对象的各种方法我们基本都已经熟悉了。不过这个BufferedReader有一个我最喜欢的方法，那就是readLine()方法。 public String readLine() throws IOException 读一行文字。 一行被视为由换行符（&#39;\ n&#39;），回车符（&#39;\ r&#39;）中的任何一个或随后的换行符终止。 结果 包含行的内容的字符串，不包括任何行终止字符，如果已达到流的末尾，则为null 异常 IOException - 如果发生I / O错误 另请参见： Files.readAllLines(java.nio.file.Path, java.nio.charset.Charset) 一次就可以读一行了，这个方法不要太方便哦~~ 下面随便写一个代码来展示一下这个类。 public class BufferedReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(file)); String line; while ((line = bufferedReader.readLine()) != null){ System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { if (bufferedReader != null){ try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 可见看到，这里我没有将FileReader这个类放在外面，也没有在finally中将其关闭，那是因为在我们关闭BufferedReader的时候其实也就是关闭了FileReader，之前说了BufferedReader是他的包装流，其实包装的就是FileWriter，底层也是FileWriter，所谓的BufferedReader其实也不是流，只是一个壳子而已。这就是为啥叫他包装流或者说装饰流。 下面就是BufferedWriter了，其实具体的用法都是相似的。 public class BufferedWriterDemo { public static void main(String[] args) { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(&quot;./Exercise/src/buf.txt&quot;)); String content = &quot;hello World&quot;; writer.write(content); writer.newLine(); writer.write(content); writer.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 可以看到BufferedWriter多了一个方法。newLine()。在linux和windows当中换行的符号是不一样的。windows中的换行是\r\n，而在linux中的换行的符号是\n。其中\r的意思是回到行首。所以说使用newLine()这个方法来换行个不错的选择。 BufferedInputStream和BufferedOutputStream上面讲过了BufferedReader, BufferedWriter了，下面的这两个也是包装流，其实就可以一带而过了。 public class BufferedInputStreamDemo { public static void main(String[] args) { BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try { bufferedInputStream = new BufferedInputStream( new FileInputStream(&quot;./Exercise/src/test.jpg&quot;)); byte[] b = bufferedInputStream.readAllBytes(); bufferedOutputStream = new BufferedOutputStream( new FileOutputStream(&quot;./Exercise/src/testCopy.jpg&quot;)); bufferedOutputStream.write(b); bufferedOutputStream.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (bufferedInputStream != null){ bufferedInputStream.close(); } if (bufferedOutputStream != null){ bufferedOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实从上面可以看出，用法和之前是完全相同的，使用Buffered之后，只是增加了一个所谓的缓冲区，是流的输入和输出变得更加快呢，而且BufferedReader还提供了readLine()这种神级的方法，所以说，Buffered这种东西，不是啥特殊情况的话，最后在使用流的时候都加上吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的IO-02]]></title>
    <url>%2F2019%2F09%2F23%2FJava%E4%B8%AD%E7%9A%84IO-02%2F</url>
    <content type="text"><![CDATA[Java中的IO-02FileInputStream与FileOutputStream对字节文件的操作根据官方文档的说法，FileInputStream和FileOutputStream这两个流主要是对图像，视频等原始字节流进行操作的，但是我们举的例子却是一个字符串操作，不能体现这两个流的专门用途。下面可以用这两个流写一个图片的拷贝操作。 图片文件的拷贝public class ImgCopy { public static void main(String[] args) { File file = new File(&quot;D:/unziptest.jpg&quot;); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(file); byte[] b = fis.readAllBytes(); // 读取原始字节 fos = new FileOutputStream(&quot;./Exercise/src/test.jpg&quot;); fos.write(b); // 写入到文件中 } catch (Exception e) { e.printStackTrace(); } finally { // 关闭流 try { if (fis != null){ fis.close(); } if (fos != null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面是一个简单的图片的拷贝的操作。其中第八行的字节来源是从本地读取，其实也可以从网络上读取，然后写入到本地，这样就是一个文件下载的操作。其实这个写入字节和写入字符串的操作比起来，是一模一样的，因为这个流就是写入原始字节，就算是字符串我们不也是使用content.getBytes()的方式得到字节的。（注意这里的编码问题，默认就是工程的编码，我这里就是utf-8 的编码） 字符IO流我们之前看FileOutputStream的官方文档的时候，发现了这样的一句话。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 那么这个FileWriter又是个什么玩意呢？ 从官方文档中看他的继承结构。 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter 我们发现这个流和OutputStream竟然没有任何关系，他竟然是继承于一个叫java.io.writer的类。 public abstract class Writer extends Object implements Appendable, Closeable, Flushable 用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 然而，大多数子类将覆盖这里定义的一些方法，以便提供更高的效率，附加的功能或两者。 看来这个流是专门为了更加方便的写入字符而准备了。可以看到他的write方法中的参数是char[]，而不是byte[]，这样我们就可以不把字符转为字节进行写入，这样可以更加方便地写入也可以更加方便地读取。（有些字符可能会占用两个字节，如果我们是一个字节一个字节进行读取的话，就可能会出现乱码的情况，但是一个字符一个字符读取就不会出现这种问题。所以说进行字符流的操作的时候尽量使用这个流的子类） 写入写出基本上都是有对应的类的，这里既然有Writer，那当然就会Reader，不过他们的用法基本都是相同的。 OutputStreamWriter与InputStreamReaderpublic class OutputStreamWriter extends Writer OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 每次调用write（）方法都会使编码转换器在给定字符上被调用。所得到的字节在写入底层输出流之前累积在缓冲区中。可以指定此缓冲区的大小，但是默认情况下它大部分用于大多数目的。请注意，传递给write（）方法的字符不会缓冲。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 上面是官方文档对这个类的一些说明。第一点倒是之前讲过了一点，对于字符流，一般我们要指定一个字符集，如果不指定的话就会是我们项目默认的字符集，不过如果我们的代码文件转移到别的环境之后，可能会出现一些字符集不一样的bug。至于第三点，我们发现了一个新的流，这个是之后要介绍的了。 OutputStreamWriter(OutputStream out) // 创建一个使用默认字符编码的OutputStreamWriter。 OutputStreamWriter(OutputStream out, Charset cs) // 创建一个使用给定字符集的OutputStreamWriter。 OutputStreamWriter(OutputStream out, CharsetEncoder enc) // 创建一个使用给定字符集编码器的OutputStreamWriter。 OutputStreamWriter(OutputStream out, String charsetName) //创建一个使用命名字符集的OutputStreamWriter。 观察这个类的三个狗渣函数，第一个构造函数没有指定字符集使用的就是默认的字符集。而后面的是哪个构造函数使用了三种不同的方式指定了这个字符流使用的字符集。一般情况下，我们使用第四种就行了，使用字符串来指定字符集，比如“UTF-8”和“GBK”这两种常见的字符集。不过我们使用如下的方式程序将会运行的更快StandardCharsets.UTF-8 然后我们再看看这个函数的第一个参数，是一个OutputStream，我们知道OutputStream是一个抽象类，是不能被实例化的，所以我们可以使用他的子类，比如FileOutputStream。 现在再看看这个类的主要的方法。 void close() // 关闭流，先刷新。 void flush() // 刷新流。 String getEncoding() // 返回此流使用的字符编码的名称。 void write(char[] cbuf, int off, int len) // 写入字符数组的一部分。 void write(int c) // 写一个字符 void write(String str, int off, int len) // 写一个字符串的一部分。 可见这个类不仅可以写入字符数组byte[]，还可以写入String，这是真的方便啊。 代码测试public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, StandardCharsets.UTF_8); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 代码的几点说明： 在new出OutputStream的时候，一般我们要指定一个字符集，可以使用StandardCharsets.UTF_8的这种写法。也可以直接写“UTF-8&quot;。 写入流的时候可以直接使用String，也可以直接使用char[]，不必将其转换成为字节。 关闭流的时候，我们需要先关闭外部的OutputStream然后再关闭内部的FileOutputStream，不然会抛出异常。 至于InputStreamReader的使用，和OutPutstreamWriter的使用是如出一辙的。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 不过需要注意的是，使用read()方法可以读取一个字符，当读取到文件的末尾的时候将返回-1。 OutputStreamWriter已经基本可以满足我们写入字符串的需要了，不过这和官方文档告诉我们的FileWrtter还是不一样，FileWriter‘是其的子类。 FileWriter与FileReader的使用public class FileWriter extends OutputStreamWriter java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter FileWriter既然是上面说的那个OutputStreamWriter的子类，那么它到底有什么有别于他的父类的特殊功能呢？ 方便课写字符文件。该类的构造函数假定默认字符编码和默认字节缓冲区大小是可以接受的。要自己指定这些值，请在FileOutputStream上构造一个OutputStreamWriter。 文件是否可用或可能被创建取决于底层平台。 特别是某些平台允许一次只能打开一个文件来写入一个FileWriter （或其他文件写入对象）。 在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileWriter是用于写入字符流。 要编写原始字节流，请考虑使用FileOutputStream 。 可以看一下第一点，我们可以知道使用这个类的时候我们是无法向OutputStreamWriter那样指定一个字符集的，这个类默认使用系统或者是项目的默认的字符集。第二点倒是不难理解，不过也没有什么重点可言。我们可以看到第三点，这个和我们在FileOutputStream中看到的是一样的。 不过问题在于，使用FileWriter和OutputstreamWriter之间到底有什么区别呢？ FileWriter(File file) // 给一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append) // 给一个File对象构造一个FileWriter对象。 FileWriter(FileDescriptor fd) // 构造与文件描述符关联的FileWriter对象。 FileWriter(String fileName) // 构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append) // 构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。 这里的构造函数没有我们之间看到的OutputStream了，也就是说我们使用FileWriter的时候不必像使用OutputstreamWriter那样先创建一个FIleOutputStream，这个倒是蛮方便的。我们可以给定File类或者文件名进行字符文件的读取。这个类的话是没有额外的方法的，也就是说这个类的使用方法和OutputStreamWriter基本是一样的。 public class FileWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); FileWriter writer = null; try { writer = new FileWriter(file); String content = &quot;why are u so beautiful my girl?&quot;; writer.write(content); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } FileReader的使用方式也是类似的。 public class FileReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); FileReader reader = null; try { reader = new FileReader(file); int res; while ((res = reader.read()) != -1) { System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (reader != null){ reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 总结上面主要介绍的就是Writer和Reader，其实IO中的四大抽象类就是InputStream，OutputStream，Writer，Reader这四种。前两种主要负责的就是原始字节流的操作，而后两种主要就是字符流的操作。不过我们也是可以通过前面的两种类来操作字符流的，不过这就是有点儿麻烦而且无法处理多字符的问题。后面要学习的是更加复杂一点的IO流的知识。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-01]]></title>
    <url>%2F2019%2F09%2F22%2FJava%E4%B8%AD%E7%9A%84IO-01%2F</url>
    <content type="text"><![CDATA[java中的IO-01基本介绍所谓的IO就是Input and Output的意思。在C++中我们学到的IO主要就是两种, Istream and Ostream，cin和cout就是这两个流的对象。C++是这样子的，那么Java又如何呢？我们学习一门语言总是要从hello world开始学起，也就是向控制台中输出hello world这个字符串。在C++中我们使用的是std::cout&lt;&lt;“Hello World”&lt;&lt;std::endl;，在Java中我们使用的是System.out.println(&quot;Hello world&quot;);。既然是输出，那么肯定是和IO流相关的。cout是std::ostream的一个对象，功能是向控制台输出。那么Java中的这个函数又如何理解呢？System是Java中的一个类。 public final class System extends Object 官方文档中这样说道 System类包含几个有用的类字段和方法。它不能被实例化。 System类提供的System包括标准输入，标准输出和错误输出流; 访问外部定义的属性和环境变量; 一种加载文件和库的方法; 以及用于快速复制阵列的一部分的实用方法。 我们继续查阅官方文档，发现System类中有几个静态的成员！ static printStream err; // 标准错误输出流 static printStream in; // 标准输入流 static printStream out; // 标准输出流 这样一来Java中的这个输出函数就很好理解了。 System.out是一个对象，相当于C++中的cout。println是System.out的一个static method用于向控制台输出信息，并在最后输出换行。如果不需要换行的话我们可以使用print方法。 OutputStream与InputStream不过这个System.out为什么能输出字符串呢？那肯定是因为他是一个类似于std::ostream的玩意，他的类型是printStream。我们观察一下它的继承结构。 java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.PrintStream 最顶层的Object这个是毫无疑问的，Java当中的所有的类都是继承于java.lang.Object的。所以说最重要的是第二个 java.io.OutputStream, 正所谓，遇事不决先参看官方文档。 public abstract class OutputStream extends Object implements Closeable, Flushable 这个抽象类是表示字节输出流的所有类的超类。输出流接收输出字节并将其发送到某个接收器。 需要定义OutputStream子类的应用OutputStream必须至少提供一个写入一个字节输出的方法。 void close(); // 关闭此输出流并释放与此流相关联的任何系统资源。 void flush(); // 刷新此输出流并强制任何缓冲的输出字节被写出。 void write(byte[] b); // 将 b.length字节从指定的字节数组写入此输出流。 void wirte(byte[] b, int off, int len); // 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 abstract void write(int b); // 将指定的字节写入此输出流。 这个类是一个抽象的类是不能够被实例化的，也就是说他是所有的输出流的一个模子。我们要针对特殊的情形使用这个类的子类。 InputStream和这个也是同样的道理。 FileOutputStream 与 FIleInputStream前面说了那么多的废话，现在假如我们要输出一些东西到文件中储存能不能做到呢？答案是明显的，我们需要OutputStream的一个合适的子类，这里我们找到了FileOutputStream。我们继续查阅官方文档。 public class FileOutputStream extends OutputStream 文件输出流是用于将数据写入到输出流File或一个FileDescriptor 。文件是否可用或可能被创建取决于底层平台。特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream （或其他文件写入对象）。在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 从文档中我们可以读出，这个类主要是将原始字节流写入到文件当中去的。不过既然这个类可以被实例化，我们就要看看这个类的构造函数是怎么样的。 FileOutputStream(File file) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(File file, boolean append) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(FileDescriptor fdObj) // 创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 FileOutputStream(String name) // 创建文件输出流以指定的名称写入文件。 FileOutputStream(String name, boolean append) // 创建文件输出流以指定的名称写入文件。 这里我们看到了一个File类，可以肯定，这个类代表的就是我们要写入的文件，不过下面的两个构造函数使用的却是String name。这两个是不一样的。 既然是写入，我们还要知道这个类的写入方法是如何的。 void write(byte[] b) // 将 b.length个字节从指定的字节数组写入此文件输出流。 void write(byte[] b, int off, int len) // 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 void write(int b) // 将指定的字节写入此文件输出流。 代码测试public class FileOutputStreamDemo { public static void main(String[] args) { try { FileOutputStream fileOutputStream = new FileOutputStream(&quot;sher&quot;); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这里我们没有使用FIle类来代表文件，使用的是一个String–“sher”，然后使用write方法将字节写入到文件中。最后使用close方法关闭这个流。这里问题来了，我们只是提供了文件的名字，那么文件放在哪儿呢？？莫非是和这个类的文件同级？答案让我很懵逼，这个文件出现在我的项目文件夹的同级。其实这个位置是很沙雕的，因为我有多个项目，谁都不知道这个文件到底是属于哪一个项目的，如果是和src文件夹同级我倒是可以理解。那么我们需要修改文件的位置该如何呢？我们可以修改给定的这个文件的绝对路径，比如说我们是使用如下的代码 FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:/sher&quot;); 那么这个文件就会创建在D盘下。其实我们没有给他一个绝对路径的时候，他使用的就是相对路径，这里的相对路径不是我们想象中的那个相对与代码文件的，而是相对于整个项目的。比如我们也可以这样写。 FileOutputStream fileOutputStream = new FileOutputStream(&quot;./Exercise/src/sher&quot;); 点的意思的本目录，点点指的是上一级目录，这里在我看来点是多余的，但是去除点之后就会报错。可能是没有点他就认为这个是一个绝对路径吧。通过上面的方法我们就将文件创建到了src目录下。不过之前我们提到了一个File类，那个类又如何使用呢？ 我们可以尝试着使用File类。不过在使用File类之前我们还需要去了解一下File类。 public class File extends Object implements Serializable, Comparable&lt;File&gt; 文件和目录路径名的抽象表示，这是官方文档对File类的说明。 File类主要有如下的构战函数 File(File parent, String child) // 从父抽象路径名和子路径名字符串创建新的 File实例。 File(String pathname) // 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File(String parent, String child) // 从父路径名字符串和子路径名字符串创建新的 File实例。 我们修改了一下代码 public class FileOutputStreamDemo { public static void main(String[] args) { try { File file = new File(&quot;./Exercise/src/sher&quot;); System.out.println(file.getPath()); FileOutputStream fileOutputStream = new FileOutputStream(file); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这个修改倒是不痛不痒的，只是修改了一点点而已。其实File类还有其他非常多的方法，这里我们学习的是IO，只要简单的会使用就好啦。 注意点： 你可能注意到了FileOutputStream构造函数还有第二个参数(boolean append)，默认是false（其实这句话是错误的，Java中的函数没有默认值，只是如果我们没有第二个参数的话，调用的单个参数函数就是相当于第二个参数是false），如果我们将其设置为true的话，写入的文件的时候就不会将原有文件清空，而且接着后面继续写入。（如果文件不存在就会创建该文件） write(byte[] b, int off, int len)的使用。 fileOutputStream.write(content.getBytes(), 3, 4);写入文件的就是“r is”从第三个字符开始，写入四个字符。注意一个中文是两个字符。 write(int b)的使用 这个就更简单了，这个就是写入一个字节。比如wirte(97)就是写入一个字符a. flush()方法的使用 有时候写入的时候可能并不会直接写入，我们需要使用flush()方法刷新缓冲区之后才能写入。所有说可以在写入操作完成之后加上这个flush()方法。 上面还只是文件的简单的写入，下面还要学习一下简单的文件的读取操作。 public class FileInputStreamDemo { public static void main(String[] args) { try { FileInputStream fileInputStream = new FileInputStream(&quot;./Exercise/src/sher&quot;); byte[] b = new byte[1024]; int res = fileInputStream.read(b); System.out.println(res); System.out.println(new String(b)); } catch (Exception e) { e.printStackTrace(); } } } read函数有一个返回值，这个值的意思的读取的字符数。 其实这个FileInputStream和FileOutputStream是非常类似的。只有个别的方法存在差别。 比如说FileInputStream对象没有flush方法，不过他有一个skip方法。 long skip(long n) // 跳过并从输入流中丢弃 n字节的数据。 如果我们使用skip(1)的话，第一个字节将会被我们跳过，他的返回值是实际跳过的字节数。 总结到这里我们就基本学完了Java io的几个最基本的类，这些类也是以后学习更加复杂的IO类的基石。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈最长回文子串——马拉车算法]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%86%8D%E8%B0%88%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[再谈最长回文子串——马拉车算法 之前说过一个算法，也是和字符串有关的——字符串的匹配算法。我们介绍了暴力匹配的BF算法，还有比较难以理解的KMP算法，最后还介绍了一种简单搞笑的Sunday算法。这里我们谈论的也是字符串问题，也就是前面所讲的最长回文子串问题，本来说是不再介绍这种适用性不强的算法的，但是这个马拉车算法和KMP算法是类似的，也是一种奇葩的算法，这里就稍微了解一下吧。 基本介绍之前解决这个问题我们使用的是动态规划算法，时间复杂度是O(n2), 空间复杂度也是O(n2)。毫无疑问这个算法还是有一点儿低效的。之前字符串的暴力匹配的算法时间复杂度是O(nm)，使用KMP算法可以优化到O(n+m)，直接是优化了一整个等级。KMP算法思路是利用已经匹配失败之后的信息来帮助下一次匹配。马拉车算法也是如此，利用回文串匹配失败的信息来加速回文串的判断。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈动态规划]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%8D%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[再谈动态规划 动态规划算法是很常见的，但是上次讲的那啥动态规划讲的几个例子都不是非常的经典，不过他们依旧都是动态规划。可以很清楚的看到他们都是利用了一个类似递归的表达式（状态转换式），从一个子问题的解到另一个子问题的解。如何能一眼看出这个使用的是动态规划算法，如何一眼看出状态转换式，这个可以说是非常困难的，需要对动态规划算法非常的熟悉才行。现在就来举几个之前写好了的例子来看看动态规划算法吧。 动态规划题目最大路径和这道题口头叙述起来比较困难，直接图形化描述吧。 1 3 2 2 4 7 上面有一个三角形形状的数阵。我们从第一层开始走到最后一层，每次到下一层只能选择向左或者向右，请问如何走才能使得最终走的路径上的数字之后是最大的。思路分析这个也是动态规划算法吗？这个当然是。先想想这个问题的子问题到底是什么？我们要知道走到第三层路径的最大的和，假如我们已经知道第二层的最大路径的和呢？ 这有啥用，我们也不知道其他的位置怎么样，比如上面的那个第二层的最大路径和是4，但是要找到三层的最大路径要走旁边的那个2，所以说我们知道最大路径和是没用的。 但是我们可以考虑到每一层的每一个点的最大路径的值，最终的结果也就是最后一层的值的最大值。 4 3 2 3 7这是我们已经知道了第二层的每个点的最大路径值，那么第三层和第二层之间有什么联系呢？ 比如第一个2，他只能和4加，那就是6,。 3可以选择和4或3加，去最大值就是7。 7只可以和3加，那就是10 6 7 10最后我们找到最后一层的最大值，也就是10。这就是最大路径和。 那么状态转移式该如何写呢？ f(i, j) = max(f(i-1, j-1), f(i-1, j)) + f(i, j)； 当然这里的i,j都是有条件的。i的含义是第几层，j的含义的第几个。这样我们就可以使用二维数组来表示这个了 1 3 2 2 4 7但是这样是否最优呢？我们可以轻易的发现，每次我们只是使用了一层的数据。比如找第三层的我们只需要第二层，找第四层我们只需要第三层，那么我们可不可以只使用一个一维数组来表示呢？ 我们现在有个思路就是从最后一层开始算，为什么呢？因为到点是固定的。第一层只有一个值，最终得到的最大路径肯定是一维数组的第一个数，而且也不用考虑左右的问题了。 2 3 7 4 3 1 这是一个二维数组 找一个一维数组将最后一排赋给它 2 3 7 和第二排比较 —————— 2 3 7 3 2 -&gt; 6 9 7 只是变了第一个数和第二个数 和第一层比较 ---- 6 9 7 1 -&gt; 10 9 7 这是变了第一个数，而这个第一个数就是最大路径这个想法确实是蛮巧妙的。我感觉牛逼！！ 这是状态转移方程就改变了 maxNum(j) = max( maxNum(j), maxNum(j+1) ) + f(i)(j) 这里的maxNum就是之前的那个一维数组。到最后这个数组的第一个数肯定就是最大路径和。 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 10 int n = 0; int maxSum[MAX] = {0}; int num[MAX][MAX] = {0}; int main(){ cout&lt;&lt;&quot;Please input n:&quot;; cin &gt;&gt; n; for (int i=0; i&lt;n ;i++){ for (int j=0; j&lt;=i; j++){ cin &gt;&gt; num[i][j]; } } // 把最后一排赋给那个一维数组 for (int i=0; i&lt;n; i++){ maxSum[i] = num[n-1][i]; } for (int i = n-2; i&gt;=0; --i){ for (int j=0; j &lt;=i; ++j){ maxSum[j] = max(maxSum[j], maxSum[j+1]) + num[i][j]; } } cout&lt;&lt;maxSum[0]; return 0; } 代码说明： 其实思路分析那一块，我做的说明已经足够多了，这里就稍微说一点吧。其实也就只有for循环那一块了吧。 第一个for循环指的是从倒数第二行开始，一直比到第一行(上面我们也是这么说的，倒着来比较) 第二个for循环是计算一位数组里的值，下面也用到了我们说的状态转移方程。 线性模型 过桥 /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ 思路分析这个题目其实蛮难的，说实话不容易想到。不过要说这个是动态规划的话，我们就要找子问题。第n个人过河，和第n-1个人过河到底有没有联系？好像并没有什么联系,每个人过桥的 时间都是乱的。但是假如我们把每个人过桥的时间给从大到小排个序呢？ 这时候加了一个时间最大的人，该如何选择过河方案？ 首先我们得让那n-1个人过河，然后派时间最少的人去河对面接那个后来的人。但是这样子的时间是不是最短的呢？肯定是的，就算你让后来的那个人代替倒数第二个人也是时间最短，因为他们始终只是过河过了一次，他们时间慢的人是不可以回头去接对面的人过来的。所以我们就得到了状态转移方程 f(i) = f(i-1) + 2*time[0] + time[i] 但是还有一个问题，这也就是这个问题难的地方。我难道不可以让n-2个人先过河，然后再让2个人过河。 这样的时间又如何呢？易得他们的状态转移方程 f(i) = f(i-2) + time[0] + time[i] + 2*time[1] 这个状态转移方程也是要说明一点的。首先我们要让最快的那个人把灯送回去，然后让最后两个人过河，再让第二快的去接最快的那个人。 我们得到了两个状态转移方程，只是我们只要取得他们之间的最小值就行了。所以说最终的状态转移方程是 f(i) = min( f(i-1) + 2*time[0] + time[i], f(i-2) + time[0] + time[i] + 2*time[1]) 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ int size_time[10]{0}; int solution(vector&lt;int&gt;, int); int solution(vector&lt;int&gt; person_time){ return solution(person_time, person_time.size()-1); } // 备忘录类型的自上而下的动态规划，使用递归来实现 int solution(vector&lt;int&gt; person_time, int size){ // 动态规划 if (size_time[size] != 0){ return size_time[size]; } if (size == 0){ size_time[0] = person_time[0]; return size_time[0]; }else if (size == 1){ size_time[1] = max(person_time[0],person_time[1]); return size_time[1]; }else{ // 递归的一个子问题，前几个怎么过，再加一个人怎么过？ 双数是怎么过？单数是怎么过？ size_time[size] = min(solution(person_time, size-1)+person_time[0]+person_time[size], solution(person_time, size-2) + person_time[0] + person_time[size] + 2*person_time[1]); return size_time[size]; } } 前面的那个动态规划的文章也说过了，我们完全可以将这里的递归转为递推。 int solution2(vector&lt;int&gt; person_time){ int size = person_time.size()-1; size_time[0] = person_time[0]; if (size == 0){ return size_time[0]; } size_time[1] = max(person_time[0], person_time[1]); if (size == 1){ return size_time[1]; } // 其实完全可以不使用数组，只使用三个变量就可以完事了，不过这个已经不是非常的重要了，问题不大 // 自下而上的动态规划，使用递归的方式实现，比上面的算法更加的高效 for (int i=2; i&lt;=size; ++i){ size_time[i] = min(size_time[i-1]+person_time[0]+person_time[i], size_time[i-2]+person_time[0]+person_time[i]+2*person_time[1]); } return size_time[size]; } int main(int argc, char const *argv[]) { vector&lt;int&gt; person_time = {5,1,2 ,10}; sort(person_time.begin(), person_time.end()); // 一定要排序！ cout&lt;&lt;solution2(person_time)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 区间模型 回文串/** * 动态规划算法的区间模型 * 区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解， * 然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 */ 思路分析 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 分析： 典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时， 在X两边各添加一个字符’a’后，aXa仍然是一个回文串， 我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数， 那么对于A[i] == A[j]的情况，很明显有 d[i][j]= d[i+1][j-1] （这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串， 所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策： 在A[j]后面添加一个字符A[i]； 在A[i]前面添加一个字符A[j]； 根据两种决策列出状态转移方程为：d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1)空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。 代码实现#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using std::string; using std::cout; using std::endl; using std::min; int memo[10][10]{0}; int func(string, int, int); int func(string str){ return func(str, 0, str.length()-1); } // 开始区间类型的动态规划 下面使用的时候备忘录类型的 int func(string str, int start, int end){ if (memo[start][end] != 0){ return memo[start][end]; } if (start &gt;= end){ return 0; } if (str[start] == str[end]){ return func(str, start+1, end-1); }else { memo[start][end] = min(func(str, start+1, end), func(str, start, end-1))+1; return memo[start][end]; } } int main(int argc, char const *argv[]) { string str = &quot;srsher&quot;; cout&lt;&lt;func(str)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 0/1背包问题0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品， 使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。思路分析这是我第三次看到这个问题。我们还是先开始来找子问题。比如有四个物品，我们将其按价格排个序。现在加入我们只是发第一个物品。得到金额。然后我们放两个物品，得到金额。问题就在放n个物品得到的金额和n-1个物品到底有没有关联呢？ 可以第n个物品太重了，空间根本放不下，放n个物品的金额就是等于n-1个物品。 还有可能第n个物品可以放下去，还有剩余的空间，再用剩余的空间放那n-1个物品。 这两种方案并不能确定谁大谁小，所以说状态转移方程中，要比较他们的大小关系。 f(n, weight) = min{f(n-1, weight), v[n]+f(n-1 ,weight-w[n]))} 这里的weight其实指的是背包的容量还有多少。v数组指的是某一样物品的价格，w指的是某一样物品的重量 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using std::cout; using std::endl; using std::vector; using std::max; int memo[10][10]{0}; int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int i, int size){ if (i == 0){ if (weight[0] &gt; size){ return 0; }else { return value[0]; } } if (memo[i][size] != 0){ return memo[i][size]; } if (weight[i] &gt; size){ return func(weight, value, i-1, size); } // 放入第i件物品，再使用剩下的空间放i-1件物品， 这样做到底有没有不放入第i件，只是使用前面的i件好？ // 但是有个问题是，这个我们可能不知道到底把什么放入了背包？？？这个问题很大我感觉。。。 // 不过，似乎用一个数组来表示是否被放入的状态可能可以解决 memo[i][size] = max(func(weight, value, i-1, size), func(weight, value, i-1, size-weight[i])+value[i]); return memo[i][size]; } int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int size){ return func(weight, value, weight.size()-1, size); } int main(int argc, char const *argv[]) { vector&lt;int&gt; weight = {1,3,5,7,9}; vector&lt;int&gt; value = {1,3,5,7,10}; cout &lt;&lt; func(weight, value, 100) &lt;&lt;endl; system(&quot;pause&quot;); return 0; } 总结上面的几道题目就是动态规划问题的经典问题。从这里我们基本就可以看出动态规划的问题到底该怎么解决。第一寻找子问题到底是什么？然后寻找状态转移方程，注意这个状态转移方程的多样性。其实之前的那个动态规划基本介绍中讲的蛮详细的，不过也蛮啰嗦的。不管了，动态规划就此了结吧，拜拜了您嘞！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串问题]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最长回文子串问题 突然发现已经好久没有写博客了，虽然说最近一直都在补京阿尼的番还有一些猛男番确实是原因之一啦。不过最近确实是在看安卓这方面的东西，之前尝试着写了一点，但是我这个安卓也是小白，啥都不懂，只是在学一点儿基础，这好像也没啥好写的东西吖。于是就上leetcode看看，没想到前面的第五题我竟然都没写，不过通过率是低的真实，不用说，这肯定是一道比较难的题目了，下面就来看看这个题目吧。 题目的基本介绍给定一个字符串s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 这个题目看起来似乎是很简单的，不过说实话难的很。反正我是不会做的。而且这个题目的解法是真的特别的多，有很多的神仙解法，把这些的只适用于这道题目的神仙解法都研究透了，似乎这也没有什么意义，所以这里我要介绍的也就是这道题目的最简单的也是最复杂的解法——使用动态规划来解决。 思路分析动态规划算法之前就已经说过了，不过当时似乎没有写什么例子，也没做做过多的说明。不过，动态规划的基本思路我们还是明白的。找到子问题不同状态之间的关联，也就是那个递推的公式。比如说背包问题，放三样东西和放两样东西之间的关联是如何的。找到了这样的公式，问题也就可以轻松的解决了。 这道题目其实也蛮类似的。我们假定i和j分别指向字符串的头和尾，我们要知道i-j这一块是回文串，那么我们就可以得到i+1-j-1这一块肯定也是字符串，而且i处的字符要等于j处的字符。这时我们就可以得到一个关系表达式： 这个递推的表达式，说实话是蛮简单的了，不过不理解动态规划的算法确实很难想出来，反正我是没有想出来的。不过看懂还是可以看懂的(到头来，做了那么多的动态规划的题目，遇到这种题目根本不知道用动态规划，也不明白如何用动态规划，可悲可悲,明天可以把之前做的那四个动态规划的题目给总结了) 这样动态规划的思路就用了，如何使用代码来实现呢？ 上面的f(i, j)很容易的想到使用二维数组来实现，和背包问题是类似的。f(i, j)表示的意思就是i-j是否是回文串（i和j都是包含的） 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Solution { public: static string longestPalindrome(string s) { int length = s.length(); if(length == 0 || length == 1){ return s; } int max_len=1; int max_start=0; bool** f= new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } // 这个似乎不初始化也是对的 // for (int i=0; i&lt;length; i++){ // for (int j=0; j&lt;length; j++){ // f[i][j] = false; // } // } for(int j=0;j&lt;length;j++){ int i=0; f[j][j]=true; for(;i&lt;j;i++){ f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); if(f[i][j] &amp;&amp; j-i+1 &gt; max_len){ max_len = j-i+1; max_start = i; } } } return s.substr(max_start, max_len); } }; int main(int argc, char const *argv[]) { cout&lt;&lt;Solution::longestPalindrome(&quot;abbbbdsfdsga&quot;)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 代码说明： 堆上的二维数组 因为这里我使用的C++，不是Java。所以说在堆上new一个二维数组这种玩意的事，我是真的没用过。问了网上，他们都推荐使用vector,不过这个vector还是要resize的要给定vector一个大小才能够那样像数组一样的使用 vector&lt;vector&lt;bool&gt;&gt; f; for (int i=0; i&lt;length; i++){ f.emplace_back(vector&lt;bool&gt;(length, false)); } 这样确实是一个好办法，不过new二维数组也不是难事，我一开始是这样子干的。 bool** f = new bool[length][length]; 不过，很遗憾，报错了，不可以在堆上new出一个二维的数组，这里是C++，这里不是Java。 那怎么办呢？我又尝试了这样子的 bool** f = new bool[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这个方法也确实是够蠢的，new返回的是bool*，我却使用bool**来接收，这是肯定错误的啊。 后来查了资料才知道，原来可以这样子干啊。 bool** f = new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这样子就搞定了，第一个new返回的是bool**类型的，第二个new返回的是bool*类型的， 这样子堆上的一个二维数组的问题也就解决了。那为啥不用vector呢？可以用，而且作为使用C++的程序员，最好就别使用这种C类型的数组的。但是为了满足好奇心，这次就使用一下子。(C++11中stl中出现了array，其实说真的我们已经不需要C类型的任何数组和，无论是堆上的还是常量区上的，C++中都有对应的数据结构，stl就是这么强大) for循环内 和背包问题是类似的，我们可以先只是取前面几个字符串，然后每次加一个字符。j就是代表着取的字符串的最后的位置（包含）。每次都将f[j][j]置为true，因为此时字符串长度为1这肯定是回文的。然后然i从0开始到j判断f[i][j]的值，也就是说此时j永远是结束的那个位置。而j又是从0开始的到length-1结束，也就是所有的情况都会被遍历的。而这个算法的时间复杂度从这儿就很容易的得出来是O(n2)，空间复杂度也是O(n2)，算得上是一个比较低效的算法了，就这个题目有O(n), O(n)的算法，不过我也不需要去了解了，看过多的骚算法也不好，反正也用不到，费脑细胞。 f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); 这个就是使用的上面的那个递推的表达式，不过有点儿不同。我在后面加入了j-i==1，这时也就是说字符串的长度就是2，这是是不能进行后面的那个递推的，所以要单独拎出来。 至于后面的那个判断也就是看看找到的回文字符串的长度有没有最大的大，如果有的话就把他记下来，而且还要把开始的位置记下来，因为函数返回的字符串不是长度。刚好c++中的substr()这个函数就两个参数，第一个参数是开始的索引，第二个位置是字符串的长度。 return s.substr(max_start, max_len); 如果是Java的话就不是这样子了。Java当中的substring()函数（为啥不是subString？这明显不符合Java函数的驼峰式的命名规范啊。。。）的第一个参数是开始的索引，第二个参数的结束的索引（不包含） return s.substring(max_start, max_start+max_len); 总结动态规划算法算是很常见的了，如果理解了这个算法，会发现这个算法其实代码很好写，就是找那个递推的关系。不过我现在也就是停留在能做成做过的动态规划的题目，如果真的是给我一道算法的题目，我真的不知道是否该用动态规划算法，如果要用又是怎么用呢？唉，还是太菜了，对这个算法的理解还不够。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（二）工厂模式]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本介绍大名鼎鼎的GOF对工厂模式的定义是这样子的。 “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。) 工厂模式的分类 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式； 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。 为什么要使用工厂模式 解耦 ：把对象的创建和使用的过程分开 降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。 下面将分这三种模式来简单的介绍一下工厂模式。 简单工厂模式简单工厂的基本介绍严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况。 最重要的是它违背了我们在概述中说的 开放-封闭原则 （虽然可以通过反射的机制来避免，后面我们会介绍到） 。因为每次你要新添加一个功能，都需要在生switch-case 语句（或者if-else 语句）中去修改代码，添加分支条件。 简单工厂的适用场景 需要创建的对象较少。 客户端不关心对象的创建过程。 简单工厂模式角色分配 工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 简单工厂实例public interface IProduct { void print(); // 这是要暴露的方法 } public abstract class AbstractProduct implements IProduct { protected void printBefore(){ System.out.println(&quot;before print&quot;); // 这里所公共的实现 } } public class AProduct extends AbstractProduct { private String name; public AProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print A &gt;&gt;&gt;&quot;+name); } } public class BProduct extends AbstractProduct { private String name; public BProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print B &gt;&gt;&gt;&quot;+name); } } public class SimpleFactory{ public static AProduct sellAProduct(){ return new AProduct(); } public static BProduct sellBProduct(){ return new BProduct; } } 这里我们有两个产品分为是产品A和产品B。还有一个卖产品的简单工厂，里面有卖A产品和卖B产品的地方。现在我们加入这个设计是合理的。现在多了一个C产品，我们要写一个C产品，让他继承那个抽象的产品，然后还有在工厂当中加入买C产品的函数。这显然有点儿烦了。我们可以将工厂进一步的抽象。 public class SimpleFactory { public static IProduct getProduct(String name){ if(&quot;A&quot;.equals(name)){ return new AProduct(name); }else if(&quot;B&quot;.equals(name)){ return new BProduct(name); }else if(&quot;C&quot;.equals(name)){ return new CProduct(name); }else { throw new IllegalArgumentException(); } } } 这样我们就可以只用一个方法就可以完成所有的产品的制作了。但是这个简单工厂并不符合设计模式。每次增加产品的时候都要修改工厂类的方法。我们做产品的一个主要的思路就是尽量不要依赖具体，尽量不要修改而是增加。 为什么要使用工厂模式？ 如果这里要要多了店要来买我们的产品，如果没有工厂的话，所有的店都要依赖我们的产品类。一旦产品有什么修改，比如说增加了什么产品，或者修改了什么产品，所有的店家都要修改代码。所以说这样非常的不好。有了工厂之后，店不用直接依赖什么具体的类，不用使用new来产生产品，而是依赖工厂，通过工厂来获取产品。只是产品有了修改，在简单工厂模式里面来说，只是修改了工厂类而已，店家的类的代码没有必要去修改。 再来一个例子 创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图. （1）创建Shape接口 public interface Shape { void draw(); } （2）创建实现该接口的具体图形类 圆形 public class Circle implements Shape { public Circle() { System.out.println(&quot;Circle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Circle&quot;); } } 长方形 public class Rectangle implements Shape { public Rectangle() { System.out.println(&quot;Rectangle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Rectangle&quot;); } } 正方形 public class Square implements Shape { public Square() { System.out.println(&quot;Square&quot;); } @Override public void draw() { System.out.println(&quot;Draw Square&quot;); } } （3）创建工厂类： public class ShapeFactory { // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) { if (shapeType == null) { return null; } if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) { return new Circle(); } else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) { return new Rectangle(); } else if (shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)) { return new Square(); } return null; } } （4）测试方法： public class Test { public static void main(String[] args) { // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape(&quot;CIRCLE&quot;); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape(&quot;RECTANGLE&quot;); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape(&quot;SQUARE&quot;); square.draw(); } } 输出结果： Circle Draw Circle Rectangle Draw Rectangle Square Draw Square这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。 所以说简单工厂模式需要进行改进。 工厂方法模式先来说说上面的AB产品的例子。 public interface IFactory { IProduct getProduct(); } public class AFactory implements IFactory { @Override public IProduct getProduct() { return new AProduct(AProduct.class.getName()); } } public class BFactory implements IFactory { @Override public IProduct getProduct() { return new BProduct(BProduct.class.getName()); } } 这一次我们让客户端不再依赖具体的工厂类，而是依赖一个抽象的工厂类。然后让各个生产对应的产品的工厂继承抽象工厂，实现抽象工厂的方法。这时，我们就满足依赖倒置原则了。我们的客户端不再依赖具体，而是一览抽象。当我们有了一个C产品的时候，我们只有添加C类，和CFactory就行了，我们这时只是增加了代码，没有修改之前的代码，符合设计模式的规则。 突然发现有些糟糕了，因为代码变得很多了，因为功能类似的产品我们进行 3 层抽象，针对每个产品我们还抽象出了 2 层的工厂类。但是我们在某个具体的业务场景中，不单单是只实例化一个类啊。举一个例子，在游戏中，我们要一个战士配装备，首先我们需要配一把枪械（枪械有很多，步枪，狙击枪等，使用问题 1 进行抽象），但是配了枪械之后，我们还需要配子弹啊（继续使用问题 1 的方法进行抽象），好了，现在可以抽象出 2 层的工厂类了，针对现在的情况我们是不是可以让一个工厂既生产枪械，又生产子弹呢？ 这就是抽象工厂模式。简单来说，可以把有一些有联系或者相近的产品，放到一个工厂去生产，没有必要单独再开一个工厂了。 图形的工厂方法的介绍 上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。 (1)增加一个工厂接口： public interface Factory { public Shape getShape(); }（2）增加相关工厂类: 圆形工厂类 public class CircleFactory implements Factory { @Override public Shape getShape() { // TODO Auto-generated method stub return new Circle(); } }长方形工厂类 public class RectangleFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Rectangle(); } }圆形工厂类 public class SquareFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Square(); } }（3）测试： public class Test { public static void main(String[] args) { Factory circlefactory = new CircleFactory(); Shape circle = circlefactory.getShape(); circle.draw(); } }输出结果： Circle Draw Circle工厂方法的一些应用我们都知道 Java 的泛型是采用类型擦除来实现的（在 javac 编译过程的中把泛型去掉，加上强制类型转换）。所以我们不能直接 new T()来实例化一个对象。其实可以采用工厂方法模式设计模式来解决。 假设我们有一个类，里面要用到了泛型的实例化。 public class Foo&lt;T&gt;(){ private T t; public Foo(){ t = new T(); // 这个代码是有问题的，我们使用工厂设计模式进行改进 } } 我们给出工厂接口如下： public interface IFactory&lt;T&gt;(){ T create(); } 进而我们可以采用如下的方法进行改进 public class Foo&lt;T&gt;(){ private T t; public &lt;F extends IFactory&lt;T&gt;&gt; Foo(F factory){ // t = new T(); return factory.create(); } } 这个时候，我们可以采用如下的方式实例化 Foo new Foo(new Ifactory&lt;Integer&gt;(){ Integer create(){ return new Integer(0); } }); new Foo(new Ifactory&lt;String&gt;(){ String create(){ return &quot;Hello&quot;; } }); 抽象工厂抽象工厂的基本介绍在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。 抽象工厂应该是比较最难理解的一个工厂模式了。 抽象工厂的适用场景 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品） 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 抽象工厂方法模式角色分配 抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。 不知道大家玩过穿越火线或者吃鸡这类游戏了吗，游戏中存在各种枪。我们假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。（AK工厂生产AK系列产品包括子弹啊，AK枪的类型啊这些，M4A1工厂同理） （1）创建相关接口： 枪 public interface Gun { public void shooting(); } 子弹 public interface Bullet { public void load(); } （2）创建接口对应实现类： AK类 public class AK implements Gun{ @Override public void shooting() { System.out.println(&quot;shooting with AK&quot;); } } M4A1类 public class M4A1 implements Gun { @Override public void shooting() { System.out.println(&quot;shooting with M4A1&quot;); } } AK子弹类 public class AK_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with AK&quot;); } } M4A1子弹类 public class M4A1_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with M4A1&quot;); } } （3）创建工厂接口 public interface Factory { public Gun produceGun(); public Bullet produceBullet(); } （4）创建具体工厂 生产AK和AK子弹的工厂 public class AK_Factory implements Factory{ @Override public Gun produceGun() { return new AK(); } @Override public Bullet produceBullet() { return new AK_Bullet(); } } 生产M4A1和M4A1子弹的工厂 public class M4A1_Factory implements Factory{ @Override public Gun produceGun() { return new M4A1(); } @Override public Bullet produceBullet() { return new M4A1_Bullet(); } } （5）测试 public class Test { public static void main(String[] args) { Factory factory; Gun gun; Bullet bullet; factory =new AK_Factory(); bullet=factory.produceBullet(); bullet.load(); gun=factory.produceGun(); gun.shooting(); } } 输出结果： Load bullets with AK shooting with AK总结意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 参考：深入理解工厂模式 知乎回答 工厂模式|菜鸟教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图和图的BFS与DFS]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84BFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[图和图的BFS与DFS图的基本介绍图和树一样，也是一种数据结构，不过这种数据结构恐怕是来得复杂了那么一点点。图一般由节点(Vertex) 与 边（Edge）来组成， 其中边是否是有方向的又将图分为有向图和无向图。有时边还是带有权值的，这时图被称为带权图。 图的表示的方式也有很多样，这里我们采用的是最简单的邻接矩阵来表示图。不要看到矩阵就嗷嗷嗷的~其实这里就是一个二维的数组而已，和线代没关系的，不要慌嘛。 图的创建看其实图和树还是有一点儿像的，但如果使用树的方式去构建图的话，效率就会变得特别的低下，所以我们要考虑其他的表示图的方案。 表示顶点创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。 class Vertex&lt;E&gt;{ private E label; private boolean isVisited; public Vertex(E label){ this.label = label; } public E getLabel() { return label; } public void setLabel(E label) { this.label = label; } public boolean isVisited() { return isVisited; } public void setVisited(boolean isVisited) { this.isVisited = isVisited; } } 表示边图的实际信息都保存在边上，因为它们描述了图的结构。我们容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。 我们是用邻接矩阵的方式来表示顶点是否是相邻的，如果是相邻的权值又是多少。 上图就是一个邻接矩阵，可以看到这个是一个实对称矩阵（求出对应的二次型的标准型，并判断是否正定，跑偏了，和线性代数没有关系的）。第一行的那个2就表示第一个节点和第二个节点是相连的，而且权值为2，这个又是一个无向图，所以一定是对称的。 表示图根据上面的思路就可以轻松的写出图的结构，还有一些简单的函数。 使用集合来存放节点，是用二维数组来存放邻接矩阵。so easy class Graph2&lt;E&gt; { private ArrayList&lt;Vertex&lt;E&gt;&gt; vertexList; private int[][] edges; private int numOfEdges; public Graph2(int n) { this.edges = new int[n][n]; this.vertexList = new ArrayList&lt;Vertex&lt;E&gt;&gt;(n); this.numOfEdges = 0; } public int getNumOfVerter() { return vertexList.size(); } public int getNumOfEdges() { return numOfEdges; } public E getValueByIndex(int index) { return vertexList.get(index).getLabel(); } public int getWeight(int v1, int v2) { return edges[v1][v2]; } public void showGraph() { for (int[] val : edges) { System.out.println(Arrays.toString(val)); } } public void insertVertex(Vertex&lt;E&gt; vertex) { vertexList.add(vertex); } public void insertEdge(int v1, int v2) { insertEdge(v1, v2, 1); } public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; ++numOfEdges; } } 下面我们去主方法进行一次测试，看看代码是否存在一些问题。 public static void main(String[] args) { int n = 5; Graph2&lt;String&gt; graph = new Graph2&lt;String&gt;(n); String[] vertexValues = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; for (int i = 0; i &lt; vertexValues.length; i++) { graph.insertVertex(new Vertex&lt;String&gt;(vertexValues[i])); } graph.insertEdge(0, 1); graph.insertEdge(0, 2); graph.insertEdge(1, 2); graph.insertEdge(1, 3); graph.insertEdge(1, 4); graph.showGraph(); } 输出的结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0] 到此为止，一个图就已经创建完成了。下面我们开始研究图的遍历的问题。 图的遍历图的遍历和树的遍历一样，也有两种。一个广度优先遍历，一个是深度优先遍历。之前在将树的遍历的时候就讲了这个是如何实现的了。不过图的遍历和树的遍历又是不一样的了，图中是没有指针来连接各个节点的。所以说只是遍历的思路是一样的，算法还是完全不同的。树的遍历用到了队列和栈，不过图是不需要的。 深度优先遍历 深度优先遍历的思路 深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是： 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。 然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。 简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止 这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。 如图所示： 深度优先搜索的算法比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。 代码实现首先我们要写找到临近节点的函数 public int getFirstNeighbor(int index) { for (int j = 0; j &lt; getNumOfVerter(); j++) { if (edges[index][j] &gt; 0) {// 表示两个节点是相通的。 return j; } } return -1; } public int getNextNeighbor(int v1, int v2) { for (int j = v2+1; j &lt; getNumOfVerter(); j++) { if (edges[v1][j] &gt; 0) { return j; } } return -1; } 然后就可以写深度优先遍历的代码了 // 图的深度优先遍历(DFS) private void depthFirstSearch(int i) { System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); int w = getFirstNeighbor(i); while (w != -1) { // 如果第一个邻近顶点w没有被访问过，就直接以他作为开始继续深度优先 if (!vertexList.get(w).isVisited()) { depthFirstSearch(w); }else { // 如果已经被方位过了，就继续寻找下一个w，如果等于-1的话就说明，没有邻近定点了，退出循环即可。 w = getNextNeighbor(i, w); } } } public void depthFirstSearch() { initVisit(); // 图并不一定是连通的，我们要对每一个顶点都作为开始判断一下，是否有没有被访问过的节点。 for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { depthFirstSearch(i); } } } // 初始化visit，防止之前已经进行过什么遍历了，再次遍历就会出问题。 public void initVisit() { for (Vertex&lt;E&gt; val : vertexList) { val.setVisited(false); } } 代码说明： 大部分的内容我都在上面的注释中进行过说明了，而且这个图的深度优先的遍历确实是有一点儿简单，所以没什么说的也是很正常的，看懂我注释基本上的明白了图的深度优先遍历的。 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 广度优先遍历 广度优先遍历的思路 广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是： 首先访问出发点Vi 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。 如图所示： 简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层 广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下： 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中; 从图中取下一个顶点v，添加到已访问的顶点列表 将所有与v相邻的未访问顶点添加到队列。 可见这个图的广度优先遍历和树的广度优先遍历还是有点儿相似的，都是使用队列这个数据结构来实现的。深度优先遍历不一样，树使用的是栈这个数据结构。 代码实现// 广度优先遍历(BFS) private void broadFirstSearch(int i) { int u; // 队列的头节点对应的下标 int w; // LinkedList实现了队列的接口，所以说可以拿来当队列来使用 LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); queue.addLast(i);// 入队列 while (!queue.isEmpty()) { u = queue.removeFirst();// 出队列 w = getFirstNeighbor(u); while (w != -1) { if (!vertexList.get(w).isVisited()) { System.out.print(getValueByIndex(w) + &quot;-&gt;&quot;); vertexList.get(w).setVisited(true); queue.addLast(w); }else { w = getNextNeighbor(u, w); } } } } public void broadFirstSearch() { initVisit(); for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { broadFirstSearch(i); } } } 代码说明： u和w是什么含义？ u表示的是队列中的第一个顶点，也就是说出队列的那个顶点。w和上面的深度优先是一样的，都是表示的是当前顶点的下一个邻接顶点。 两个while循环？ 先看第二个while循环，如果这个邻接顶点w没有被访问过，那么我们就方位，不然我们就找u的下一个邻接顶点。其实这个也是很好理解的。如果这个while循环结束的话，那么也就是以为着u的所有的邻接顶点都被访问过了。那么我们就访问u的邻接顶点的所有的邻接顶点。刚才的u的所有的邻接顶点都已经入队列了。我们只需要按顺序让他们出队列就行了。如果第一个while循环也结束了，那就说明u的所有的可以连通的顶点都通过广度优先遍历访问玩了。但是这并不意味着图就遍历完了。上面也说过了，图可能不是连通的。所以就有了下面的那个函数来做保证 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 和深度优先遍历输出的结果竟然是一样的，不过这个例子是纯属巧合而已 总结上面我表示图是用的邻接矩阵的方式，还可以使用邻接表的方式来表示这个图结构，而且效率也是有点儿小高。不过这里我就不瞎掰了，就先介绍一个邻接矩阵就完事了。感觉图的 BFS和DFS比树的真的是差不多，至少理解其实都不是很难。 参考文章：数据结构与算法：图和图算法(一)扩展文章：数据结构与算法 - 图论]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（一）单例模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式基本介绍单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单例模式的基本思路实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 单例模式的实现饿汉式public class SingletonTest01{ public static void main(String[] args) { // Singleton01 singleton01 = new SingletonTest01(); Singleton01 singleton1 = Singleton01.getInstance(); Singleton01 singleton2 = Singleton01.getInstance(); System.out.println(&quot;singleton1:&quot;+singleton1.hashCode()); System.out.println(&quot;singleton2:&quot;+singleton2.hashCode()); } } class Singleton01 { // 静态变存储唯一的实例化对象 private static final Singleton01 INSTANCE = new Singleton01(); // 构造器私有化 private Singleton01() {} // 提供唯一的实例化对象 public static Singleton01 getInstance() { return INSTANCE; } } 像这样子实现单例模式，似乎是已经足够了。但是这样子做的效率不是非常高，因为当我们创建这个类的时候，无论有没有使用到这个类的实例都会产生这个对象，所以说这样子的单例模式的代码不具有懒加载性，需要改进。不过值得鼓励的是，这样的代码在多线程的模式下，不会产生任何的混乱，这也算是他的一个优点吧。 输出结果： singleton1:1534030866singleton2:1534030866 懒汉式public class SingletonTest02 { public static void main(String[] args) { Singleton02 singleton1 = Singleton02.getInstance(); Singleton02 singleton2 = Singleton02.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton02{ private static volatile Singleton02 INSTANCE; private Singleton02() { } public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } } 代码说明： volatile关键词？ 这个关键词C++中也有使用，但是也是非常的少见，基本上没有人用。 被volatile修饰的共享变量，就具有了以下两点特性： 1.保证了不同线程对该变量操作的内存可见性; 2.禁止指令重排序 volatile这个东西基本上都和多线程有关系，这里就不作深究了。 两个if判断和synchronized(Singleton02.class) 为了实现懒加载，我们要做的是在调用getInstance这个方法的时候才去构建这个对象，不过考虑到多线程的情况下。如果直接是这样子写的话 public static Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 这个代码在单线程的情况下是一点问题都没有的。但如果是多线程的环境下，有多个线程同时进入了if语句就会构建许多的对象，这就不是单例模式了，所以说这样的代码不能够使用。 那是不是加个锁就行了呢？ public static synchronized Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 确实是这样子代码确实就能用了，但是又不出现了一个新的问题。线程的同步是要花很多时间的。你一个线程调用这个函数其他的线程都要等你这个线程，这显然是效率太低了。 那行，咋继续改，不给方法加锁，只是给new语句加锁不就完事了嘛。** public static Singleton02 getInstance(){ if (INSTANCE == null){ synchronized(Singleton02.class){ INSTANCE = new Singleton02(); } } return INSTANCE; } 给整个if语句加锁就相当于是给整个方法加锁，所以说是没有用的。这里给new语句加锁。不能说是效率低的问题了，是直接错误的。事实上，完全有可以多个线程同时进入了if语句内，虽然new加锁了，那几个进入if语句的线程都会执行new语句，破坏了单例模式。 那怎么改呢？这就到了我们代码中的那个双重检查锁了。 public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } 这时虽然也会有多个线程进入if语句，但是里面还有一个带锁的if，这时第一个线程进入创建对象之后，后面的线程因为if的判断就无法创建对象了，实现了单例模式。 要非常注意的是，前面的INSTANCE要声明为volatile（JDK5以后的版本），不然这个模式使用的失败的。这里我去看了极客班的C++的设计模式的教程，如果没有volatile关键词的话，这个是错误的是不能够使用的。为什么呢？在INSTANCE = new Singleton02()这个语句中，正常我们会想这个应该会先分配内存，然后开始构造函数，再然后把地址赋给INSTANCE。但是由于编译器的优化以及各种其他的情况下，任何语言可能都不是这样子的。大多数情况下，可能是先分配内存，然后直接赋地址，最后再构造函数，也可以是先赋地址，然后再怎么怎么样的。这种情况被称为reorder。这是如果有一个线程进入第一个if，发现你已经赋给地址了，已经不是空了，所以直接就返回，但是构造函数还没有开始启动，这是会发生什么错误是不用说了。加上了volatile之后就是告诉编译器，别给我优化，别给我整这些reorder。C++11当中也引入了这个问题的解决方案，不过确实是有点儿复杂，这里就不多说什么了。 输出结果： singleton1:1534030866singleton2:1534030866 静态内部类使用静态内部类的性质来实现线程的同步。静态内部类中的静态数据只有被类第一次被使用到的时候创建，而且这个还是线程安全的，这都是由JVM来保证的。所以说这种方法也是非常好滴。代码也很易懂，不用做什么说明了。 public class SingletonTest03 { public static void main(String[] args) { Singleton03 singleton1 = Singleton03.getInstance(); Singleton03 singleton2 = Singleton03.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton03{ private Singleton03() {} // 使用静态内部类 private static class SingletonInstance { private static final Singleton03 INSTANCE = new Singleton03(); } public static Singleton03 getInstance() { return SingletonInstance.INSTANCE; } } 输出结果： singleton1:664223387singleton2:664223387 枚举式使用了JDK1.5中添加的枚举来实现单例模式。不仅以及避免多线程同步的问题，而且还可以防止反序列化创建新的对象。而且这种方法也是《Effective Java》中推荐的方法。 public class SingletonTest04 { public static void main(String[] args) { Singleton04 singleton1 = Singleton04.INSTANCE; Singleton04 singleton2 = Singleton04.INSTANCE; System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } enum Singleton04 { INSTANCE; } 这个方法可谓是简单而又粗暴，而且枚举类也是类，里面也可以有各种方法，也可以有private数据等。这里就不展开对Java中enum的说明了。 输出结果： singleton1:1534030866singleton2:1534030866 C++中的单例模式// ... class lock { public: lock(); lock(lock const &amp; l); ~lock(); lock &amp; operator =(lock const &amp; l); void request(); void release(); // ... }; lock::lock() { // ... } // ... lock::~lock() { // ... } // ... void lock::request() { // ... } void lock::release() { // ... } // ... // assumes _DATA_TYPE_ has a default constructor template&lt;typename _DATA_TYPE_&gt; class singleton { public: static _DATA_TYPE_ * request(); static void release(); private: singleton(); singleton(singleton&lt;_DATA_TYPE_&gt; const &amp; s); ~singleton(); singleton&lt;_DATA_TYPE_&gt; &amp; operator =(singleton&lt;_DATA_TYPE_&gt; const &amp; s); static _DATA_TYPE_ * pointer; static lock mutex; // ... }; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; template&lt;typename _DATA_TYPE_&gt; lock singleton&lt;_DATA_TYPE_&gt;::mutex; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::request() { if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::pointer = new _DATA_TYPE_; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } return singleton&lt;_DATA_TYPE_&gt;::pointer; } template&lt;typename _DATA_TYPE_&gt; void singleton&lt;_DATA_TYPE_&gt;::release() { if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { delete singleton&lt;_DATA_TYPE_&gt;::pointer; singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } } template&lt;typename _DATA_TYPE_&gt; singleton&lt;_DATA_TYPE_&gt;::singleton() { // ... } // ... int main() { int * s; s = singleton&lt;int&gt;::request(); // ... singleton&lt;int&gt;::release(); return 0; } 这个代码着实有点儿难懂，而且我现在还没有接触到C++中的多线程。所以说，代码先放在这儿吧。C++真的是一门高深莫测的语言！ Java库中的单例模式Java.lang.Runtime /** * Every Java application has a single instance of class * {@code Runtime} that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the {@code getRuntime} method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since 1.0 */ public class Runtime { private static final Runtime currentRuntime = new Runtime(); private static Version version; /** * Returns the runtime object associated with the current Java application. * Most of the methods of class {@code Runtime} are instance * methods and must be invoked with respect to the current runtime object. * * @return the {@code Runtime} object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don&#39;t let anyone else instantiate this class */ private Runtime() {} //..... } 可以看到这个使用的第一个，典型的饿汉式的单例模式。因为这个类不需要多线程，所以也没有必要使用懒汉式，这个饿汉式就是perfect的啦~~ 总结 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须要记住使用对应的获取对象的方法，而不是使用new。 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL Tree]]></title>
    <url>%2F2019%2F07%2F25%2FAVL-Tree%2F</url>
    <content type="text"><![CDATA[AVL TreeAVL Tree的基本介绍AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.来自：GeeksforGeeks 在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。来自：Wikipedia 现在我们看AVL数的中文，自平衡二叉查找树，这个平衡我们从定义中看出来了：任一节点对应的两棵子树的最大高度差为1，那么二叉查找树的概念呢？似乎没有说明，其实二叉查找树(BST)也是一种独立的树结构。那么我们就先来了解一下BST BST的基本介绍二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 比如说上面的这棵树就是一个二叉查找树。 构造BST那么我们该如何构造一颗BST呢？添加节点的时候，当树为空的时候就直接插入节点作为根节点。不然当小于节点且左子树不为空的递归加入左子树，大于节点且右子树不为空的时候加入右子树。左右子树为空的时候就直接插入作为左右子树。 这个思路还是特别的简单的直接按照BST的规则来就完事了。 节点代码实现class Node{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } @Override public String toString() { return &quot;Node [value=&quot; + value + &quot;]&quot;; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } public void add(Node node) { if (node.value &lt; this.value) { if (this.left == null) { this.left = node; return; }else { this.left.add(node); } }else { if (this.right == null) { this.right = node; return; }else { this.right.add(node); } } } //：用于后面的AVT平衡二叉树的操作 public int height() { return Math.max(left == null?0:left.height(), right == null?0:right.height()) +1; } public int leftHeight() { if (left == null) { return 0; } return left.height(); } public int rightHeight() { if (right == null) { return 0; } return right.height(); } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } public Node search(int value) { if (this.value == value) { return this; } if (value &lt; this.value) { return this.left.search(value); }else { return this.right.search(value); } } public Node searchParent(int value) { if (this.left != null &amp;&amp; this.left.value == value) { return this; } if (this.right != null &amp;&amp; this.right.value == value) { return this; } if (value &lt; this.value) { return this.left.searchParent(value); }else { return this.right.searchParent(value); } } /** * 找到左子树上最大的节点的父节点 * @return 左子树上最大的节点的父节点 没有左子树就返回null */ public Node findLeftMaxParentNode() { if (this.left == null) { return null; } Node temp = this.left; if (temp.getRight() == null) { return this; } if (temp.getRight() != null &amp;&amp; temp.getRight().getRight() != null) { temp = temp.getRight(); } return temp; } /** * 找到右子树上最小的节点的父节点 * @return 右子树上最小的节点的父节点， 没有右子树就返回null */ public Node findRightMinParentNode() { if (this.right == null) { return null; } Node temp = this.right; if (temp.getLeft() == null) { return this; } if (temp.getLeft() != null &amp;&amp; temp.getLeft().getLeft() != null) { temp = temp.getLeft(); } return temp; } } 可见由一个数组构造一个BST还是非常容易的。 BST代码实现class BinarySearchTree { private Node root = null; public BinarySearchTree(Node root) { this.root = root; } public BinarySearchTree() { this.root = null; } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; } public void add(Node node) { if (root == null) { root = node; return; } this.root.add(node); } public int height() { return this.root.height(); } public int leftHeight() { return this.root.leftHeight(); } public int rightHeight() { return this.root.rightHeight(); } public void infixOrder() { if (root == null) { return; } this.root.infixOrder(); } /** * 搜索节点 缺点是重复的值会出现问题，值不能重复 * @param value 要查询的值 * @return 返回找到值的当前节点 找不到就返回null */ public Node search(int value) { if (root == null) { return null; } return this.root.search(value); } /** * 搜索父节点 缺点是值不能重复 * @param value * @return 返回找到值的父节点， 找不到就返回null */ public Node searchParent(int value) { if (root == null) { return null; } if (root.getValue() == value) { return null; } return this.root.searchParent(value); } public Node findLeftMaxParentNode() { return root.findLeftMaxParentNode(); } public Node findRightMinParentNode() { return root.findRightMinParentNode(); } /** * 删除节点 * @param value * @return */ public boolean delNode(int value) { Node node = search(value); Node parent = searchParent(value); if (node == null) { return false; } if (parent == null) { if (root == null) { return true; }else { //：要删除的节点就是根节点 Node leftMaxParentNode = findLeftMaxParentNode(); // System.out.println(leftMaxParentNode.getRight().getValue()); if (leftMaxParentNode == null) { root = root.getRight(); return true; }else { if (leftMaxParentNode == root) { this.root.setValue(this.root.getLeft().getValue()); this.root.setLeft(null); return true; }else { this.root.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } } // 是一个叶子节点 if (node.getLeft() == null &amp;&amp; node.getRight() == null) { if (parent.getLeft() == node) { parent.setLeft(null); }else { parent.setRight(null); } return true; } // 只有一个右子节点 if (node.getLeft() == null) { if (parent.getRight() ==node) { parent.setRight(node.getRight()); return true; }else { parent.setLeft(node.getRight()); return true; } } if (node.getRight() == null) { if (parent.getRight() == node) { parent.setRight(node.getLeft()); return true; }else { parent.setLeft(node.getLeft()); return true; } } // 有两个节点的 Node leftMaxParentNode = node.findLeftMaxParentNode(); if (leftMaxParentNode == node) { node.setValue(node.getLeft().getValue()); node.setLeft(null); return true; }else { node.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } 可以看到上面的代码还是特别的多的，因为这个代码都是我学习的时候写的，这里就直接复制过来了。里面很多的方法都是为了AVL来写的。其实里面有几个函数还是比较难写的，比如那个删除节点的那个函数我就写了不少的时间，不过，这里这个问题都不是重点了。我们主要说的是AVL树。 从BST到AVL虽然说BST是蛮好的，中序遍历一个BST我们就能得到一个有序的数组，这个是多么的方便。但是BST也存在了一些问题。比如说我给定的数组是1 2 3 4 5 6使用这个数组构造BST的时候，我们发现构造出来一个非常奇怪的树。 1 2 3 4 5 6一个如同单链表的BST，但是效率比单链表还要低。有些人会说，我们可以使用中位数作为节点来构造二叉树，但是这个依然是有问题的。 4 3 5 2 6 1 7这棵树是效率高的吗？童谣也不是，效率和单链表其实也差不多。 是什么导致这些BST的效率很低的？因为这些树不平衡，这就可以联系到上面的AVL中关于平衡的定义了。左右子树的高度差不大于1。而且是所有的子树的左右子树的高度差都不大于1。所以说上面的两棵树都不是AVL。 An Example Tree that is an AVL Tree The above tree is AVL because differences between heights of left and right subtrees for every node is less than or equal to 1. An Example Tree that is NOT an AVL Tree The above tree is not AVL because differences between heights of left and right subtrees for 8 and 18 is greater than 1. Insertion Examples: AVL代码实现class AVLTree extends BinarySearchTree { public AVLTree() { this.setRoot(null); } public AVLTree(Node rootNode) { this.setRoot(rootNode); } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } //：左旋转， 当左子树的高度小于右子树的高度时候可以降低两者之间的差值，使之成为平衡树 public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } //：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } } 旋转 由BST到AVL左旋转public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } 左旋转是非常的形象的。当右子树的高度大于左子树的高度的时候，我们将树进行左旋转这样就可以平衡左右子树之间的高度之差。 如何左旋转： 以当前节点（根节点）值构造一个新的节点。 新节点的左指针指向根节点的左子树 新节点的右指针指向根节点的右子树的左子树。 根节点的左子树指向新节点。 将根节点的右子树的值赋给根节点 根节点的右指针指向根节点的右子树的右子树 这个看起来可能很懵逼，不过看着下面的图基本上就可以理解了。理解之后你也会发现这个这个左旋转会存在一些问题。 右旋转//：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } 右旋转与左旋转类似，这里不再赘述、 恐怕你已经发现了问题，就是原本是1 3的树经过左旋转之后会变成 3 1。 这是如果再使用右旋转又会变成1 3。这个是非常有问题的。那么问题出在了那么了呢？ 我当我们进行右旋转的时候，们将根节点的右子树树指向的是新的节点，新节点的左子树指向的是根节点的左子树的右子树，那么如果根节点的左子树的左子树的高度小于其左子树的右子树的高度上呢？这时就会引发这个问题。此时我们虽然是想右选择的。但是右子树上的新的节点的左子树连接这那个比较大的根节点的左子树的右子树，这时旋转之后右子树就会变得高，不会形成一个AVL。此时需要平衡一下根节点的左子树，使左子树先来一次左旋转 左旋转也是类似的道理。因此需要将左右旋转结合起来写一个新的函数。 左右旋转结合public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } 这样我们的AVL就完成了，上面的代码都已经做了说明，不想说了。而且这种二叉树的问题，说明是真的难说，还是自己拿一个笔多画一画就完事了，画着画着就可以理解其中的大智慧了。 上面的图可能看起来有点儿懵逼，不过我感觉画的特别的形象。主要讲了旋转的事情。要结合上面的代码一起进行消化理解吸收。 总结这个讲的稍微的敷衍，不过也没有办法，我主要想说的就是AVL的旋转而已，但是又是用语言难以理解的，于是上外网盗了一些图片过来辅助理解，不知道下次这些图片会不会么得了，嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sunday字符串匹配算法]]></title>
    <url>%2F2019%2F07%2F25%2FSunday%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Sunday字符串匹配算法Sunday算法的基本介绍字符串匹配的算法其实之前就已经说过一个KMP算法了，不过现在我还是有点儿不理解KMP算法中next数组中的精髓。其实关于字符串匹配的算法基本有以下的四种。BF算法，这个就是我们在说KMP算法中的那个暴力匹配的那个算法。其次就是KMP算法，也就一种比较难以理解的算法。然后是BM算法，据说是KMP算法的优化，不过实在是恐怖，我看着也十分的复杂，根本没有看的兴趣。最后一个就是Sunday算法，且不论这个算法到底怎么样，就凭这个算法的名字也要努力学习吖。Sunday~多暖的名字吖。关键是我听说Sunday算法简单高效易理解！！！ Sunday算法的基本思路Sunday算法和BM算法稍有不同的是，Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1； 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。 可以说这个思路是非常的亲民了。 下面举个例子来了解一下Sunday算法: 参考文章：字符串匹配之Sunday算法 由此可见在这个例子中，Sunday算法的效率还是非常高的，不过也可以看出来，Sunday算法也是有一点儿不稳定的。如果每次都发现后面的那个元素和最后一个相同，那么这个就变成了BF暴力匹配的算法了。 代码实现这里博主使用的是Java，那我就不使用Java，用C++吧，我还是喜欢我的vscode。。。蛤蛤蛤 /** * Sunday字符串匹配算法 */ #include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; const int ASCII_SIZE = 128; int sunday(string str, string sub) { int strLength = str.size(); int subLength = sub.size(); int move[ASCII_SIZE]{0}; for (size_t i = 0; i &lt; ASCII_SIZE; i++) { move[i] = subLength + 1; } for (size_t i = 0; i &lt; subLength; i++) { move[sub[i]] = subLength - i; } int i = 0; int j = 0; while (i &lt;= strLength - subLength) { j = 0; while (str[i + j] == sub[j]) { j++; if (j &gt;= subLength) { return i; } } i += move[str[i + subLength]]; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABDE&quot;; int index = sunday(str, sub); // cout &lt;&lt; sub &lt;&lt; endl; // cout &lt;&lt; str.substr(index, sub.length()) &lt;&lt; endl; cout &lt;&lt; (sub == str.substr(index, sub.length()) ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 代码说明： ACSII_SIZE和move是什么意思？ ACSII_SIZE常用的字符有128个（键盘上可以找得到的），还有另外的128个是找不到的，所以这里我们只使用128而不是256。说到Sunday算法规则的时候我们也提到了。每次匹配失败往后移动多少位完全是取决于匹配失败时子串对应的后一个字符。（可以看上面的图进行理解），所以说每个字母都对应了一个移动的位数。我们可以用一个数组来存储移动的位数。比如说字母a要移动六位就是——move[‘a’] = 6 也就是 move[97] = 6（a对应的ascii值是97） 第一个for循环？ 当字母没有出现的时候，移动位数 = 模式串长度 + 1 第二个for循环 当字母出现的时候， 移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。不过上面说的是最右出现的位置，这里没有考虑啊。此言差矣，其实考虑了，i是从左到右进行覆盖的，如果出现了重复的字符，move数组里面存放的肯定是最右面的那个字符对应的移动位数。 i, j与while循环 i表示的指向主串的开始的位置。j表示的指向字符正在匹配的字符的位置。注意：这里i并不是指向当前正在比较的字符的位置。当前主串中正在匹配的字符的位置是i+j。每次匹配失败的时候，i向后面移动相对应的位置。j重置为0重新进行比较。 总结不得不说，这个Sunday算法真的简单易理解，关键代码还很好写，效率也非常高。这特喵的谁还看那个什么KMP算法啊。那个啥BM算法反向比较致敬韦神我是更不可能去看的了。不管了，反正Sunday算法赛高就完事了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与回溯]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[递归与回溯关于递归与回溯其实之前我们已经遇到了好多的递归的问题了，比如说动态规划里面的就用到了不少的递归，那种递归也可以转换成为递推。但是这里我们讲的是递归与回溯。何为回溯？ 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 可以看出来递归其实是回溯的一个实现条件，一个算法既然和递归联系起来了，那免不了麻烦的事情，回溯法也是如此，需要我们对递归有着深层次的理解，才能够游刃有余的掌握。 看一下网上对回溯法的一些说明： 回溯法一般都用在要给出多个可以实现最终条件的解的最终形式。回溯法要求对解要添加一些约束条件。总的来说，如果要解决一个回溯法的问题，通常要确定三个元素： 选择。对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列。 条件。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。 结束。当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。 对于回溯法来说，每次递归调用，很重要的一点是把每次递归的不同信息传递给递归调用的函数。而这里最重要的要传递给递归调用函数的信息，就是把上一步做过的某些事情的这个选择排除，避免重复和无限递归。另外还有一个信息必须传递给递归函数，就是进行了每一步选择后，暂时还没构成完整的解，这个时候前面所有选择的汇总也要传递进去。而且一般情况下，都是能从传递给递归函数的参数处，得到结束条件的。 递归函数的参数的选择，要遵循四个原则：1、必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。2、可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。3、最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。 4、要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。 递归与回溯的经典案列迷宫问题基本介绍看到之前回溯的概念我们可以非常轻易的想到迷宫问题。走不通就退回再走的技术为回溯法，迷宫不也是走不通就退回再走吗，非常的符合回溯法的使用条件。 至于迷宫问题的题目我就不多说了，就以下面的数组为例，起始点假如规定在左上角的[1][1]处，目标终点在右下角的[10][25]，请走迷宫，并显示程序所走的路径。下图中0表示路，1表示墙。** map = new int[][] { {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1}, {1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1}, {1,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,0,0,0,1}, {1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1}, {1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1}, {1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1}, {1,0,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1}, {1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1}, {1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} }; 思路分析我们很容易想到回溯但是到底如何回溯呢？我们要告诉程序如何去走这个迷宫，第一点就是，当四条路都可以走的时候我们怎么走？这是最关键的，我们要给程序设定一个初识的目标，遇到多路口先走什么。 0 0 x 0 0这时我们可以规定一个策略就是先走右面，如果右面不通再走下面，如果再不通就走上面，如果还是不通就走上面。 使用→↓←↑的策略进行这一场的迷宫游戏。 那么有没有可能出现这样一种情况，四条路都不通。——怎么可能四条路都不通，四条路都不通你是怎么进来的？？？ 唉~你错了，还真的有四条路都不通的情况，比如如下的图。 ↓ 1 0 1 1 x 1 1 1 1不对啊，这条路上面不是通的吗？往上走不就完事了吗？但是我们是就是从上面下来的，还能再回到上面去吗？所以我们有必要把我们走过的路进行标记比如标记为2。如果走路的这个路确定是死路了，我们还可以将他标记为3，以和我们走过的路正确的路径进行区分。如果四周都是墙或者走过的路，那么这条路的递归就结束，回到选择这个递归的那个路口，开始下一条路的递归。这就是回溯的过程这样说可能很难听懂，不过看到了代码可就算是柳暗花明了。 代码实现处于路口(迷宫的某一个点)时找路的代码// 递归与回溯 private boolean findWay(int i, int j) { // count++; // 只有走到了目标终点的位置这个函数才会返回true if (map[map.length - 2][map[0].length - 2] == 2) { return true; } else { // == 0 代表这条路还没有走过 if (map[i][j] == 0) { // 设为2 假定这条路可以走了 map[i][j] = 2; // 找路的策略是： // 向下 -》 向右 -》 向上 -》 向左 if (findWay(i + 1, j)) { return true; } else if (findWay(i, j + 1)) { return true; } else if (findWay(i - 1, j)) { return true; } else if (findWay(i, j - 1)) { return true; } else { // 四条路都走不通了 map[i][j] = 3; return false; } } else { // 不是0可能是 1 2 3，反正就是不能走这条路 return false; } } } 代码说明： 这个函数的返回值是什么意思？ 函数的返回值是boolean，他只有在一个情况上返回的 是true，那就是走到了目标终点了。虽然下面也有几个return true，但是那些return true都是依靠if里面为真，而if里面为真只是依靠找到终点了。 下面的if为0是什么意思？ 让我们找路给我们的坐标是i，j如果给定的就是一堵墙，走过了的或者死路，当然要返回false，让它进行下一个路口的探索。也就是下右上左的次序进行走路（其实什么顺序都可以啦，没什么太重要的，都可以走到终点的）。 最后的那个else returnfalse是？ 这说明前面的四个递归返回的都是false，说明什么？四条路都是走不通的，那么就把这个点置为死路点，标记为3。 那这个不是只有一个点是3吗？？死路就这是一个点？ 不是的，当这个点被置为死路3的时候，递归会回溯。比如下面的这个路。 1 2 1 1 3 1 1 1 1（1,1）被标记为3之后，可别忘了(1,1)点是从(0,1)点走过来的。走路的顺序是下右上左。(0,1)点的下面返回false，于是走右面，不通，走上面，走过了，走左面，不通，于是(0,1)也被置为了3。 所以说被置为3的是通往死路的那一整条路啦~~递归就是这么神奇。 这个findWay函数写完了，直接调用findWay(1,1)就可以进行迷宫的探索了。（我们规定的是1,1是起点了） 迷宫的输出结果==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # X X X X # # # # # # # # # X # # # X # # X X X X X # # # # # # # # X # # # # # X # # N # # # X # # # # # # # # X # X X X # X X X # # # # X # # # # # # # # # # X # X # X # X X X N N # # X # # # # # # # X X X # X # X # # # N # # X # # # # # # # # # # # X # X # # # # # X # # # # # X X X X X X X # X # # # # # X # # # # # # # # # X # # # # # # X X # # # # X X X X X X X X X # # # X X X X X X X X # # # # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 这里我们使用#表示墙，X表示正确的路径，N表示走过的死路。空白的区域就是没有走过的路。可见这个下右上左的策略还是蛮不错的，走过的死路是比较上的。如果我们换成左上右下，那么结果又是如何呢？ ==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # N N N N X X X X X X # # N N N N N # # N # # # # # X # N N # # X # # N N X X X # # N # N # # N # # # N N X # # # # # X # # N # # # X # # N # N N N N # # # # # X # X X X # X # # # # X # # N # # # # # # # N N # X # X # X # X # # X # # N # N # N N # # N N # X X X # X # X # # # # # X X N N # N # # N # # N # # # # # # X # X # # N # # # X X # # # N N N N # # N X X X X X X X # X # # N # # # X X # # # # # # N # # # X # # # # # # X X # # N # # N N X X X X X X X X # # # X X X X X X X X # # # N N N N # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 可以看出走过的死路是非常多的，但是无论怎么说都是可以到达终点的。毕竟我们这个题目是从左上角到右上角，我们选定的策略肯定是选右下啊。 在不知道起点终点的时候，我们可以四个策略都使用一下，看看哪个策略走的次数是最少的（有效的路，不算死路)。前面我的代码中也使用了count来计数，就是为了这一点。这样我们基本就可以确定走迷宫的最优路径了。 八皇后问题基本介绍这个题目可以说是非常著名了，我学python的时候就在研究这个问题，但是当时怎么研究都研究不出来到底怎么解决这个问题。递归这种事我们都是不敢想的（递归那该有多难啊），回溯根本不知道回溯是什么玩意。不过现在有个递归和回溯这个武器，八皇后问题可以说只用几行代码就完事了。看一下百度百科对八皇后问题的解释 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。 现在有个计算机，什么八皇后，就是八十皇后都么得问题。 思路分析上面也说了，八皇后问题同样是回溯算法的典型案列。那么这个问题该如何回溯呢？迷宫问题是路走不通了我退回去重新走其他的路，那八皇后也很好理解了。皇后放不了了，我换其他地方重新放。 我们可以选择一行一行的放置皇后，这个显然不会对结果产生什么影响，你要是乐意一列一列放也是可以的。 大多数人解决这个问题都喜欢使用二维数组，第一个表示行，第二个表示列，数组的值表示有没有放置过皇后，我承认这样可行。但是真的有必要使用二维数组吗？我们使用一维数组不可以解决这个问题吗？比如使用一个一维数组int[8]。int[0]表示第一行皇后所在的列，我们只要按顺序去放置int[1],int[2]里的值就完事了，这不是很好喵~ 下面就该说说八皇后的回溯了。首先我们也要和迷宫一样确定如何放置皇后，这里其实很容易，直接从第一列开始依次往后尝试呗。（这也是正常人的思想）如果某一列不可以放置皇后(要写个函数进行判断)，就往后放，如果已经是最后一列了。就直接返回false。回到上面的一行(回溯算法)，重新按顺序放置皇后。如果可以放置，就进入下面一行放置皇后，如果第八行的皇后都放置OK了就返回true，这是一种皇后的放置方法已经完成了，不过我们需要循环找到所有的皇后的放置的方法。 代码实现判断是否可以放置皇后private boolean isValid(int n) { ++count2; for (int i = 0; i &lt; n; i++) { // 在同一列或者说是在同一个斜线上 if (map[i] == map[n] || Math.abs(map[n] - map[i]) == Math.abs(n - i)) { return false; } } return true; } 代码说明： count2++ 这个是后面用来统计进行了多少次的皇后判断用的。 map[i] == map[n]? 我们说过了一维数组的值表示的是皇后所在的列，如果map[i] == map[n]那么就说明放置的皇后在同一列，返回的false。 Math.abs(map[n] - map[i]) == Math.abs(n - i)? 这个代表的意义就是列差的绝对值是等于行差的绝对值的。这个我都是使用斜率来理解的。斜率为1或者-1，那么两个 皇后就是在一天斜线上！斜率为其他值的就不算一天直线了吧，国际象棋的规则明白吧老弟~ 这里我们只是和n前面那的皇后进行比较，那么后面呢？ 后面个锤子啊，我们放置皇后的顺序是从第一列一次到第八列，后面的皇后还都没有放呢，当然不用来比较。 在某一行开始放置皇后private void check(int n) { if (n == max) { // 输出解决方案 System.out.printf(&quot;%-3d&quot; + &quot;: &quot; + Arrays.toString(map) + &quot;\n&quot;, ++count); return; } for (int i = 0; i &lt; map.length; i++) { map[n] = i; if (isValid(n)) { check(n + 1); } } } 代码说明： 我只知道System.out.println，那个printf是什么鬼？ 没学过c吗？printf是Java中用于格式化输出的语句，%-3d的意思就是三位数的整数，左对齐。 后面的for循环是？？？ 如果不加上for循环的话我们啥都得不到，而且肯定是前面几个皇后的列值都很小的。比如说没有for循环的时候我们使用check(0)就是放置第一个皇后，第一个皇后置为i(一开始也就是0，因为没有for循环)，然后看在i处放置合不合理。如果合理就开始放置下面一个皇后，但是倘若是不合理呢？？不合理是不是直接就没了，程序也不会尝试其他的路径了。 如果加上这个for循环。合理自然很好，一路往下走。假如遇到了不合理的。（就算是合理的也会往后的）那for循环就会执行给我们尝试后面的列是否可行。如果for循环结束了都是不可行的。那么这一层的递归就结束了。就会返回上一层的递归。（就算这个合理了也是会返回上一层的递归的），在上一层寻找其他的放置皇后合理的地方。就这样一直回溯就可以找到八皇后的所有的解了。递归是真的神奇~~比如之前一直都不理解的归并排序。 测试代码public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;Slove N Queue Problem: &quot;); int num = scanner.nextInt(); Queue8 queue8 = new Queue8(num); System.out.println(&quot;=====THE SOLUTION OF &quot; + num + &quot;QUEUE PROBLEM=====&quot;); long start_time = System.currentTimeMillis(); queue8.check(0); long end_time = System.currentTimeMillis(); System.out.println(); System.out.println(&quot;=====================SUMMARY=====================&quot;); System.out.println(&quot;THE NUMBERS OF &quot; + num + &quot;QUEUE SOLUTIONS IS &quot; + count); System.out.println(&quot;THE NUMBERS OF JUDGES IS &quot; + count2); long time = end_time - start_time; System.out.println(&quot;THE TIME USED IS &quot; + time + &quot;MS&quot;); } 8皇后 =====================SUMMARY===================== THE NUMBERS OF 8QUEUE SOLUTIONS IS 92 THE NUMBERS OF JUDGES IS 15720 THE TIME USED IS 1MS这里的解决方案没有输出，因为太长了，顶不住啊。由此可见是92种，看来天才高斯也有错误的时候啊~~嘤嘤嘤 12皇后 =====================SUMMARY===================== THE NUMBERS OF 12QUEUE SOLUTIONS IS 14200 THE NUMBERS OF JUDGES IS 10103868 THE TIME USED IS 154MS20皇后 ..... 等了好长的时间（20秒）都没有输出，这个判断函数执行的次数我感觉肯定有上百亿次。。。估计我再不退出就可能 会发生栈溢出了。。。还是不等这个输出结果了吧。上面的两个问题都是我亲手完成和研究的问题，不过递归和回溯算法的题目不止如此，下面看几个网上看到的几个题目。 括号排列基本介绍 给出n对括号，求括号排列的所有可能性。 思路分析对于回溯法来说，必须齐备的三要素： 1、选择。在这个例子中，解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号； 2、条件。在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于0才能放入左括号。这里if的顺序会影响输出的顺序，但是不影响最终解； 3、结束。这里的结束条件很显然就是，左右括号都放完了。 回溯法中，参数的设计是一大难点，也是很重要的地方。而递归参数的设计要注意的四个点： 1、用了一个空字符串来作为临时变量存储不完整解； 2、用了一个ArrayList results来存放符合要求的解。在后面可以看到，不一定要这样做，也可以直接打印结果； 3、把leftnum和rightnum传入给递归函数，这样可以用于判断结束条件； 代码实现import java.util.ArrayList; public class BackTracking { public static void main(String[] args) { int n = 3; int leftnum = n, rightnum = n;// 左括号和右括号都各有n个 ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();// 用于存放解空间 parentheses(&quot;&quot;, results, leftnum, rightnum); for (String s : results) System.out.println(s); } public static void parentheses(String sublist, ArrayList&lt;String&gt; results, int leftnum, int rightnum){ if (leftnum == 0 &amp;&amp; rightnum == 0)// 结束 results.add(sublist); if (rightnum &gt; leftnum)// 选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist + &quot;)&quot;, results, leftnum, rightnum - 1); if (leftnum &gt; 0) parentheses(sublist + &quot;(&quot;, results, leftnum - 1, rightnum); } } 代码说明： parentheses函数的参数的说明 @param sublist 尚未完成的括号串 @param results 存放已经完成的括号串的字符串 @param leftnum 左括号的数量 @param rightnum 右括号的数量 回溯算法如何实现的？ 其实这个算法我倒是感觉没有什么回溯的味道，就是单纯的递归而已。当剩下的左括号和右括号的数量都为0的时候，就是一条递归终止，然后将结果放入集合中。 当剩下的右括号的数量比较多的时候（放入的左括号的数量大于放入的右括号的数量）此时就放入右括号。（如何剩下的右括号的数量小于等于左括号的数量放入右括号是非法的） 当还有剩下的左括号，就放入左括号。 这或许有点不好理解，下面的两个条件其实是在同步进行的。比如说 比如要放四个括号，遇到了这样的字符串 (()( 经过第二个条件的判断产生的递归的分支是 (()() 经过第三个条件的判断产生的递归的分支是 (()((通过了上面的说明就可以理解，不存在少了哪一种情形。每一次的递归都是一种结果。不过，这个算法里面是真的没有回溯这个部分，只是递归而已。 不过作者偏说这个有回溯的部分。 4、这个例子不明显。但是事实上也符合这个条件。可以仔细观察代码，可以发现由于使用了两个if，所以当一次递归退出后，例如从第一个if退出，第二个递归直接递归的是leftnum-1和rightnum，这其实是已经恢复状态了（如果没有恢复状态，那就是leftnum, rightnum-1）。因此不需要人为让他恢复状态。但是恢复状态这点是很重要的，因为回溯法，顾名思义要回溯，不恢复状态，怎么回溯呢。 if(rightnum&gt;leftnum)//选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist+&quot;)&quot;, results, leftnum, rightnum-1); if(leftnum&gt;0) parentheses(sublist+&quot;(&quot;, results, leftnum-1, rightnum); 把这个称为是回溯，确实是有点儿牵强。每一个递归都是这样使用的不是吗？因为每一层递归不在一个栈空间，在同一个栈空间的数据当然是相同的，自然不用人为恢复状态。 数字之和基本介绍 给出一个不重复大于0数字的数组和一个目标，求数组中数的组合的和得到该目标（数字不同组合顺序当做一个解）。 这个和leetcode上的第一题两数之和是有点儿像的，不过这个题目似乎是没有规定这些数的个数是2，那么难度就不是一倍两倍的往上涨了。两数之和可以使用排序双指针轻松解决，不过这个题目使用排序双指针似乎有点儿困难。 思路分析代码实现 public class BackTracking { public static void main(String[] args){ int[] num=new int[]{2,3,7,6，4,9,1}; int target=9; find(num, target, &quot;&quot;); } public static void find(int[] num, int target, String temp){ if(issolution(temp,target)){ System.out.println(temp); return; } for(int i=0;i&lt;num.length;i++){ if(num[i]!=-1){//如果取过这个数字了，就置为-1 int k=num[i]; num[i]=-1; find(num, target, temp+k); num[i]=k; // 恢复取出的数据的值。 } } } public static boolean issolution(String temp, int target){ boolean result=false; int count=0; for(int i=0;i&lt;temp.length();i++){ count=count+Integer.valueOf(temp.charAt(i)+&quot;&quot;); } if(count==target) result=true; return result; } } 代码说明： for循环里面？ 其实这一整块的代码只有for循环的里面是需要说明的。首先先记录一下放入组合中的那个数据，然后将之置为0.然后再次递归，这样在那个递归的find里面数组的num[i]就为-1了。在后面将i再次恢复到-1从而不影响其他的递归空间。下面的那个issolution函数也非常的容易理解。 代码存在的问题首先这个代码不是我写的，但是我再研究了多道递归的题目的时候还是看出了一个代码其实还是有不少的问题的。 首先我们看一下这个问题的输出如何： 234 27 261 243 216 324 36 342 72 621 63 612 423 432 9 126 162不得不说这个结果的输出就是非常乱的，首先没有任何的分隔符告诉我是那些数的组合，其次，全是重复！！！这个算法其实就是暴力破解法，效率是特别的低的。可以改进的空间非常大！ 首先输出得改善，第二得去重复，第三要考虑到效率问题。针对这三个点，我重写了这个代码。 重写代码public class BackTracking2 { public static void main(String[] args) { int[] num = new int[] { 2, 3, 7, 6, 4, 9, 1}; Arrays.sort(num); int target = 9; // find(num, 0, target, &quot;&quot;); find(num, target); } public static void find(int[] num, int loc, int target, String temp) { int result = issolution(temp, target); if (result == 0) { System.out.println(temp); return; } if (result &gt; 0) { // 和都已经大于target了， 再增加已经没有任何的意义了 return; } for (int i = loc; i &lt; num.length; i++) { if (num[i] &lt;= target) {// 如果取过这个数字了，就置为-1 find(num, i + 1, target, (temp + num[i]) + &quot; &quot;); } else { return; } } } // 可以重载一下，是调用更加简洁 public static void find(int[] num, int target){ find(num, 0, target, &quot;&quot;); } public static int issolution(String temp, int target) { int count = 0; for (int i = 0; i &lt; temp.length() / 2; i++) { count = count + Integer.valueOf(temp.charAt(2 * i) + &quot;&quot;); } if (count &gt; target) return 1; if (count &lt; target) return -1; return 0; } } 输出结果： 1 2 62 3 42 73 69 可见这个输出结果就是很舒服的 代码说明： 关于输出 输出添加了空格主要就是修改了上面的23,31,32这几行，这个修改起来相对简单容易理解。 关于重复 其实重复这个问题也蛮好解决的，只要好马不吃回头草就行了。你想想看比如2，3，7，6假如我挑选的是已经把所有的包含2的都挑选完了，那么在我挑选3的时候，为何还要继续挑选前面的2呢？我们只需要给函数加上一个参数loc，告诉他从什么位置开始挑选就可以完美地解决这个问题了。 关于效率 原先的真的是暴力算法，一点效率都没有。首先是作为自以为完美的将num[i]置为-1，然后再还原的操作，虽然说的确是很秀但是真的没有必要。还有issoluation函数的返回值，完美可以返回大于小于和等于，然后利用大于可以直接结束递归。还有就是将num数组进行排序，虽然说不排序也可以做，但是排序之后的效率将变得高的多，而且还可以在函数中利用num[i] &gt; target就直接结束这个函数（num数组是递增的），可以说是提高了效率。 不过说修改之后的函数就没有问题了，这也是不可能的，我认为还是可以继续改进的，不过做到这一块已经可以说是基本上差不多了。 字符串排列基本介绍 给一个字符串，给出他的所有排列 什么叫字符串的所有的排列呢？就比如说给定的字符串是abc，他的所有的排列就是 abc acb bac bca cab cba总共有 A33 = 3! = 3 × 2 × 1= 6 种 思路分析这个其实也是一种放东西类型的题目，和上面的那一个题目倒是有一点儿类似，不对，应该说是有点儿儿完全一样，就是上面的那一个题目改进前的那个算法。毕竟这玩意是需要重复的嘛。 代码实现public class StringArrange { public static void main(String[] args) { String s = &quot;abc&quot;; Arrange(s, &quot;&quot;); } public static void Arrange(String s, String temp) {// 参数设计地尽量地简洁 if (s.length() == 0) { System.out.println(temp); return; } for (int i = 0; i &lt; s.length(); i++) { String news = s.substring(0, i) + s.substring(i + 1, s.length());// 去掉String中的某个字母 Arrange(news, temp + s.charAt(i)); } } } // 既然你要说参数设计要简洁的话为啥不给这个函数一个重载呢？ public static void Arrange(String s){ Arrange(s, &quot;&quot;); } // 然后直接这样子调用不就完事了 String s = &quot;abc&quot;; Arrange(s); 输出结果： abcacbbacbcacabcba 代码说明： 这个其实没有什么要说明的地方，不过要注意的一点是java当中substring的第二个参数是结束的位置（不包括），C++中的substr()的第二个参数是子串的长度。关于这一点，我也算是佛了！ 还有一个与之比较类似的题目。 新字符串给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 这个题目可以直接用前面的回溯算法，而且真的特别的简单，至于效率，应该不是很快吧。不过真的是特别容易理解。 代码实现public class NewStr { public static void main(String[] args) { String a = &quot;ak47A&quot;; // newStr(a, 0, &quot;&quot;); newStr(a); } public static void newStr(String a, int i, String temp) { if (i == a.length()) { System.out.println(temp); return; } if (Character.isAlphabetic(a.charAt(i))) { String temp2 = new String(temp); temp += a.charAt(i); newStr(a, i+1, temp); if (Character.isLowerCase(a.charAt(i))) { temp2 += Character.toUpperCase(a.charAt(i)); }else { temp2 += Character.toLowerCase(a.charAt(i)); } newStr(a, i+1, temp2); }else { temp += a.charAt(i); newStr(a, i+1, temp); } } public static void newStr(String a){ newStr(a, 0, &quot;&quot;); } } 输出结果： ak47Aak47aaK47AaK47aAk47AAk47aAK47AAK47a 代码说明： 这个代码实在是太容易理解了，不用说什么了。里面用到了几个库函数，看函数的名字大概就可以知道函数的意思了。 我看到博主使用的代码有点沙雕，不过思路是完全一样子的（我可没有看这个函数起名都花里胡哨的代码，dfs。。。to784To？？？我佛了）。这里就直接说我上面的那个算法就完事了，至于博主的算法直接贴出来就完事了。 public void dfs(String pre, String S, List&lt;String&gt; res, int index) { if (index == S.length()) res.add(pre); else { char ch = S.charAt(index); if (!Character.isLetter(ch)) dfs(pre + ch, S, res, index + 1); else { // 小写字符分支 ch = Character.toLowerCase(ch); dfs(pre + ch, S, res, index + 1); // 大写字符分支 ch = Character.toUpperCase(ch); dfs(pre + ch, S, res, index + 1); } } } public List&lt;String&gt; letterCasePermutation(String S) { List&lt;String&gt; res = new LinkedList&lt;&gt;(); dfs(&quot;&quot;, S, res, 0); return res; } // 测试 public static void main(String[] args) { String S = &quot;a1b&quot;; To784To to784To = new To784To(); System.out.println(to784To.letterCasePermutation(S)); } 子集问题 给定一个集合，求他的所有的子集 就不上什么思路分析了，直接代码 代码实现public class Subsets { public static List&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public static List&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] arr) { ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); subsets(arr, curr, 0); // System.out.println(res); return res; } public static void subsets(int[] arr, ArrayList&lt;Integer&gt; curr, int start) { res.add(new ArrayList&lt;Integer&gt;(curr)); // 如果不这样放，最后就都是空 if (start == arr.length) { return; } for (int i = start; i &lt; arr.length; i++) { curr.add(arr[i]); subsets(arr, curr, i + 1); curr.remove(curr.size() - 1); } } public static void main(String[] args) { int[] arr = { 1, 2, 3 }; subsets(arr); } } 要注意一点的是，放入res的时候，如果不new的话，放入的就是引用，（Java万物都是引用）最后就都会变成空的集合。这一点上C++和Java的区别要尤其的注意。这两门语言名义上说是很像，但是这点差的真的是特别的大。我也是佛了。 总结递归与回溯确实有点儿难以掌握，刚才去leetcode上面看了一题，还是有点儿懵，虽然有了思路 ，但是并不能完全的写下去，唉，还是要多加的训练才能基本掌握这门高深的“通用解题方法”啊。 参考了一点的文章: 回溯算法超通俗易懂详尽分析和例题]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的广度优先和深度优先遍历]]></title>
    <url>%2F2019%2F07%2F23%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的广度优先和深度优先遍历其实之前我们已经学过了二叉树的先序遍历，中序遍历和后序遍历，这些遍历的方式都是几行代码利用递归的方式来实现的。其实这些遍历方式是不怎么符合我们的逻辑的（至少是不符合我的逻辑），不过他们确实的使用简单的算法就可以遍历二叉树的好办法。这不是说这些遍历方式不好（二叉排序树还就是需要中序遍历呢），只是我们还可以学习其他的遍历二叉树的方式。比如下面的广度优先遍历和深度优先遍历。 广度优先 广度优先的基本介绍广度优先遍历（ Breadth-First Search）一般缩写为BFS。 其过程检验来说是对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。对于上面的例子来说，广度优先遍历的 结果是：A,B,C,D,E,F,G,H,I(假设每层节点从左到右访问)。 广度优先的算法实现 先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。 广度优先遍历树，需要用到队列（Queue）来存储节点对象,队列的特点就是先进先出。例如，上面这颗树的访问如下： 首先将A节点插入队列中，队列中有元素（A）; 将A节点弹出，同时将A节点的左、右节点依次插入队列，B在队首，C在队尾，（B，C），此时得到A节点； 继续弹出队首元素，即弹出B，并将B的左、右节点插入队列，C在队首，E在队尾（C,D，E），此时得到B节点； 继续弹出，即弹出C，并将C节点的左、中、右节点依次插入队列，（D,E,F,G,H），此时得到C节点； 将D弹出，此时D没有子节点，队列中元素为（E,F,G,H），得到D节点； 首先构战树节点struct TreeNode { int data; TreeNode* left; TreeNode* right; TreeNode(int val):data(val){ this-&gt;left = nullptr; this-&gt;right = nullptr; } }; 这里就不写二叉树这个类了，就写一个树节点就完事了。 删除树void deleteTree(TreeNode* root){ if (root == nullptr){ return; } if (root-&gt;left != nullptr){ deleteTree(root-&gt;left); } if (root-&gt;right != nullptr){ deleteTree(root-&gt;right); } delete root; } 广度遍历算法vector&lt;TreeNode*&gt; BFSsearch(TreeNode* root) { // 首先将A节点插入队列中，队列中有元素（A） // 队列是先进先出的一种数据结构 queue&lt;TreeNode*&gt; node_queue; // 按广度遍历的算法来保存节点顺序 vector&lt;TreeNode*&gt; result; node_queue.push(root); TreeNode* pop_node; while (!node_queue.empty()) { // 将第一个节点取出，将节点的左右节点放入队列 pop_node = node_queue.front(); result.emplace_back(pop_node); node_queue.pop(); if (pop_node-&gt;left != nullptr) { node_queue.push(pop_node-&gt;left); } if (pop_node-&gt;right != nullptr) { node_queue.push(pop_node-&gt;right); } } return result; } 主方法中的测试代码二叉树的结构： 1 2 3 4 5 6 7 8 int main(int argc, char const* argv[]) { TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;right = new TreeNode(3); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;left-&gt;right = new TreeNode(5); root-&gt;right-&gt;left = new TreeNode(6); root-&gt;right-&gt;right = new TreeNode(7); root-&gt;right-&gt;right-&gt;right = new TreeNode(8); vector&lt;TreeNode*&gt; bfs = BFSsearch(root); for (auto node : bfs) { cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; deleteTree(root); system(&quot;pause&quot;); return 0; } 输出的结果： 1 2 3 4 5 6 7 8 深度优先 深度优先基本介绍深度优先是Depth-First Search（DFS）。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。对于上面的例子来说深度优先遍历的结果就是：A,B,D,E,I,C,F,G,H.(假设先走子节点的的左侧)。 深度优先的算法思路深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。 先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 首先将A节点压入栈中，stack（A）; 将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)； 将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）； 将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）； 将E节点弹出，同时将E的子节点I压入，stack（I,C）； …依次往下，最终遍历完成。 可以看到这个深度优先的算法和广度优先的算法是十分的类似的，一个使用的是队列，一个使用的栈。队列的特点是先进先出，队列的特点是先进后出。 深度优先算法代码实现vector&lt;TreeNode*&gt; DFSsearch(TreeNode* root) { vector&lt;TreeNode*&gt; result; stack&lt;TreeNode*&gt; node_stack; TreeNode* pop_node; node_stack.push(root); while (!node_stack.empty()) { pop_node = node_stack.top(); node_stack.pop(); result.push_back(pop_node); if (pop_node-&gt;right) { node_stack.push(pop_node-&gt;right); } if (pop_node-&gt;left) { node_stack.push(pop_node-&gt;left); } } return result; } 测试代码和上面的基本都是一样的： 二叉树的结构： 1 2 3 4 5 6 7 8 *输出结果: * 1 2 4 5 3 6 7 8 总结二叉树的深度优先及广度优先遍历算法算是二叉树中比较重要的两个算法了。但是深度优先和广度优先这个并不是二叉树中的概念，其实还有其他很多的数据结构及算法都有深度优先和广度优先算法。比如说图的遍历，也有广度优先和深度优先。总之，一点一点去学吧，么得多大的问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法简介]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[贪心算法简介 ​ 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法的基本介绍贪心算法的一般流程Greedy(C) //C是问题的输入集合即候选集合 { S={ }; //初始解集合为空集 while (not solution(S)) //集合S没有构成问题的一个解 { x=select(C); //在候选集合C中做贪心选择 if feasible(S, x) //判断集合S中加入x后的解是否可行 S=S+{x}; C=C-{x}; } return S;贪心算法其实没有一个固定的流程，这点和KMP算法不一样，KMP算法是解决那种特定的问题，但是这个贪心算法是解决那一种问题，适合做出贪心选择的问题： 贪心选择的性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 对于那些不满足贪心选择的问题，我们不可以使用贪心算法来解决。 贪心算法存在的问题 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心算法的例题找零钱问题假如老板要找给我99分钱，他有上面的面值分别为25，10，5，1的硬币数，为了找给我最少的硬币数，那么他是不是该这样找呢，先看看该找多少个25分的，诶99／25＝3，好像是3个，要是4个的话，我们还得再给老板一个1分的，我不干，那么老板只能给我3个25分的拉，由于还少给我24，所以还得给我2个10分的和4个1分。 思路分析这个题目其实非常的简单，估计不学这个贪心算法都是非常容易搞定的，我们想要最少的硬币数，这里存不存在贪心选择呢？其实是很容易看出来的，我们的贪心选择就是尽量找大面额的硬币，能有多少找多少，毕竟有1元的硬币无需担心有早不开这种情况。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; giveMoney(vector&lt;int&gt; m, int target) { int size = m.size(); vector&lt;int&gt; num(size, 0); for (size_t i = 0; i &lt; size; i++) { num[i] = target / m[i]; target = target % m[i]; } return num; } int main(int argc, char const *argv[]) { vector&lt;int&gt; num = {25, 10, 5, 1}; int target = 99; vector&lt;int&gt; result = giveMoney(num, target); std::cout &lt;&lt; target &lt;&lt; &quot;的找钱方案为：&quot; &lt;&lt; std::endl; for (size_t i = 0; i &lt; result.size(); i++) { std::cout &lt;&lt; result[i] &lt;&lt; &quot;枚面值为&quot; &lt;&lt; num[i] &lt;&lt; &quot;的硬币&quot; &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 运行结果99的找钱方案为： 3枚面值为25的硬币 2枚面值为10的硬币 0枚面值为 5的硬币 4枚面值为 1的硬币这个是贪心算法的一个简单的例子，也无需做什么代码说明啦。 活动安排问题设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si&lt; fi。如果选择了活动i，则它在半开时间区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当si≥fi或sj≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。 思路分析其实我有点儿不想认为这个是贪心算法，但是你非要说这个是，我也没办法啦~ 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; arrangeActivity(vector&lt;int&gt; start, vector&lt;int&gt; end) { int total = start.size(); int endFlag = end[0]; vector&lt;int&gt; result; result.push_back(0); for (size_t i = 0; i &lt; total; i++) { if (start[i] &gt; endFlag) { result.push_back(i); endFlag = end[i]; } } return result; } int main(int argc, char const *argv[]) { vector&lt;int&gt; start = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12}; // end数组是有序的 vector&lt;int&gt; end = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; vector&lt;int&gt; result = arrangeActivity(start, end); for (size_t i = 0; i &lt; result.size(); i++) { int index = result[i]; std::cout &lt;&lt; &quot;开始时间：&quot; &lt;&lt; start[index] &lt;&lt; &quot; 结束时间：&quot; &lt;&lt; end[index] &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 我简直不忍心说这个是。。。贪心算法啦~ 背包问题这个问题之前在动态规划的时候说过好像，不过那篇文章中好像没有谈及这个问题，不过我已经写完了好几道背包问题的例题了，下次可以再次写一个动态规划的文章。这里就使用动态规划里面的那个背包问题的题目吧。 0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。 那么问题来了，这个题目可以使用贪心算法来做吗？也就是说这个题目存在贪心选择吗？ 贪心选择1 ： 和找零钱一样，选择最贵的往里面放。 但是这个得到的是最优解吗？很容易得到反例，放入了贵的东西之后，剩余的空间可以会得不到利用。 贪心选择2： 选择轻的往背包里面放。 和上面的选择一样，这个也不能确保是最优解。 由此可见，使用贪心算法无法解决这个问题，还是安心的去选择动态规划吧。。。蛤蛤蛤 均分纸牌有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。 思路分析设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动： 若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆； 若a[i]&lt; v，则将v-a[i]张从第I+1堆移动到第I堆。为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v. 在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？ 我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不变，因此此题使用贪心法可行的。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::cout; using std::endl; using std::vector; int moveCards(vector&lt;int&gt;&amp; cards) { int sum = 0; int count = 0; for (size_t i = 0; i &lt; cards.size(); i++) { sum += cards[i]; } int average = sum / cards.size(); for (size_t i = 0; i &lt; cards.size(); i++) { if (cards[i] != average) { cards[i] += average - cards[i]; cards[i + 1] -= average - cards[i]; count++; } } return count; } int main(int argc, char const* argv[]) { vector&lt;int&gt; cards = {2, 10, 18}; int count = moveCards(cards); cout &lt;&lt; &quot;移动次数：&quot; &lt;&lt; count &lt;&lt; endl; for (size_t i = 0; i &lt; cards.size(); i++) { cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;堆牌：&quot; &lt;&lt; cards[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 代码说明： 乍一看以为这个题目是很难的题目，但是定睛一看，这不是一个沙雕题目吗？特别是有个这个贪心算法的思路之后，这个题目就变得尤为的弱智。 不过，关于这个题目，以及贪心算法还有特别多要注意的地方 一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。 二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。 这个题目找到了合理的贪心选择：如果不等于平均值的话就利用右面的牌堆变成平均值，即使出现了负数问题也不是很大。这个选择很好像，不过要说明这个就可以得到最优解，还是有一点难度的。 加入说这个移动不是限制在相邻的牌堆之间了，这个选择就肯定是一个错误的选择了。所以说贪心算法难，但是代码不是特别的难写，主要就贪心选择有没有选择正确。 最大整数设有n个正整数，将它们连接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 思路分析这个题目我们想要使用贪心算法来做，那么我们就要选择一个正确的贪心选择，那么关于这个题目怎么做贪心选择呢？把大的数放在前面？ 78 123 -&gt; 12378明显不对，把小的数放在前面？这同样都是不对的。对于两个整数 a和b我们要是ab &gt; ba(这里不是乘法)，这样做其实有一个很简单的实现方式，就是利用字符串。和求整数的最大的位数相似(将整数转为字符串然后求得字符串的长度就是整数的长度)我们可以将整数a和b转为字符串然后比较a+b和b+a的大小。 代码实现/** * 设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 * 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。 * 又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 */ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using std::string; using std::to_string; using std::vector; #include &lt;sstream&gt; using std::stringstream; // 也可以使用stringstream来将nums转为string // 将int转为string可以使用stoi， long转为string可以使用stol 转为char* // 就以atoi和atol吧 string maxNum(vector&lt;int&gt;&amp; nums) { // string result = to_string(nums[0]); string result = &quot;&quot;; stringstream ss; ss &lt;&lt; nums[0]; ss &gt;&gt; result; for (size_t i = 1; i &lt; nums.size(); i++) { string plusNum = to_string(nums[i]); if (result + plusNum &gt; plusNum + result) { result += plusNum; } else { result = plusNum + result; } } return result; } int main(int argc, char const* argv[]) { vector&lt;int&gt; nums = {78, 123, 93}; for (auto val : nums) { std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &quot;可以组成的最大的整数为：&quot;; std::cout &lt;&lt; maxNum(nums) &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 也是非常简单的代码不用做什么说明了。 总结贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，(动态规划依赖于子问题的解) 因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。但是不是所有的问题都可以使用贪心算法来解决的，要注意贪心选择是否是正确的，不然太贪心了之后搞得自己人莫得了。贪心算法学了感觉还是有点儿懵，这个算法拓展性真的是太强了，完全就只是一个思路，怎么搞都依赖于你自己的想法。嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-1>0x7fffffff???(黑人问号脸)]]></title>
    <url>%2F2019%2F07%2F22%2F-1%E5%A4%A7%E4%BA%8E0x7fffffff%2F</url>
    <content type="text"><![CDATA[-1 &gt; 0x7fffffff ??? 今天在研究KMP算法的时候，KMP算法研究的一窍不通，完全看不懂这个神仙算法的思路。那想着先照葫芦画瓢，先不管三七二十一，知道KMP要干啥，至于为啥要那样做咋先不管，咋先把这个算法写一遍，然后再去理解，但是这个就出问题了，出了一个莫名其妙的bug，这是怎么找都找不到啊，找的我头大啊！！！ 我先确定了出问题的函数，这个很简单。 然后我又确定了出问题的部分是什么，这不确定不得了，发现是while循环出错了，while循环只是循环了一次就退出了。。。 代码如下： int KMPsearch(string str, string sub, int* next) { int i = 0, j = 0; while (i &lt; str.length() &amp;&amp; j &lt; sub.length()) { if (j == -1 || str[i] == sub[j]) { i++; j++; } else { j = next[j]; } } if (j == subLen) { return i - j; } else { return -1; } } 这个代码看着是十分的没有问题，但是我就是定位到这个函数有问题了而且是while循环一次就退出while循环一次之后i是1，j是-1，str.length()和sub.length()肯定是一直都不会变的啊？那么究竟是1&gt;=26还是-1&gt;=6? 这搞得我非常的懵逼。。。我的编译器出问题了，开始跟我瞎搞了？ // 原因是这样子的 str.length()返回类型是size_t是无符号类型的 // j 是int是有符号类型的，一般情况下还真的没问题，但是问题就在与这里的j可以为-1 // 有符号值与无符号的值进行比较的时候，有符号值会转换成无符号的值 // -1 是 0xffffffff 变成有符号的数还是 0xffffffff 可怕。。。这个比0x7fffffff(MAX_INT)还大！！数据在电脑中的存储和计算都是以补码的形式. -1的原码是 1000 0000 0000 0000 0000 0000 0000 0001 -1的反码是 1111 1111 1111 1111 1111 1111 1111 1110 -1的补码是 1111 1111 1111 1111 1111 1111 1111 1111反码是除了符号位其余的位取反 正整数的补码是就是原码 负整数的补码是反码加1 size_t i = 0x7fffffff; int j = -1; if (j &gt; i){ cout &lt;&lt; &quot;-1 &gt; 0x7fffffff&quot;&lt;&lt;endl; } 当一个有符号数和无符号数进行比较的时候，就不会把-1这个符号位1当成符号位. 也就是说-1 == (unsigned int)0xffffffff &gt; (unsigned int)0x7fffffff 0x7fffffff是啥玩意？是MAX_INT（定义在limits.h中) 0x80000000是MIN_INT，咦这个不是-0的原码嘛？ 0x80000000 -1 = 0x7fffffff 取反就是 0x00000000，这不是0嘛？蛤蛤蛤这也就是为嘛最大的负数的绝对值要比最大的正数大上1. -0的原码是0x80000000 反码是0xfffffff 补码是0x00000000，咦为啥呢？ 因为溢出了1 0000 0000，这个只是取后八位，所以说-0和0的补码都是0。 #include &lt;stdio.h&gt; #include &lt;limits.h&gt; int main(){ if (INT_MIN == 0x80000000 &amp;&amp; INT_MAX == 0x7fffffff){ printf(&quot;INT_MIN: 0x80000000\nINT_MAX: 0x7fffffff\n&quot;); }else{ printf(&quot;No&quot;); } return 0; } 有符号的数和无符号的数时要注意：有符号的数会变成无符号的数。 这不禁又让我想起来我之前遇到的一个大体相同bug for (size_t i = 10; i&gt;=value; i--){ // ... } 这个value是-1，导致这个循环死的了，当时找bug找的我也是头发昏，找到了的原因也是如此 无符号与有符号的数进行比较！！！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 我被坑的已经不止这一次了，嘤嘤嘤~，继续看KMP算法去了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法简介]]></title>
    <url>%2F2019%2F07%2F22%2FKMP%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[KMP 算法 KMP算法是关于字符串匹配的一个算法。 比如说有一个字符串是 “acbabcdabdbacdd” 我们要在这个字符串中寻找是否有子串 “acbdacd”，有就返回下标，没有就返回-1 暴力匹配暴力匹配的思路这个题目我们的思路其实是非常明确的。那就是暴力匹配呗。 如果匹配了我们就返回，如果不匹配我们就重新开始匹配下一个字符。 上面的那个题目，匹配到第四个个字符不匹配了，那么我们把子串往后移后一位，用a和c再比较。。。 这个暴力匹配就是一旦遇到了不匹配的字符，就把子串移后一位，如果都到了主串的末尾了还没有匹配成功，那么就说明这个主串中没有子串，返回-1即可。 代码实现的其实也蛮简单的。 暴力匹配代码实现#include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; /** * 使用暴力算法，就是这么的暴力！！ */ int KMP(string str, string sub) { // 使用i来指向主串，使用j来指向子串 int i = 0, j = 0; // 主串还没有被比较结束 while (i &lt; str.length()) { // 匹配了 继续比较下一位 while (str[i] == sub[j]) { i++; j++; // 匹配成功，在主串中发现了子串 if (j == sub.length()) { return i - j; } } // 匹配失败，将i移动到本次匹配的后一位 i = i - j + 1; // 重置子串， j重新指向子串的开头 j = 0; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABCDE&quot;; int index = KMP(str, sub); if (index == -1) { cout &lt;&lt; &quot;Not Found!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Found!\nT/F: &quot; &lt;&lt; (str.substr(index, sub.length()) == sub ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 这个暴力匹配的算法，就算是个小学生也能一眼看懂吧，不需要做什么代码说明了，重点戏是后面的KMP算法。 暴力匹配：时间复杂度是O(mn) 其中m是子串的长度，n是主串的长度. KMP 算法关于暴力匹配的思考及KMP的思路暴力匹配的算法每次都是后移一位。比如下面 主串: abcdxxxx 子串: abcde我们发现第五位不匹配，暴力匹配的思路是这样子的，移动到下一位 主串：abcdxxxx 子串： abcde但是这个不是很脑残的行为吗？既然第五位是不匹配的，那么主串和子串的前四位不就都是相等的吗？我们再次观察这个子串的前面的四位都是不相同的字符，那么我们完全没有必要让子串a再次和后面bcd比了。我们完全可以直接跳到这一步 主串: abcdxxxx 子串: abcdei直接往前跳了四步，极大的节省了时间。 但是问题就在，你是怎么知道前面的四位都是不相等的? 主串: ababxxxx 子串: ababe这次也是第五位不匹配的，这次我们还是跳四位？？？ 这时有人要抢答了：同学，这里有两个相同的字符，这傻子都可以看出来是跳两位啊！！ 那么这个也是跳两位？ 主串: abbaxxxx 子串: abbae很明显这个是跳三位。我们看起来非常的容易，一看就知道跳几位，但是如何用逻辑描述这个到底应该跳几位了？ 我们到第5位不匹配要跳几位，其实和第五位没有关系，这完全取决与前面的四位。我们来观察一下： abcd -&gt; 4 = 4-0 abab -&gt; 2 = 4-2 abba -&gt; 3 = 4-1或许也许可能观察不出来什么，不过观察一下他们的前缀和后缀。 比如 impossible 前缀就有im 后缀就有ible 但是他们的前缀和后缀不能是他们的本身 字符串 前缀 后缀 前缀后缀共有字符串的最大长度 abcd a, ab, abc d, cd, bcd 0 abab a, ab, aba b, ab, bab 2 abba a, ab, abb a, ba, bba 1 这样就明白了吧，我们往后移动的多少取决于前缀后缀共有字符串的最大的长度。 我们可以来验证一下 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第一步：（找到第一个匹配的位置） 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第二步：(C和空格不匹配) ABCDAB的前缀后缀的共有字符串是2，那么应该向后移动6-2=4位 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD发现找到了 我们可以发现KMP的思路其实还是蛮清晰的。就是这个简答，利用匹配失败已经前面匹配成功的字符的前缀后缀共有字符串的最大的长度来尽可能多的往后移动位置，反观暴力破解，每次就只是往后面移动一位d，效率低下。 KMP寻找的时候的时间复杂度是O(n) 构造部分匹配表上面的那个由前几位前缀后缀共有字符串的最大长度构成的表被称为部分匹配表。那么如果用代码去构造这个部分匹配表呢？ 比如如下的字符串，部分匹配表如下(第三行)，但是如何去构造呢 0 1 2 3 4 5 6 ---(序号) a b c d a b d ---(字符串) 0 0 0 0 1 2 0 ---(部分匹配表) 1 1 2 3 4 4 4 ---(到这一位不匹配的时候向后移动的位数)思路 a b c d a b d 1 j i -&gt;0 2 j i -&gt;0 3 j i -&gt;0 4 j i -&gt;1 5 j i -&gt;2 6 j i 这个第六步发现i位和j位不相等，那么i是肯定不能动的，动的肯定是j那么j怎么变？j变成0？？？ 此时j-1的字符肯定是等于i-1处的字符的。此时我们想要知道是否j还有别的值的前一位是等于i-1的然后跳到这个j 这个例子中没有下面再举一个例子 a b c d a b d a b c d a b d ... a b c d a d b a b c d a b d 0 0 0 0 1 2 此时我们发现d和c不匹配，我们想从a b中找到可能和b相等的值 d处的最大前缀后缀共有的最大长度有可能超过2吗？不可能 假如如下的字符串 x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] 此时又回到了j前面的值和i前面的值再次都相等的情况，再次比较,如果不相等回到 x y d x y c z z z z x y d x y d j i -&gt; x y这个串的前后缀最大已经是0了上面或许讲的有点乱，因为当时我也是有点乱，但是现在我明白了 我们发现当部分匹配表没有1这个值，没有前缀也没有后缀，就给它一个0吧 int* calNext(string sub){ int length = sub.length(); int* next = new int[length]; next[0] = 0; int i=1, j=0; while(i &lt; sub.length){ if (j &gt; 0 &amp;&amp; sub[i] != sub[j]){ j = next[j-1]; } if (sub[i] == sub[j]){ j++; } next[i++] = j; } } 代码说明： 这里面最难以理解的估计就是那一句话，就是j = next[j-1]到底是什么含义 比如 0 1 2 3 4 a b a b c j i 0 0 1 2 0j = next[j-1]之后就是 j =0; j = next[j-1]的含义就是回到上一个时刻 sub[j-1] == sub[i-1]不仅如此，他们前面的值都是相等的！ 这个例子中这样的数不存在 x d x y x d x d j i 这时 j = next[j-1] x d x y x d x d j i 此时j前面的数和d前面的数又都是相等的了，再次进行比较！如果还是不相等 j = next[j-1]这样应该很好理解了吧。 这样我们的next数组也就构造好了，KMP算法也就好实现了 KMP 代码int KMPsearch(string str, string sub, int* next){ int strLength = str.length(); int subLength = sub.length(); int i=0, j=0; while (i &lt; strLength &amp;&amp; j &lt; subLength){ // KMP核心，不匹配向后移动 if (j &gt; 0 &amp;&amp; str[i] != str[j]){ j = next[j-1]; } if (str[i] == sub[j]){ i++; j++; } if (j == 0 &amp;&amp; str[i] != str[j]){ i++; } } // 找到了子串 if (j == subLength){ return i-j; }else { return -1; } } 代码说明： 其实需要说明的就只是KMP的核心那一块代码。我们一直说什么往后移动，其实这也不是往后移动啊？ 其实这只是我们想象中的往后移动，实际上是这样子的 abcdabcde abcde -&gt; 上面的a匹配失败 -&gt; abcdabcde abcde -&gt; 让下面a和上面a进行比较当匹配到第五位的时候，i其实没有变，变的只是j而已我们直接让sub[next[j-1]]和str[i]进行比较 上面那个next[j-1]就是a abacabab abab -&gt; 上面的c匹配失败 -&gt; abacabab abab -&gt; 让下面b和上面c进行比较再次重申一下，i没有变，变的只是j而已。 总结写到了这儿KMP算法基本上就写完了，写完了之后我对KMP算法的理解算是有涨了一个层次，至少能基本理解这个算法该如何用了而不是单纯的被代码。其实网上关于KMP算法的博客特别多，每个人使用的方法都是不一样的，我看了很多人的next[0] = -1，还有构造了其他各种各样的数组，我基本上都没怎么看，我看的不是代码是怎么写的，主要是KMP的思路是如何的，理解了这个思路之后，什么样的实现KMP算法的代码基本上都能看懂了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法简介]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[动态规划算法简介动态规划基本介绍动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 适用情况 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如下图所示： 初始状态→│决策1│→│决策2│→…→│决策n│→结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征。 递归的定义最优解。 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 根据计算最优值时得到的信息，构造问题的最优解 算法实现动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 上面的这些内容都是从百度百科中抄来的，虽然是百度百科讲的也不是很烂，我感觉除了不是很形象，其他讲的还是不错的。现在还是直接从leetcode动态规划算法的题目开始吧！ leetcode 动态规划爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶这个题目我之前就已经是做过了的，不过似乎是没有使用到动态规划的算法。 class Solution { public: map&lt;int, int&gt; result; int climbStairs(int n) { if (n == 1 || n == 2) return n; if (result.find(n) != result.end()) return result[n]; int res = climbStairs(n-1)+climbStairs(n-2); result[n] = res; return res; } }; 执行结果：通过 显示详情 执行用时 : 0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 : 8.7 MB, 在所有 C++ 提交中击败了10.62%的用户 由此可见，程序运行的速度是飞快的，但是因为使用了map进行记忆，程序消耗了太大的内存，所以说算法值得优化。这是一个典型的动态规划型的题目，和斐波那契数列有点儿相似，那么如何使用动态规划算法呢？ 其实我上面用的map已经是一种动态规划算法了，就是记住原来算过的结果，极大的提高了效率，不过int， int类型的map如果是使用数组的话，还是更好一些。 class Solution { public static int memo[]; public int climbStairs(int n) { memo = new int[n+1]; return climbStairs(n, memo); } public static int climbStairs(int n, int memo[]){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗 :33 MB, 在所有 Java 提交中击败了73.01%的用户 内存消耗反而变大了，，这个是语言的原因，你懂得~ 改成C++代码 int climbStairs(int n){ int* memo = new int[n+1]{0}; return climbStairs(n, memo); } int climbStairs(int n, int* memo){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.6 MB, 在所有 C++ 提交中击败了19.38%的用户 内存的消耗还是特别多，这。。。只能求助于题解了。可以不使用递归的方式，不过说实话，时间复杂度都是一样的，空间复杂度感觉也没多少改善啊。。。 int climbStairs(int n){ if (n &lt;= 2) return n; int* memo = new int[n+1]{0}; memo[1] = 1; memo[2] = 2; for (int i=3; i&lt;=n; ++i){ memo[i] = memo[i-1] + memo[i-2]; } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.4 MB, 在所有 C++ 提交中击败了43.73%的用户 算了，不纠结这题了，这只是一个简单题罢了，请看下一题。 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int sum = 0; int max_sum = nums[0]; for (auto i : nums){ if (sum &gt; 0){ sum += i; }else { sum = i; } max_sum = max(sum, max_sum); } return max_sum; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了92.04%的用户 内存消耗 :9.2 MB, 在所有 C++ 提交中击败了80.50%的用户 代码说明： ​ 别看着这个代码好像很简单似的，但是其中动态规划的算法还是不好理解的。 sum max_sum的含义是什么？ sum表示的当前选定的序列的和，max_sum值的是遇到的最大的序列的和。 sum &gt;0 -&gt; sum += i ? 这其实很好理解，前面的sum是正的，而且最大值已经被记录过了，加上前面正的序列对i有促进的作用，所以说新的序列就是前面的正的那一块加上当前的i. else sum = i? 前面的序列是负的，加上i无论i正负也好都不会有前面的序列大，所以直接从i开始一条新的序列就好了。 那万一i前面的那个值是正的，为什么不从i前面的那个正数开始呢？ 不可能的，i前面的那个值既然被加入了序列中就说明，i前面的前面的序列的和是正数，而i前面的序列和是一个负数，这就可以肯定i前面的数是一个负数。所以从i开始新的序列的最对的。 max_sum = max(sum, max_sum); 每次我们生成新的序列的，和都要和之前获取到的最大的数列的和进行比较以确保我们保存的的确是最大的子序列的和。 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。我一开始是这样子写的(纯暴力破解法，时间用的差不多是一千多ms吧，能AC我也是佛了) int maxProfit(vector&lt;int&gt;&amp; prices) { int profit = 0; int size = prices.size(); for (int i=0; i&lt;size-1; ++i){ for (int j=i+1; j&lt;size; ++j){ if (prices.at(j) - prices.at(i) &gt; profit) profit = prices.at(j) - prices.at(i); } } return profit; } 其实这个题目一眼看过去就知道是动态规划的算法，和前面的那个题目是类似的 int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size &lt;= 1) return 0; if (size == 2) return max(prices.at(1) - prices.at(0), 0); vector&lt;int&gt; buy(size, 0); vector&lt;int&gt; sell(size, 0); buy.at(0) = -prices.at(0); for (int i=1; i&lt;size; ++i){ buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); } return *max_element(sell.begin(), sell.end()); } 执行结果：通过 显示详情 执行用时 :20 ms, 在所有 C++ 提交中击败了25.61%的用户 内存消耗 :9.8 MB, 在所有 C++ 提交中击败了5.10%的用户 这个问题的解决方案是动态规划当中比较经典的填表的方法。之前的那个百度百科中也都已经介绍了这个公式。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 与之比较类似的还有背包问题，待会可以一并解决。 代码说明： 上面的代码主要就是两行比较重要： buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); 第一个就是我在第i天买，比不比我在昨天买上算，如果今天比昨天还要贵那么我今天肯定是不买的。 第二个就是我在第i天卖有没有我在第i-1天卖上算，如果昨天卖比较好那还不如昨天卖。 但是光凭以上两点能解决什么问题呢？ 仔细看的话，你会发现，其实你每一天买的都是相对来说最优的。而每天卖的也是最好的。 我们可以这样想，如何只有三天的话，我们是不是就可以获得在第三天卖的最高的价格？ 假如是 1 2 5 只有buy[1] = 1 sell[1] = 2 第三天的价格是5，那buy[2] = 1，肯定还是延续在只有两天时的买法 sell[2] = max(sell[1], -1 + 5) ，这个卖就是sell[1]肯定是只有i两天的时候最优的利润，buy[1]也是最优的买法，现在加入就在第三天的时候，我们在第三天卖一下，我们看一看这个利润有没有之前的高。然后存入数组。 加上第四天的话还是这样子考虑。就这样其实sell数组里面放的就是有第n天的最大利润，sell数组后面值肯定也都是一样的。 于是取得最大值就行了。 return *max_element(sell.begin(), sell.end()); 注意：max_element返回的是迭代器，所以要加上*取值。 leetcode给出的官方题解是这样子的 public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minprice) minprice = prices[i]; else if (prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; } return maxprofit; } 使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。 这两个算法的思路其实都是一样的，不过官方的题解更加的清晰明了。不过我上面的那个更像是一个动态规划算法，把一个问题拆分成他的子问题。要取得第七天的最大的利润，我们需要利用第六天的数据，这就是一步一步往后推的过程。 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。额~这个好像有点儿复杂，不过如果想到转换的话，一步头就完事了。 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size == 1 || size == 0){ return 0; } int profit = 0; for (int i= 1; i&lt;size; ++i){ if (prices[i] &gt; prices[i-1]){ profit += prices[i] - prices[i-1]; } } return profit; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了89.37%的用户 内存消耗 :9.5 MB, 在所有 C++ 提交中击败了48.29%的用户 感觉这个和动态规划已经扯不上边了，算了叭说了，反正我也不会。。。。 转载两篇文章，这个动态规划有点儿难，我特喵现在也有点儿懵逼了，算了不研究了，下次研究透彻了再说吧。 文章阅读教你彻底学会动态规划——入门篇 算法-动态规划 Dynamic Programming–从菜鸟到老鸟]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本的增删改查操作]]></title>
    <url>%2F2019%2F07%2F19%2FMySQL%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MySQL基本的增删改查 JDBC MySQL的连接 使用工具：Eclipse and Visual Studio 2019 这里其实无论是使用Java还是C++，使用的都是jdBC的操作。当然这里的Java相对来说更加的正宗一点，C++中的jdBC库我用了关于string那一块还有bug，兼容性还不行。所以这里就使用eclipse Java来举例吧。至于如何连接MySQL，这个倒是简单的很，也是不必再说了。 Driver的初始化try { //Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。 // 首先加载驱动包 com.mysql.cj.jdbc.Driver Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } mysql::MySQL_Driver* driver; driver = sql::mysql::get_mysql_driver_instance(); Connection连接数据库, 初始化 Statement// 连接的地址 localhost就是127.0.0.1就是本机的地址 world 代表的是要使用的数据库的名字 String url = &quot;jdbc:mysql://localhost:3306/sher?useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&amp;serverTimezone=UTC&quot;; // 建立和数据库的连接 url account password try { con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); stmt = con.createStatement(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } 其实上面的变量的声明都在类中的静态变量中，为了方便以后数据库的关闭 static ResultSet rs = null; static Statement stmt = null; static Connection con = null; static PreparedStatement pstmt = null; Connection* con; Statement* state; ResultSet* result; const char* accout = &quot;root&quot;; const char* passwd = &quot;root&quot;; con = driver-&gt;connect(&quot;tcp://127.0.0.1:3306&quot;, accout, passwd); state = con-&gt;createStatement(); 这里C++代码中要注意一个问题，account和passwd不能直接写driver-&gt;connect中，而且也不可以使用string类，不然会出现莫名其妙的bug，我也是求助了好长时间才知道这个地方出了问题，我也是醉了。 数据库的关闭private static void close() { try { if (rs!=null) { rs.close(); } if (stmt!=null) { stmt.close(); } if (con!=null) { con.close(); } if (pstmt!=null) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } } C++代码当中没有使用异常处理的机制，而且C++代码中异常处理也不是很好，反正使用体验极差。不过C++11中对于异常机制的改良，我也没学过不知道怎么样。 数据库的增删改查数据库增加数据private static void addData(int id, String username, String passwd) throws SQLException { String sql = String.format(&quot;insert into shertable(id, username, passwd) values(&#39;%d&#39;, &#39;%s&#39;, &#39;%s&#39;)&quot;, id, username,passwd); stmt.execute(sql); } 上面定义的时候我们使用了两种Statement。Statement和 PreparedStatement，这两种之间有什么区别呢？其实是建议使用PreparedStatement的，Statement容易被SQL注入，是不怎么安全的，不过为了介绍这里就都使用了。 stmt.execute(sql) 一般这种insert语句还有用的就是executeUpdate()。还有一个是executeQuery().这三者是有区别的 ResultSet executeQuery(String sql); 执行SQL查询，并返回ResultSet 对象。 int executeUpdate(String sql); 可执行增，删，改，返回执行受到影响的行数。 boolean execute(String sql); 可执行任何SQL语句，返回一个布尔值，表示是否返回ResultSet 。 不过这个execute也不是万能的。 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 至于这个？占位符是PreparedStatement中使用的，等到下面再说。 数据库查询数据private static void queryData(String sql) throws SQLException { rs = stmt.executeQuery(sql); while (rs.next()){ System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot; Username: &quot;+rs.getString(&quot;username&quot;)+&quot; Password: &quot;+rs.getString(&quot;passwd&quot;)); } System.out.println(); } state-&gt;execute(&quot;use world&quot;); // 查询 result = state-&gt;executeQuery(&quot;select * from city order by id desc limit 10&quot;); // 输出查询 cout &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot;; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; &quot;Id&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Name&quot; &lt;&lt; setw(15) &lt;&lt; &quot;CounryCode&quot; &lt;&lt; setw(15) &lt;&lt; &quot;District&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Population&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; while (result-&gt;next()) { int id = result-&gt;getInt(&quot;id&quot;); // 关于getString()这一块这个写的真的是全都是bug， 不过现在好像已经可以运行了。 string name = result-&gt;getString(&quot;name&quot;).c_str(); string countrycode = result-&gt;getString(&quot;countrycode&quot;).c_str(); string district = result-&gt;getString(&quot;district&quot;).c_str(); int population = result-&gt;getInt(&quot;population&quot;); cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; setw(15) &lt;&lt; id &lt;&lt; setw(15) &lt;&lt; name &lt;&lt; setw(15) &lt;&lt; countrycode &lt;&lt; setw(15) &lt;&lt; district &lt;&lt; setw(15) &lt;&lt; population &lt;&lt; endl; } cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; delete state; delete con; 看这个Java和C++中jdBC的操作基本上都是一样的。不过这里C++代码需要注意一下，我又被坑惨了。在使用result-&gt;getString()之后要加上.c_str()使其变成C风格的字符串。都说了string类在jdBC for C++中真的全是bug。C++其实也有C风格的MySQL数据库连接的库，不过那个已经不在这次介绍的范围之内了。 PreparedStatement 添加数据private static void setPstmtSql(int id, String username, String passwd) throws SQLException { pstmt = con.prepareStatement(&quot;insert into shertable(id, username, passwd) values(?,?,?)&quot;); pstmt.setInt(1, id); pstmt.setString(2, username); pstmt.setString(3, passwd); pstmt.executeUpdate(); } 这里就是pstmt的代码的使用。我们先使用占位符来创建一个SQL语句，然后使用setInt()，setString()的方法，来填入占位符中的内容，这是既简便了stmt字符串连接的操作，也可以防止SQL注入，很安全~ 注意上面说的： 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 数据库删除数据private static void delData(int id) throws SQLException{ pstmt = con.prepareStatement(&quot;delete from shertable where id=?&quot;); pstmt.setInt(1, id); pstmt.executeUpdate(); } 数据库修改数据private static void modifyPasswd(String username, String old_passwd, String new_passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;update shertable set passwd = ? where username = ? and passwd = ?&quot;); pstmt.setString(1, new_passwd); pstmt.setString(2, username); pstmt.setString(3, old_passwd); int flag = pstmt.executeUpdate(); if (flag!=0) { System.out.println(&quot;Successfully!&quot;); }else { System.out.println(&quot;Unsuccessfully, please try again!&quot;); } } 本列中其他的操作根据名字查询 private static void queryByName(String name) throws SQLException { pstmt = con.prepareStatement(&quot;select * from shertable where username = ?&quot;); pstmt.setString(1, name); rs = pstmt.executeQuery(); if (rs.next()) System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot;\nUsername: &quot;+rs.getString(&quot;username&quot;)+&quot;\nPassword: &quot;+rs.getString(&quot;passwd&quot;)); else System.out.println(&quot;Not Found!&quot;); } 登陆系统 private static void sign(String name, String passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;select * from shertable where username = ? and passwd = ?&quot;); pstmt.setString(1, name); pstmt.setString(2, passwd); rs = pstmt.executeQuery(); if (rs.next()) { System.out.println(&quot;Sign Up Successfully!&quot;); }else { System.out.println(&quot;Worng UserName or Password!&quot;); } } 总结上面都只是MySQL中的基础中的基础中的基础的操作，作为从来没有学过MySQL的看看基本就行了。对于MySQL中进阶一点的操作，SQL命令的更加高阶的使用可以下次写写看，现在暂时MySQL用得还是比较少滴，不急着学。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数]]></title>
    <url>%2F2019%2F07%2F19%2F0.1%2B0.2%20%3D%3D%200.3%20%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数0.1 + 0.2 == ？ 0.1 +0.2 是等于0.3的吗？这个问题似乎有点儿弱智，但是估计大多数人回答的都是错误的。在我们的认知当中，即使是在计算机当中，0.1+0.2也应该是等于0.3的啊，不然那不就乱套了嘛。不过现在你可以打开你的编译器来测试一下。 System.out.println((0.1+0.2 == 0.3)); // false 确实是不等的。。。那是不是Java的原因？我们可以使用C++，python测试一下. std::cout&lt;&lt;(0.1+0.2 == 0.3)&lt;&lt;std::endl; // 0 print( (0.1+0.2 == 0.3)) // False 我们发现无论是哪一种语言来说0.1+0.2都是不等于0.3的，这说明了这不是语言的问题了。那么0.1+0.2到底是多少呢？ std::cout&lt;&lt;std::setprecision(20)&lt;&lt;std::setiosflags(std::ios::fixed)&lt;&lt;0.1+0.2&lt;&lt;std::endl; 我们取了小数点二十位。输出的结果是0.30000000000000004441。这个结果果然不是0.3，后面为什么带了几个4呢？这是为什么呢？ 计算机中浮点数的储存众所周知计算机当中数据的存储都是二进制的。比如说2就是10,8就是100。如果有一个数带有小数的话，在计算中是如何存储的呢? 我们可以先来想想看如何把一个十进制小数表示成二进制。这个其实是和整数是一样的。二进制的小数点后的第一位是2-1=0.5，小数点后的第二位是2-2=0.25…以此类推。那么如何把0.1用二进制表示？和把一个整数转为二进制有点相似，小数转为二进制是使用乘以2的方式。 整数转为二进制：（除以2取余） 100/2 = 50 ……0 50/2 = 25 ……0 25/2 = 12 ……1 12 /2 = 6 ……0 6/2 = 3 ……0 3/2 = 1 ……1 1/2 = 0 ……1 然后将这些余数倒着写出来。100(10) = 1100100(2) 小数转为二进制：(乘以二取整) 0.1 * 2 = 0.2 ——0 0.2 * 2 = 0.4 ——0 0.4 * 2 = 0.8 ——0 0.8 * 2 = 1.6 ——1 0.6 * 2 = 1.2 ——1 0.2 * 2 = 0.4 ——0(开始重复了) 这次是将这些小数正写出来。0.1(10) = 0.0 0011 0011 0011 …… 可见二进制表示0.1是一个无限循环的数，可以float就占4个字节，double就占用8个字节。计算机是不可能使用这种方式来储存浮点数的。其实0.1~0.9999这9999个数中只有15个数可以用二进制精确的表示。 我们可以看一下Java当中基本类型表示的数的范围是多少 Java中基本类型的表示范围 数据类型 字节数 二进制位数 范围 规律 byte 1 8 -128～127 -27～27-1 short 2 16 -32768～32767 -215～215-1 int 4 32 -2147483648～2147483647 -231～231-1 long 8 64 -9223372036854775808 ~ 9223372036854775807 -263～263-1 float 4 32 1.4E-45~3.4028235E38 double 8 64 4.9E-324~1.7976931348623157E308 char 2 16 0～65535 0~216-1 boolean 1 8 true或false true或false float的大小是和int一样的，但是float表示的范围和int表示的范围比起来那可是一个天文数字。这就肯定说明了浮点数的储存是异于整型变量的。而且也必定说明浮点数是不精确的，不然如果float是绝对精确的，int还有存在的意义吗？这浮点数不也太能干了吗？ 其实浮点数为什么叫浮点数就是因为浮点数是浮动的，是不确定的。(量子力学？？)为什么浮动就要剖析一下浮点数存储的原理了。 浮点数的存储浮点数的存储分为一下四个部分。Java中浮点数的存储符合IEEE754标准。浮点数使用符号位、指数域和有效位数域来存储。 类型 符号位 指数域 有效位数域 float 1位（第31位） 8位（第23~30位） 23位（第0~22位） double 1位（第63位） 11位（第52~62位） 52位（第0~51位） 作用 表示浮点值的正负 存储指数位 存储小数值 浮点数的符号位和整型变量是一样的。0表示正数，1表示负数。 指数使用了偏移量的方式来表示。偏移量为2x-1(比实际值大2x-1)，x表示的是指数域的位数。 任何一个非0且非无穷大的浮点数都可以表示为 v = s × m × 2e的形式。 s为-1或1，m为有效位数(小数)，e为指数。 根据m和e的不同，我们可以将浮点数分为三类： 正规化浮点数 ——指数域不全为0且不全为1. 如99.5f在计算机中存储为：0 10000101 10001110000000000000000 有效位数是0.1000111，加上1为1.1000111转为十进制为1.5546875. 指数部分减去偏移量(01111111)就是110也就是6. 符号位为0，表示这是一个正浮点数。 99.5f = 1 × 1.5546875 × 2 6 = 99.5（就是这么完美） 16进制表示为 0x1.8ep6 (1.8e-&gt;1.10001110) p:代表指数位，因为e在16进制中已经被使用了。 6代表26 非正规化浮点数 ——指数域全为0且有效位数域不全为0 如5.877472E-39f在计算机中存储为：0 00000000 1000000000000000000000 有效位数为0.1此时不再加上1，转为十进制为0.5 指数位为 1-127为-126 符号位为0，表示这是一个正浮点数。 5.877472E-39f= 1 × 0.1 × 2-126 = 2-127(误差有点打好像。。。) 16进制表示为0x1.0p-127 特殊浮点数 浮点数 符号位 指数域 有效位数域 0 0 全是0 全是0 负0 1 全是0 全是0 正无穷大 0 全是1 全是0 负无穷大 1 全是1 全是0 NaN 任意 全是1 不全为0 所谓NaN就是 Not a Number 上面我们就基本了解了浮点数在计算机中是如何存储的了。 我们也可以使用Float和Double类中的中如下两个方法来查看对应浮点数在计算机中的存储情况。 public static int floatToIntBits(float value); // Float类中 public static long doubleToLongBits(double value); // Double类中 // 不过以上的两个方法输出的都是十进制的值我们可以使用 Integer (Long)类中的转为二进制 public static String toBinaryString(int i); public static String toBinaryString(long i); // 不过还是有问题，就是前面如果有0的话，0是不会输出的，我们可以根据输出的长度进行补0 浮点数比较需要注意的地方扯了那么多有点没的，其实还是要回到之前的那个问题上——浮点数之间的比较。0.1 + 0.2 == 0.3怎么才能让他返回true呢？ 设置绝对误差public static int compareFloat(float a, float b, double realError){ if (Math.abs(a-b) &lt;= realError){ return true; }else { return false; } } 不过这样真的合理吗？设置realError为 10-6 10-6好2 × 10-6返回的也是true。不过，平心而论他们的确不应该返回true。 而1000000000和1000000000.1应该返回true的却返回了false 设置相对误差public static int compareFloat(float a, float b， double absError){ if (Math.abs(a-b)/(a+b)*2 &lt;= absError){ return true; } return false; } 不过这种相对误差其实也是有点儿问题的。 其实对于浮点值精度的丢失的解决方法是非常复杂的，而且是没有一个固定的方法的。我们只能考虑到我们 自己的需求，设置合理的误差的范围进行合理的比较。 设置绝对误差和相对误差public static compareFloat(float a, float b, double realError, double absError){ if (a == b){ return true; } if (Math.abs(b-a) &lt;= realError){ return true; } if (Math.abs(b-a)/a+b*2 &lt;= absError){ return true; } return false; } 设置好合理的realError和absError就可以确保0.1+0.2 == 0.3啦 其实关于浮点数的转换也有很多的问题，不过这里就不多说啦。。。 总结浮点数是条蛇，别有事没事就玩它！尤其是这种代码就別写出来丢人了。。。蛤蛤蛤 for (double i = 0.1 ; i != 1.0; i += 0.1){ // ... } 之前看到没啥的，现在看到总是想笑~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的equals与==陷阱]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84equals%E4%B8%8E%3D%3D%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[浅谈Java中的equals与==陷阱 Java当中最常用的一个类便是String，对于C++程序员来说这个string也是非常熟悉的。到了Java这一块，咦，仅仅是变了一个大小写一样，还不是一样的用。不过用着用着就发现了一个天大的问题。这也是我实际写Java的时候发生的问题，程序莫名其妙死了，就是因为使用了Java的== std::string a = &quot;abc&quot;; std::string b = &quot;abc&quot;; if (a == b){ std::cout&lt;&lt;&quot;a is equal to b&quot;&lt;&lt;std::endl; } else { std::cout&lt;&lt;&quot;a is not equal to b&quot;&lt;&lt;std::endl; } String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } 对于一个C++程序员来说上面的代码输出什么估计想都不用想都知道是输出a is equal to b，但是如果是一个Java程序员他肯定会说肯定输入a is not equal to b。C++程序员在想：Java程序员这么弱智的嘛，这个a和b明显相等的啊！Java程序员在想：C++程序员这么智障的吗，这个明显不相等的啊！先不管这两个程序员骂来骂去的了，先看看为什么会发生这种情况。 这时候一般就会有一个大神跳出来说，你们这群蠢蛋，Java当中==比较的是地址，equals()方法才是比较的内容。C++程序员其实是在做这样的事 String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } C++程序员一测验，果然输出了a is equal to b。哇这个人果然是大神，晓得了晓得了，又学到了一个知识点，==比较地址，equals比较内容。不过C++程序员转念一想1 + 1 == 2难道在Java中都不对吗？于是反问大神，大神说：你是沙雕吗？这个肯定是true啊。那我加个限制吧，对于非基础类型而言，==是比较地址, equals()方法是比较内容。 但是C++程序员都是比较喜欢test瞎测验的。这一侧不得了了。 StringBulider a = new StringBulider(&quot;abc&quot;); StringBulider b = new StringBulider(&quot;abc&quot;); if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } C++程序员发现这两个输出的都是a is not equal to b。鬼鬼，这还得了啊。问了一下大神，大神也是哑口无言了。说起什么，你这个类不算，肯定是你的类出了问题。 那么问题到底出在了哪儿呢？ 首先我们要清楚为什么为什么每个类都会有一个equals方法。比如如下写了一个类 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } // 这里省略了setter public int getId(){ return this.id; } public String getName(){ return this.name; } } 我们发现这个类中没有写equals方法，但是我们仍然是可以调用的。原因就在于Java中的每个类都是默认继承Object的，也就是说equals是从Object中继承过来的方法。那就好办了，直接看看Object中equals()方法是怎么写的不就行了。 public boolean equals(Object obj){ return (this == obj); } 我靠！这个equals和==不就是一样的嘛。有个屁的区别啊。这大神不是在耍我完的吗？那为什么上面的String类中==和equals呈现的结果不同呢？那是因为String中是Override(覆盖)了equals方法的。 以上面的这个Student举例，判断两个人是不是相等，肯定不能用name(光是我听到的名字叫张旭的就至少五个，据说有一次考试按姓名分班，全校的张旭都坐一排，到了张旭，有来了两个张旭，感觉张旭这个名字比张伟还强，至少张伟这个一个都不认识)。所以我们应该用id来重载一下equals()方法。 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == obj.id; } return false; } } 哈，现在已经都完事了吧。这样这个类也算是完美了。 至于重写equals方法是有五个规定的，不过那五个规定估计傻子都不会违反的，这里就叭说了。 重写了这个equals难道这就完美了吗？不尽然。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == this.id; } return false; } } 你说此时，难道作为人的小明和作为学生的小明不是一个人吗？所以说这个equals还是有不足，没有考虑到可能有的父类。或者说这个equals可以直接在父类中重载，而不用在子类中重载。 把这一点也考虑到了，哇哈哈，这个equals已经完美了，不是么？ 嗯。。还真的不是，你以为你又能了，其实不然。尤其是在HashMap的使用上。 Student a = new Student(123, &quot;sher&quot;); Student b = new Student(123, &quot;sher&quot;); System.out.println(a.equals(b)); // true Map&lt;Student, Integer&gt; scoreMap = new HashMap&lt;Student, Integer&gt;(); scoreMap.put(a, 99); System.out.println(scoreMap.get(a)); // 99 System.out.println(scoreMap.get(b)); // null 你看，又出问题了。即使你a和b是完全一样的。但是放入HashMap中之后你却只能通过a来获取成绩了。这是因为HashMap使用的是哈希表。HashMap在判断你是否相等的时候是这样子的. if (a.equals(b) &amp;&amp; a.hashCode() == b.hashCode()){ .... } 前面虽然是相等的，但是后面是不相等的。那么后面那玩意是啥啊？其实他也是所有类都从Object继承的方法。当我们重写equals而不重载hashCode的话，就会在这些使用哈希表的集合中出现问题。所以api文档规定我们: 如果两个对象调用equals()是true，那么他们的hashCode必须是相等的。(hashCode返回一个int) 如果两个对象调用equals()是false，我们建议他们的hashCode不要相等。 所以我们还要Override一下hashCode方法。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Person){ Person p = (Person)obj; return p.getId() == this.id; } if (obj instanceof Student){ Student s = (Student)obj; return s.id == obj.id; } return false; } @Override public int hashCode(){ // int类型的hashCode系统已经替我们写好了 return Integer.hashCode(this.id);// 其实就写return id;好像也没什么问题，毕竟是整型变量。 } } 至此，是不是就没有问题了呢？其实，可能还有问题，不过还有什么问题，我也是不晓得的了，等学到了更多的知识，有了丰富的经验之后看这一小段代码，还是会有很多的问题。不过，这个问题，现在就叭说了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（八）堆排序]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（八）堆排序 堆排序算是里面最比较难懂的算法了，因为堆排序需要二叉树的基础。不过虽然说靠的是二叉树但是实际上并没有生成一个二叉树而是利用了顺序存储二叉树，来构造大顶堆和小顶堆来实现的。 堆排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 是 我感觉这个算法牛不牛逼已经是不言而喻的了。时间复杂度是交换法的巅峰，空间复杂度还是O(1)，这个算法实在是神奇。赶紧如果是学会了这个算法就可以去装逼了。别人排个序是 好几秒，你排个序是几毫秒。关键是你们用的还是同样的内存，这谁能顶得住啊！不过，要说明的是，堆排序是一种不稳定的算法。 堆排序的基本思路 上面也提到了，堆排序是用顺序存储二叉树来实现的。那什么是顺序存储二叉树呢？ 且看下图 我们大多数时候所了解到的二叉树都是上面的链式结构的二叉树，直观而且容易理解和操作。但是二叉树也可以用数组来表示。可以说一个数组就对应了一个二叉树。右面的图展示的是非完全二叉树的顺序存储，这里是我们不需要的。因为堆排序的时候要构造大顶堆(从小到大排序)。如果要是从小到大排序的话就要构造小顶堆。大/小顶堆就是一种完全二叉树。所谓完全二叉树所有的叶子节点(也就是没儿子的节点)都必须出现在最后两层，而且叶子节点在左面要连续。 按照上面的顺序存储的关系，上面的大顶堆可以转换成为一个数组来表示。 观察这个数组和二叉树，我们可以得出如下的结论。arr[n]的左子结点是arr[2n+1]，右子节点是arr[2n+2]，父节点是arr[(n-1/2)] 大顶堆的每个一个节点的值都大于他的左子结点和右子节点。但是左右节点之间的大小是不用限制的。 根据大顶堆的定义我们就可以知道大顶堆的根节点的值一定是所有节点当中最大的。如果我们把根节点去掉，然后利用剩下的节点再构造一个大顶堆。我们又可以找到第二大的节点，如此循环。我们就可以让数组变得有序。但是，如何构造大顶堆呢？ 看到上面的动图其实是有一点儿傻眼的，这不是数组排序吗？为什么搞这个一个二叉树在这？其实我们实际上并没有构造这个一个二叉树，只是把数组想象为一个完全二叉树罢了。要想把一个二叉树变成大顶堆，首先我们要看他的非叶子节点，因为叶子节点没有子节点，对于构造大顶堆是没有意义的。对于一个顺序存储二叉树，他的叶子节点是哪几个呢？答案是从0到arr.length/2-1。蛤？为什么是这几个节点啊？如果你仔细观察的话，叶子节点的个数永远是比非叶子节点多一个的，一棵树要么是叶子节点，要么是非叶子节点，所以非叶子节点个数 arr.length/2个。而非叶子节点都是存储在数组的前面的，所以说非叶子节点的下标是0到arr.length-1。 对于一个非叶子节点来说，要满足大顶堆的条件，就要使他大于他的子节点。而所有的非叶子节点都大于他们的子节点的话，这棵树就是一个二叉树了。 堆排序的代码实现 将数组调整为大顶堆代码实现 /** * 将一个数组（二叉树）调整成一个大顶堆 * @param arr 待排序数组 * @param i 非叶子节点在数组中的索引 * @param length 数组的大小(逐渐减小的) */ private static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; //：2*i+1 左子节点的索引 2*i+2 右子节点的索引 for (int k = 2*i+1; k &lt; length; k=2*k+1) { if (k+1&lt;length &amp;&amp; arr[k] &lt; arr[k+1]) { k++; } if (arr[k] &gt; temp) { //：子节点大于父节点， 两者交换位置 arr[i] = arr[k]; i = k; // 继续循环比较 }else { break; //：为什么break？ 以i为父节点的下面的都已经排序过了，都是大顶堆了 } } arr[i] = temp; } 代码说明： for循环里面的k, temp是干什么的 ? k的初始值是给定的非叶子节点的左子结点。每次循环都要到下一个左子结点。arr[k] &lt; arr[k+1]就是比较左右子节点哪个大。k++就是定位到右子节点，因为一开始k是指向左子结点的，右子节点的下标比左子结点大1。 temp保存的是给定的非叶子节点中的值。 arr[k] &gt; temp 说明左右子节点中较大的那个要比他要大，那么就把他赋给当前给定的非子节点。 为什么 i = k。为什么要循环比较？ 非叶子节点不是只有叶子节点，他们的子节点也会有子节点。假定我们让子节点的值变成非叶子节点的那个值，而非叶子节点的值又是很小的。那么那个子节点构成的岂不是大顶堆了？所以还是要递归下去继续构造大顶堆。 为什么else break？ 其实这个问题应该在第二个问题的前面的。我们构造大顶堆其实是从下往上构造的。也就是说从arr.length/2-1到0这个顺序来构造的。也就是说我们在构造非叶子节点i的过程中就知道他的左子树和右子树其实都是大顶堆。如果我们没有进行交换也就没有破坏左子树和右子树的大顶堆结构，如果进行交换了就有可能破环了他们的大顶堆结构了。毕竟如果交换了，说明非叶子节点的值要小一点嘛。你不能确保他比子节点的子节点的值要大。 arr[i] = temp 是什么意思？ 你或许发现了，我们始终没有说交换，这就有点像移位法的味道了。我们只是给i找到合适的位置，（第二个问题中的i = k 就是在做这个事情）当for循环退出了，意味着i的位置就找到了，这时给之前保存好的temp安上去就行了。 堆排序代码public static void heapSort(int[] arr) { int temp = 0; // 将其变成大顶堆 for (int i = arr.length/2-1; i &gt;=0; i--) { adjustHeap(arr, i, arr.length); } // ：将大顶堆上面的元素交换到末尾，然后对大顶堆最上面的元素排序 for (int j = arr.length-1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } } 代码说明： 第一个for循环? 其实第一个for循环就是我们上面说过的，大顶堆是从下往上构造的。只有这样我们才能确保要构造的非叶子节点的左子树和右子树都是大顶堆。 第二个for循环？ 将构造好的大顶堆的根的值(arr[0])放到数组的最后面，然后把数组最后面的元素移动到根处。并且还要将要进行构造大顶堆的 length-1，因为已经最大的那个数已经不用再去构造大顶堆了，安心在数组后面躺着吧。 adjustHeap(arr, 0, j)，这次构造大顶堆为什么没有循环了，而一开始需要循环？ 因为一开始的数组对应的二叉树的根节点的子树不是大顶堆。而此时，将一个大顶堆的根节点移走，然后取他的一个叶子节点作为新的根，这个新的二叉树虽然不再是大顶堆，但是根节点的左右子树依然是大顶堆。所以说不用再循环了。 堆排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); heapSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 9ms Time : 0ms Time : 15ms 8,000,000数据时： Time : 1686ms Time : 1703ms Time : 1672ms 总结 什么这个0ms你是认真的吗？我测试了几次，有好几次0ms，但是全写0ms有点太高调了，所以还是让你大一点，防止你骄傲。不过说实话处理八百万个数据的时候，堆排序处理的并不快。毕竟是空间复杂度O(1)的算法，对于海量数据的处理还是略显疲软。不过这并不然掩盖这个算法的光辉之处，能想到这样的排序算法，图灵奖获得者——弗洛伊德是真的牛逼。这个人好像写了不少有名的算法。QwQ]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（七）基数排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（七）基数排序 这里说的是基数排序(Radix Sort)而不是计数排序(Counting Sort)，计数排序也是另外的一种比较高效的排序算法，但是这个算法不在我近阶段要讲的算法之列。说起和基数排序类似的算法，桶排序(Bucket Sort)其实就是和基数排序是有点儿相似的，不过桶排序也不在近阶段介绍之列，蛤蛤蛤~~(⊙o⊙)… 基数排序的的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 一般 我们发现这个基数排序的时间复杂度似乎是比O(nlogn)要低的，但是这个O(nlogn)是比较类的排序算法的下限，基数排序是一种典型的使用空间来换取时间的算法，不属于比较类排序算法。另外要说的是，基数排序是一个稳定的算法。 基数排序的基本思路 基数排序的基本思路是准备十个桶。从0号桶到9号桶。第一次我们使用个位数进行排序，然后把数据从桶中依次取出来。第二次使用百位数进行排序。。。以此类推就这样这个数组就是有序的了。这个思路还是比较容易理解的。 下面直接上图吧。 再来一个图片看一下子 这个算法算是一般流弊算法吧。因为特别容易理解，没啥需要理解的，搞得我都不知道要说什么啦。。。 直接来上代码看代码的实现吧。 基数排序的代码实现 public static void radixSort(int[] arr) { int[][] backet = new int[10][arr.length]; int[] backetElementsCounts = new int[10]; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } // 下面两种方法都可以选择 转为字符串求数字的长度 int maxLength = (max+&quot;&quot;).length(); // int maxLength = Integer.toString(max).length(); for (int i = 0, t=1; i &lt; maxLength; i++, t*=10) { // 数据放入桶中 for (int j = 0; j &lt; arr.length; j++) { int which_backet = arr[j]/t%10; backet[which_backet][backetElementsCounts[which_backet]++] = arr[j]; } // 把数据从桶中取出 for (int j = 0, k=0, m=0; j &lt; 10; j++) { while (backetElementsCounts[j] != 0) { arr[k] = backet[j][m]; backetElementsCounts[j]--; k++; m++; } m=0; } } } 代码说明： 第三行代表的含义是什么？ 第二行代码其实就是在造桶子，十个桶子，每个桶子的大小的都是arr.length，因为万一所有的数的某一位都是相同的，那个桶子不就爆了喵？？而第三行的数组是存放每个桶子中的元素的个数。因为下面还是要取出元素的，不知道放了几个元素，怎么取，玩蛇皮的嘛。 为什么要求最大的数字的长度？ 这个把数字转为字符串来求长度还是非常的妙的。不过你问为啥要求最大的数字的长度？？因为后面我们要从个位数开始根据每个位置开始排序啊。 t的作用是什么？ 第一次取到个位数就是 num/1%10。取百位数就是 num/10%10。我们通过每次t /= t就可以依次取到各个位数了。每次放入一个元素之后，对应的用来计数的数组中的值也要增加1. 如何取出数据的？ 这恐怕是更容易理解的。找到桶里有数据的桶，看看桶中有几个数据取出来放到原来的数组中不就完事了。 唉~，这个算法是实在简单，搞得我是真的没话说了。我也是醉了吖。。。 基数排序的测试 测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); radixSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 12ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 423ms Time : 397ms Time : 404ms 总结 可以清楚的看到排八万个这种小数据的时候，几种高效的算法几乎没有区别。不过排八百万个数据的时候，基数排序就发挥出了他的优势。快啊！不过要说明的是，基数排序极其占用内存，如果是排序八千万个数耗费的就是4个G左右的内存，所以说在内存不足的情况下，这个算法是不适合考虑的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（六）归并排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（六）归并排序 归并排序算法是分治算法的一个典型。所谓分治算法就是把一个复杂的问题分成多个子问题。这些子问题如果都解决了，这个复杂的问题也就解决了，这是典型的先分后治的思路。归并排序也算得上是一个比较复杂的算法了，说实话原理容易看懂，但到底是如何解决的可要大费脑筋了。 归并排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 是 你或许看到了，是否牛逼那一块我写的是是，那这个算法也就是我们第一个接触到的，流弊的排序算法，因为速度是很快的。同时你也可以看到空间复杂度是O(n)，要知道很多复杂的算法以及各种各样的缓存机制，数据库等等都是使用空间来换取时间的，不过这样也并不意味着排序算法的时间复杂度可以变成O(1)，算法导论中有证明，排序算法的最低时间复杂度是O(nlogn)。 归并排序的基本思路归并排序的思路很难将明白，但是举个列子就很好说了。假如有待排序的数组4 1 2 5 8 7 6 0.我们找到mid((left+right)/2)先将其分为两个数组4 1 2 5和8 7 6 0（实际上我们并没有真的的分为两个数组，操作的始终是原来的那个数组）,然后再分为 4 1，2 5,8 7,6 0，然后继续分成 4,1,2,5,8,6,7,0.到这儿你或许会说，卧槽你这不是玩我的嘛，分了半天就是把数组之间加上逗号？玩蛇皮？其实我们的目的不在于分，而在于治。将 4 和 1 排成一个有序的数组简单不？就是 1 4 同理第一轮治理数组就变成了1 4 2 5 7 8 0 6然后再将1 4 和 2 5排序 7 8 和0 6排序。数组变成了1 2 4 5 0 6 7 8最后对1 2 4 5 和0 6 7 8 排序。数组变成了0 1 2 4 5 6 7 8，这样就变得有序了。 你或许在想，卧槽！这什么垃圾算法？这个速度也能快？这能叫流弊算法？ 但是人家是真的快啊，而且你没有注意到的是，我们始终在做一件事情，把两个有序的数组合并为一个有序的数组。这就是这个问题的子问题，我们只有解决了这个问题也就解决了排序这个复杂的问题了。把两个有序的数组合并为一个有序的数组真的是一件简单的事情，只需要一个额外的临时的数组的帮助就可以轻松的解决。 看了下面的这个图，应该就很容易理解了。把数组中的元素往下放就是下面有一个临时数组。 归并排序的代码实现首先我们先来完成治的过程，两个有序数组的合并 “治”的代码实现public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left;// 左边有序序列的初识索引 int j = mid+1;// 右边有序序列的初识索引 int t = 0;// 指向temp临时数组当前的序列 // 将左面和右面的值按照大小放入到临时的数组当中去 while (i &lt;= mid &amp;&amp; j&lt;=right) { if (arr[i] &lt;= arr[j]) { temp[t] = arr[i]; ++t; ++i; }else { temp[t] = arr[j]; ++t; ++j; } } // 如果左面还剩下数据的话，直接放入临时数组中，此时右面的已经都放入了临时数组中。（上面while退出就是一个已经放完了） while(i &lt;= mid) { temp[t] = arr[i]; ++t; ++i; } // 同理，左面为空，右面还有数据，直接放入临时数组当中 while (j &lt;= right) { temp[t] = arr[j]; ++t; ++j; } // 将temp拷贝到原始的数组当中去。注意放入临时数组的范围是从left到right t = 0; int tempLeft = left; while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; ++t; ++tempLeft; } } 代码说明： 函数的参数是？？ 首先需要说明的是，数组其实是没有分的，只是逻辑上分为了几个数组，待合并的数组也还都是相邻的。 left是左边有序数组的开始 mid是中间的那个数，也就是(left+right)/2，需要注意的是，mid这个位置的值是属于前面的那个数组的，所以说右边有序数组的开始是mid+1。right是待合并的数组的结束。也就是说这个函数操作的只是数组的arr[left]到arr[right]而已。 temp 是用来辅助排序的临时数组 第一个while循环在干啥？ 很好理解第一个while循环是不停的把两个有序数组中的元素放入临时数组中去，直到有一个数组为空了，就退出while循环。这时，我们就可以直接把不为空的那个数组放入到临时数组的后面。于是便有了后面的两个while循环。 最后一个while循环是? 把临时数组中的元素拷贝到待排序数组的left到right上。我前面说过，数组其实并没有真正分为两个，只是逻辑上分为两块而这一个函数操作的就只是数组的left到right。也就是说一个函数只是解决了一个子问题。 “分”的代码实现public static void mergeSortHelper(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right)/2; // 找到中间值，开始分治 mergeSortHelper(arr, left, mid, temp); mergeSortHelper(arr, mid+1, right, temp); merge(arr, left, mid, right, temp); } } public static void mergeSort(int[] arr) { int[] temp = new int[arr.length]; mergeSortHelper(arr, 0, arr.length-1, temp); } 代码说明： 这我咋有点看不懂？ 虽然治才是分治法的核心但是这里的分确实是有点不好理解。不好理解的主要原因是你对递归的了解还不够透彻。上面将数组分为了两个部分，然后合并。 一开始左右不是无序的吗？怎么能合并呢？ 这就是我所说的递归的理解了。执行到第一个mergeSortHelper时会一直递归，递归到left == right退出递归。执行下面的第二个mergeSortHelper，需要注意的是此时位于的是退出的那个栈的前一个栈，也就是right - left == 1的那个栈。回到那个栈之后又是一直递归。又到了left == right又退出了递归。那么执行到第三个合并的时候位于那个栈呢？此时第一个mergeSortHelper的栈都位于底部。最上面的那个栈是left = 0，mid =0， right=1。为什么呢？因为退出的那个栈是left == right而这个right就是上一层的mid 也就是说mid = (left + right)/2是为0的。而这个栈是没有退出的也就是说left &lt; right。所以right =1；。。。。我特喵的再将什么。算了不说这个递归过程是如何的了。直接通俗的将一下吧。 我听不懂你乱七八糟的说辞，可以讲的简单一点吗？ 双递归函数本来就有点乱，况且后面还带了一个函数，我理解的也不是很透彻。简单的将就是mergeSortHelper的作用是left到right变得有序，第一个mergeSortHelper因此就是使左面有序，第二个是使右面有序，第三个是使左右两个有序的合并。 这也行？讲的也太敷衍了吧。。。 其实一点都不敷衍，你看看其他的两次递归算法。比如斐波那契数列，汉罗塔问题。不都是这样解决的吗？ 斐波那契数列代码public static int fibonacci(int n){ return (n==1 || n==2)?1:fibonacci(n-1)+fibonacci(n-2); } 汉罗塔问题代码public static void hanoi(int n,char a, char b, char c){ if (n == 1){ System.out.println(a+&quot;-&gt;&quot;+c); } hanoi(n-1, a, c, b); System.out.println(a+&quot;-&gt;&quot;+c); hanoi(n-1, b, a, c); } 上面的两串代码都是即兴瞎写的不保证对，但是思路是一样的。你说这些递归问题都是如何解决的呢？如果说斐波那契数列比较容易理解，这个肯定是可以算出的啊。那么汉罗塔问题呢？？这个问题够复杂了吧。将n个盘借助b从a移动到c，我们只需要分析子问题是什么——子问题是将n-1个盘借助c移动到b，然后将最大的那个盘从a移动到c，然后再借助a把n-1盘从b移动到c。这里我们只需要知道1个盘怎么移动，那么2个盘，3个盘就是999999个盘我们都可以知道。（如果有64个盘，有一个人知道如何移盘，假设他一秒移动一个盘子，那么移动到太阳系没了也不会移完的。）归并排序也是如此。当right只比left大一的话(此时不用多次递归)就可以合并这个数组，那么当right比left大得多的时候呢？不就是根据先把左右有序然后合并一样的道理吗？这就是递归解决问题的神奇之处。 归并排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Randon.nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); mergeSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 11ms Time : 12ms Time : 16ms 8,000,000数据时： Time : 1029ms Time : 1024ms Time : 1007ms 总结可能是测试的时候电脑的问题，为啥归并排序排8,000,000还比快速排序慢啊，这个其实很意外，按照时间复杂度来说应该是归并排序快一点啊。不过再我多次测量了之后，速度稳定在1000ms，放弃了。唉~，只能说一句，快速排序牛逼！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（五）快速排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（五）快速排序 希尔排序是插入排序的升华，这里说的快速排序其实就是冒泡排序的升华？（啥？冒泡排序终于有了出人头地的机会了。。）不过我反正是很难看出来快速排序和冒泡排序之间的关系多的。冒泡排序是相邻的两个值之间进行比较然后进行交换，而快速排序是一种递归的过程。。真心发现不了其中的关系。 快速排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) 一般 之前也已经说过了，快速排序是一种不稳定的排序算法，是冒泡排序的一种优化，至于是如何优化的，后面一起看一下子吧。 快速排序的基本思路希尔排序是将数据分组进行插入排序，那莫非快速排序就是把数据分组进行冒泡排序？其实并不是。 快速排序的思路是： 以当前的数组中的一个元素(一般取第一个元素也就是arr[0])作为基准值，然后将数组变换为左面的数都比基准值小，右值的值都比基准值大，然后对左面的那一块和右面的那一块进行同样方式的快速排序。直到发现待排序的数组的大小只有1的时候就退出。此时数组也就变得有序起来了。 下图中是将数组的最后一个作为基准值的，其实都是一样滴~ 这张图是以最左面的值作为基准值的，讲解的也蛮不错的，就是画质太渣了。 可以清楚的看到上面两个快速排序的实现思路是有一点不同的。第一张采用的是移位法，第二张采用的是交换法。所以说，和插入排序，希尔排序一样，快速排序也有两个实现的思路。 快速排序——交换法代码实现public static void quickSort(int[] arr, int left, int right){ // 这个是后面的递归的退出的条件 if (left &gt;= right){ return; } int temp = arr[left];// 最左面的值作为基准值 int l = left; int r = right; int t;// 用于下面的数据的交换 // 其实交换用不着额外的变量可以使用异或的操作来进行 a^=b^=a^=b 就可以对整型变量的值进行交换 while(l &lt; r){ // 从右面找到比基准值小的下标 while(l &lt; r &amp;&amp; arr[r] &gt;= temp){ --r; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; // 从左面找比基准值大的下标 while(l &lt; r &amp;&amp; arr[l] &lt;= temp){ ++l; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; } // 退出的时候 l == r 这是肯定的毕竟每次都是只走一步l和r必定会相遇。相遇的时候arr[l] == temp! // 对数组的左面和右面进行同样操作，也就是递归.其实两个if是多余的，上面已经有了退出递归的条件了。不过加上if就可以减少一次递归的次数，何乐而不为呢？ if (left &lt; l-1){ quickSort(arr, left, l-1); } if (l+1 &lt; right){ quickSort(arr, l+1, right); } } public static void quickSort(int[] arr){ quickSort(arr, 0, arr.length-1); } 代码说明： 基准值为什么选第一个数？ 其实你要是乐意的话，left到right之间的任意一个值都是可以取的。只要你有本事写出对应的算法就完事了。一般情况下我们是取第一个值(arr[left])或者最后一个值(arr[right])的。 基准值的选择会影响后面的代码？ 这肯定的啊。要不然选个锤子的基准值的。后面我们做的事情就是不停的交换使得基准值位于这样一个位置——左面的值都比他小，右面的值都比他大 这个到底是如何做到的，我看只是只是l和r不停的交换的啊？ 如果你仔细留意我上面的倒数第一张图的话，你会发现虽然是l和r的交换，实际上每次都有基准值的参与。一开始基准值位于arr[l]，我们从右面找到了第一个小于基准值的数，经过第一次的交换我们就可以确定当时r右面的值都是比基准值大的。此时基准值位于arr[r]。我们又从左面找到第一个比基准值大的数，进行第二次交换，基准值的位置又到了arr[l]，此时我们依然可以确定l左面的值都是比基准值小的。如此一来循环往复。我们始终可以确信的是，left到l-1上的值都是比基准值小的，r+1到right上的值都是比基准值大的。直到l和r相遇，基准值位于arr[l]处，他左面的值都比他小，右面的值都比他大。 为什么一开始先从右面开始，也就是说为什么先从右面找第一个小于基准值的数？ 因为一开始选定的基准值是位于arr[left]的吖，如果你选定的是arr[right]作为基准值的话，你就要先从左面开始找大于基准值的数了。如果你选定的是其他位置的话。。你为什么要那么欠呢？如果你不嫌麻烦的话，当我没说。。。 快速排序——移位法代码实现public static void quickSortPlus(int[] arr, int left, int right) { if (left &gt;= right) return; // 此时不用排序 int temp = arr[left];// 记录基准值。 左面的数都比基准值小，右面的都比基准值大 int l = left; int r = right; while (l &lt; r) { // 从右面找到比基准值小的数 while (l &lt; r &amp;&amp; arr[r] &gt;= temp) { --r; } // 移动到左面， 此时第一轮的时候基准值被覆盖 arr[l] = arr[r]; // 从左面找到比基准值大的数 while(l &lt; r &amp;&amp; arr[l] &lt;= temp) { ++l; } // 将大的数移动到后面，此时后面的那个比基准值小的数被覆盖了 arr[r] = arr[l]; } // 退出循环的时候l==r 此时这个位置就是temp这个基准值应该插入的位置 arr[l] = temp; // 递归下去对左右两边进行排序 if (left &lt; l-1){ quickSortPlus(arr, left, l-1); } if (l+1 &lt; right){ quickSortPlus(arr, l+1, right); } } public static void quickSortPlus(int[] arr){ quickSortPlus(arr, 0, arr.length-1); } 移位法其实说的已经蛮多的了，这里就不再赘述了。其实代码也就改了几行而已。也么得什么好说的。 快速排序的测试public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); quickSortPlus(arr); // quickSort2(arr, 0, arr.length-1); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 80,000数据时： Time : 14ms Time : 23ms Time : 25ms 8,000,000数据时： Time : 836ms Time : 804ms Time : 772ms 移位法 80,000数据时： Time : 14ms Time : 13ms Time : 15ms 8000000数据时： Time : 734ms Time : 848ms *Time : 832ms 总结 感觉也没啥好说的，这个快速排序是真的蛮快的了。不过这还并不是最快的，虽然他名字是快速排序。。。至于我一开始提到的那个快速排序是冒泡排序的改进，我是真的没怎么发现这两个算法之前的联系有多么的紧密。你说希尔排序是插入排序的改进，这个我能看出来，快速排序和冒泡排序。。。额，还是我太蠢了吗？看不粗来啊！至少速度上，是看不出来，，，蛤蛤蛤，冒泡排序哭死~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（四）希尔排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（四）希尔排序 之前说的是插入排序，虽然插入排序的效率嘛已经说是可以的了，但是插入排序有一个明显的漏动。比如说给定的数组如果是 1 2 3 4 5 6 7 8 9 0使用插入排序要将这个0移动到数组的最前面还是非常费力的。也就说是如果有很多小数据位于数组的末端，插入排序的效率就会极大的降低。而这次要说的希尔排序就是插入排序的一种，也就死来解决这个问题的。 希尔排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 希尔排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 一般 希尔排序虽然是插入排序的一种优化，但是希尔排序是不稳定的，插入排序是稳定的。于此类似的是快速排序是冒泡排序的优化，但是快速排序不稳定，冒泡排序稳定。不过。。稳定性这个玩意我到现在还没有用到过。 希尔排序的基本思路希尔排序的基本思路就是分组进行插入排序。就还比如说上面的那个数组 1 2 3 4 5 6 7 8 9 0，我们将其分为五组，1 6 ，2 7.3 8.4 9.5 0。对这五组数据进行插入排序，那么清晰的可以看见0到前面却。然后将数据分为两组，继续插入排序。再将数据分为一组(此时就是插入排序了)进行排序就完事了。既然希尔排序中包含这插入排序那为啥希尔排序的速度还比插入排序快啊，希尔排序的前面的几次分组将小的数据往前面进行了移动，最后的那次插入排序移动的次数是很少的。所以说希尔排序是一种较为高效的算法。 下面的图片基本上就讲的比较清楚了。 再来一个图片演示一下 希尔排序和插入排序一样，都有交换法和移动法的实现，我们就分别都用代码演示一下。 希尔排序——交换法代码实现//这也是插入排序的一种 ,因为插入排序是 ,如果小的数在后面的话 插入排序的效率特别的低,所以出现了希尔排序，是插入排序的一种改进 public static void shellSort(int[] arr) { int temp = 0; // System.out.println(&quot;原来的数组：&quot;+Arrays.toString(arr)); // 这里的gap指的是不同的组数据之间的距离。 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { for (int j = i; j &gt;= gap; j -= gap) { // 交换的次数太多了 太浪费时间 if (arr[j] &lt; arr[j - gap]) { temp = arr[j]; arr[j] = arr[j - gap]; arr[j - gap] = temp; }else break; // 分组进行插入排序，如果上面的条件不成立就说明已经插入到了指定的位置。 } } // System.out.println(&quot;第x次排序：&quot; + Arrays.toString(arr)); } } 代码说明： gap是什么？ gap指的是同一组当中相邻的元素之前的距离。初始值是arr.length/2，以后每次都除以2，这就是为什么我在一开始的那个数组中先分为五组再分为两组最后再分为一组。等到gap等于1也排序完成了之后，gap/2变成了0，此时排序完成，就可以退出循环了。 i和j代表着什么含义？ i从gap开始是为什么？ i代表的是每组元素的后面无序元素，从每组第二个元素开始。这就好比插入排序，每一组的第一个元素是有序的，而后面的元素是无序的，我们要将后面的无序的数据插入到前面的有序的数据中。其实我们完全可以写了个函数insertSort(int arr[], int gap)。gap等于1的时候就是上面篇博客当中的插入排序的算法。 j就是要插入的元素所在的位置，只不过这一次他前面的那个元素不再是j-1，而是j-gap， 如果理解了上篇博客的插入排序的思路的话，这个希尔排序也是非常容易理解的。 有三层for循环，效率为什么高？ 有三层for循环并不代表这时间复杂度就是O(n^3^)，第一层for循环每次都除以2，时间复杂度是O(log2n)。第二层的for循环每次都加1，时间复杂度是O(n)，第三层for循环的每次都减去gap，复杂度也在O(logn)左右。所以这个算法的时间复杂度是O(nlog^2^n)。数据量越大，越是比O(n^2^)的排序算法来的优越。 希尔排序——移位法代码实现 // 和插入排序法相似，希尔排序也有两种实现的方式，一个是上面的那个交换法，另一个就是下面的移动法。 // 采用移动法 对交换式的希尔排序进行改进 思路与之前的插入排序是相似的 public static void shellSortPlus(int[] arr) { for (int gap = arr.length/2; gap &gt; 0; gap/=2) { for (int i = gap; i &lt; arr.length; i++) { int insertIndex = i; int insertVal = arr[i]; while (insertIndex-gap &gt;=0 &amp;&amp; insertVal &lt; arr[insertIndex-gap]) { arr[insertIndex] = arr[insertIndex-gap]; insertIndex -= gap; } arr[insertIndex] = insertVal; } } } 代码说明： 其实这个代码也没有什么要说明的，这就是插入排序的套了个gap嘛。不懂的可以去看看插入排序的那个算法去。嘤嘤嘤~ 希尔排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80,000个和8,000,000个[0, 800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random() * 800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); shellSort(arr); // shellSortPlus(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot; + (end_time - start_time) + &quot;ms&quot;); } 交换法 80,000数据时： Time : 14ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 2008ms Time : 2018ms Time : 1973ms 移位法 80,000数据时： Time : 17ms Time : 17ms Time : 15ms 8000000数据时： Time : 1868ms Time : 1824ms Time : 1873ms 总结希尔排序虽然只是对冒泡排序的一个小小的改进，但是看到了这个希尔排序的速度后，这肯定是要惊呆了！！什么！！！排序八百万个数据也就和插入排序法排序八万个差不多！什么！！冒泡排序法，，它。。要寻短见？ 这不能喽，程序员需要冒泡排序法！你排七八个数据难道还要写归并排序，堆排序嘛，还不是一个冒泡排序写的舒服~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（三）插入排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法(三) 插入排序法插入排序算法，冒泡排序算法，和选择排序算法三个合称三大基本排序算法，因为都是相对比较简单易懂的算法，相对来说算法的效率也是比较低的。但是这个插入排序算法比起冒泡选择来说难度还是高一点的，而且在学校中教授的也只有冒泡排序和选择排序，插入排序是没有教授的。 插入排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 插入排序法 O(n^2) O(n) O(n^2) O(1) 否 插入排序算法是一种稳定的算法，和冒泡排序是一样的，相同的数据经过插入排序之后相对位置是不变的。 插入排序的基本思路插入排序的思路是将待排序的数组分为两个数组，左面是有序的数组，右面是无序的数组，（一开始左边的第一个元素就自成一个有序数组，毕竟只有一个元素，怎么说都是有序的）然后将无序数组的第一个数据插入到有序的数组当中去。于是有序的数组越来越大，等到无序的数组中的所有的元素都插入到了有序的数组中的时候，排序就完成了。 对于无序的数据如何插入到有序的数组当中去有两个实现的办法。一个是交换法，另一个是移位法。上面的动图实现的就是交换法。让我们先从简单的交换法讲起。 插入排序——交换法的代码实现感觉这个算法看一下上面的那个动图就能清楚的明白。就是如同冒泡排序法一样，如果要插入的数据被前面的数据小的话，两者交换数据，然后继续比较，直到插入的数据大于前面的那个数据(此时便插入到了合适的位置了)退出循环即可。 // 插入排序， 使用直接交换的方法，这样交换的次数就非常多了，效率就变低了 public static void insertSort(int[] arr) { int temp;// temp用于下面的交换 // 左面有一个数据是有序的，无序的数据是从第二个开始的，所以i的初始值为1 for (int i = 1; i &lt; arr.length; i++) { for (int j = i; j &gt; 0; j--) {// 使用交换的方式来插入当前的数据 if (arr[j] &lt; arr[j-1]) { temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; }else { // 如果上面的if不成立就说明这个数已经到达了指定的位置，因为左面的数组是有序的。 break; } } } } 代码说明： i 为什么从一开始？ ​ 因为插入的值是从无序开始的，而一开始arr[0]就是有序的，无序的从arr[1]开始，所以i是从1开始的。 j。。。好像没啥好说明的。这个代码还是非常容易理解的。还是叭说了QwQ 插入排序——移位法的实现移位法不是交换数据来实现数据的插入，而是先把待插入的数据保存起来。然后依次与前面的有序的值进行比较。如果前面的值比待插入的值大的话，直接将前面的值赋给后面的值(就好像移动位置一样，前面的值将后面的值覆盖了)。然后继续比较。如果小于的话，直接将当前的位置赋予之前保存的那个待插入的值，然后退出本次循环。 // 采用的是移位法不是交换法，极大的提高了插入排序的效率 public static void insertSortSgg(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { int insertVal = arr[i];// 保存要插入的值 int insertIndex = i; // 要插入的位置。。。 // while循环找到了当前值应该插入的位置 while (insertIndex &gt; 0 &amp;&amp; insertVal &lt; arr[insertIndex-1]) { arr[insertIndex] = arr[insertIndex-1];// 将大的数据后移 insertIndex--; } arr[insertIndex] = insertVal; // 插入数据 } } 代码说明： insertVal和insertIndex是干什么用的？ insertVal用于保存当前要插入的值，也就是后面的无序的数组的第一个元素。如果不保存的话，根据移位法，要插入的值将可能被前面的值覆盖，那还玩个蛇皮！ insertIndex是保存要插入的位置，初识值就是要插入的值的原本的位置（即没有发生移位）。 while循环写的是什么玩意，我为啥看不懂？？ while循环里面的第一个条件是保存你不能插到数组的外面去（咋滴，你是想飞还是干啥，想插入到数组的外面去？），第二个条件是要插入的位置的前面的位置的值要比要插入的值大。刚才也分析过了，如果比要插入值小的话，就说明要插入值放在这个位置是正确的。（前面的位置比他小，后面的位置比他大）注意：此时要插入的值后面的那个值是和当前位置的值相同的。insertIndex是因为满足了insertVal &lt; arr[insertIndex-1]（上一层循环的条件,因为insertIndex–同时由于数据右移了，所以，在本层循环应该是 insertVal&lt; arr[insertIndex+1]）这个条件才来到这个位置的。所以说，如果不满足这个条件，insertVal就应该放在insertIndex上。 while循环里面是干啥？ 进入while循环就意味着满足 insertVal &lt; arr[insertIndex-1]这个条件也就是说如果insertVal放在insertIndex这个位置是 arr[insertIndex] &lt; arr[insertIndex-1]，后面比前面小，这不满足条件啊，所以说要移动位置继续向前探索！ 插入排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*80000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); insertSort(arr); // insertSortPlus(arr); // insertSortPlusPlus(arr); // insertSortSgg(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 Time: 2531ms Time: 2340ms Time: 2376ms 移位法 Time: 1580ms Time: 1580ms Time: 1540ms 总结和冒泡排序，选择排序比起来插入排序有一定的优势，毕竟是基本算法中既有稳定性，速度还可以的算法啦。移位法的速度比选择排序快一点，交换法虽然慢一点但是容易理解。这个移位法其实蛮容易理解的，可能是我没有画图，所以讲的不清楚吧，下次我把图补上(网上没找到合适的图)，应该就好多了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（二）选择排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（二）选择排序法选择排序算法和冒泡排序算法算是难兄难弟了，都是以其简单而闻名，也是在学校中我们主要学习的排序算法。但是不是不说，这个选择排序算法除了不稳定，其他都可以吊打冒泡排序算法。那现在难兄没了，只剩下这个难弟冒泡排序算法了。 选择排序法的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 选择排序法 O(n^2) O(n^2) O(n^2) O(1) 否 选择排序法是一种不稳定的算法，也就是说相同的数据经过选择排序法之后不一定会保持原来的顺序。 选择排序法的基本思路每次使用第一个位置的（不一定是arr[0]）和之后的数据比较，找到最小的那个数据然后两者交换。如此一来，小的数据就往数组的前面去了，数组也就变得有序了。不是我说，这个排序一看就比冒泡排序法好，因为每一轮排序只需要进行一次的交换。当然比较节省时间了。 从上图可以看出来，选择排序似乎和冒泡排序有点相似，一个是把大的数据往后边沉，一个是把小的数据往前面搬。 代码实现 public static void selectSort(int[] arr) { int temp; for (int i = 0; i &lt; arr.length-1; i++) { int minIndex = i; for (int j = i+1; j &lt; arr.length; j++) { if (arr[minIndex] &gt; arr[j]) { minIndex = j; } } if (minIndex != i) { temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } } } 代码的几点说明： i，j的作用： i变量指的是数组开始排序的位置，因为每排一个序，前面就多一个数字变得有序，所以我们就没有必要动那些已经变得有序的数组了。所以说需要排序的范围就是 i 到 arr.length -1 j变量值的是i后面的那些数据，所以从i+1开始一直到数组的结束。i的结束的数组的倒数第二数，如果i到最后一个数的话后面已经没有数据，一个数怎么说都是有序的，所以说i没有必要到最后一个数。每次arr[i]也就是当前循环的第一个数都会与后面的arr[j]进行比较，一轮之后和最小的数进行交换然后i移动到下一个数 为什么只有一次交换？ 因为minIndex变量的存在（minIndex被初始化为了i），我们可以存储找到的最小的值的下标，而不是一味的交换i与j的数据。当我们发现arr[j] &lt; arr[minIndex]时，就把minIndex = j；因为他的值更小嘛，如此一来，我们就可以得到后面的最小值的下标了。一轮循环结束之后再进行交换（i != minIndex 如果i == minIndex那就说明if语句一直都是假的，arr[i]处的值就是最小的，没有必要和谁交换啦)。 选择排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); selectSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 测试结果： Time: 1629ms Time: 1417ms Time: 1606ms 总结选择排序法虽然和冒泡排序深处基本排序算法之列，但是选择排序的速度比冒泡排序法快的不是一点半点。虽然说冒泡排序法有稳定性上面的优势，但是同处基本排序算法的插入排序法也是稳定的，而且插入排序法的效率也蛮高的。冒泡排序。。。很危险吖~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(一） 冒泡排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（一） 冒泡排序法冒泡排序法可谓是我们学到的第一个排序算法了，以其简单易懂而闻名，但是这个算法又是特别的垃圾，因为效率及其的低下。 下面是一些经典的排序算法的时间复杂度： 别看这个冒泡排序法的时间复杂度和选择，插入是一样的，但是效率却远远比选择，插入低，尤其是数据量很大的时候。 冒泡排序的思路冒泡排序的思路就是每次把最大的数挑出来放到数组的最后面(排序皆是从小到大)。如下图所示 每一次将最大的元素移动到数组的后面，移动了5次，这个数组就是从大到小有序的了。 代码的实现冒泡排序比较容易理解，代码也是比较好写的。 public static void bubbleSort(int[] arr) { boolean flag = false; int temp; for (int i = 0; i &lt; arr.length-1; i++) { for (int j = 0; j &lt; arr.length-i-1; j++) { if (arr[j] &gt; arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = true; } } if (!flag) { break; }else { flag = false; } } } 代码的几点说明： i和j的含义 可以清除的看到在两个for循环的循环体中是没有i变量的，也就是说i变量只是用来计量有几个大数被移动到了数组的末尾。 j变量是用于交换. j &lt; arr.length - 1-i的作用是后面的几个变量已经排过序了，他们就是最大的那几个数，j变量可以不用对他们进行比较交换啦。j从0开始每次和j+1进行比较，如果arr[j]大，也就是前面的数大，就把他往后面移动。如此一来，前面的几个数中最大的那个数就被移动到当前j所比较的末尾arr.lenght-1-i处。 flag的作用是什么？ flag这个是对冒泡排序法的一个优化，虽然优化过后这个算法还是一样的垃圾。。。flag所代表的含义是该次循环中有没有发生过交换。一开始我们将其置为flag(不初始化也是可以的，boolean型的变量的初始值就是false).当本次循环进行过交换的时候，将flag置为true。然后再将循环置为false。当有某次的循环中没有进行过交换，这个也就是意味着此时数组前面的那几个数已经是有序的了，而数组后面的数同样也是有序的，所以退出循环排序结束。 冒泡排序的测试：测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); bubbleSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 测试结果： Time： 8786ms Time： 8706ms Time： 8661ms 总结哇！！！八万个数据的排序才花了八秒，这个算法好厉害啊！！！我是不会告诉你后面的堆排序，归并排序排序八万个数只是用了10ms，排序八百万个也用不了一秒的。。 冒泡排序算法中有着大量的数据的交换，这就注定了这是一个低效的算法。但是还好的是，冒泡排序算法是一个稳定的算法。所谓稳定的算法就是拥有相同的值的数据在排序完之后的顺序保持不变. 比如说 8 3 4 5 3 6 排序后是 3 3 4 5 6 8，排序完的第一3仍然是原来数组中的第一个3]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用赫夫曼编码来压缩数据]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%88%A9%E7%94%A8%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[利用赫夫曼算法来压缩数据压缩文件是我们经常碰到的文件类型，一般在windows上 rar zip 7z这几种格式是最常见的。因为格式的不同他们的原理也同样不同。这里介绍的是使用赫夫曼算法进行简单的压缩数据。 首先要来了解一下赫夫曼树是什么。 赫夫曼树 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 简单的来说赫夫曼树就是WPL最小的树。 WPL计算WPL首先要知道这个树的权值，然后还要知道这个树的高度(所谓高度就是到根节点的经过的节点的个数)。 想要一个树是最优二叉树(WPL最小的树)，我们就要尽量把权值较大的数据放在靠近跟节点的地方，把权值较小的数据放在远离根节点的地方。 如何构造赫夫曼树首先我们要新建一个节点，因为赫夫曼树要比较权值的大小，所以这个节点类还要实现Comparable接口. // ：让Node是实现Comparable接口，使之可以排序 class Node implements Comparable&lt;Node&gt;{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } @Override public String toString() { return &quot;[value=&quot; + value + &quot;]&quot;; } //：返回 -1 0 1 @Override public int compareTo(Node o) { //： 表示从小到大排序 return this.value - o.value; //： 表示从大到小的排序是 return o.value - this.value } } 这样一个节点就创建好了。 接下来就可以来生成一个赫夫曼树了 class HuffmanTree { public static Node createHuffmanTree(int[] arr) { List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int val : arr) { nodes.add(new Node(val)); } while(nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // ：最小的那个节点 Node rightNode = nodes.get(1); //：第二小的那个节点 Node parentNode = new Node(leftNode.getValue() + rightNode.getValue()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } //：实现了Comparable，可以进行排序 return nodes.get(0); } } 由代码可见，上面的算法的步骤是： 1. 先将所有的节点放入到一个ArrayList中。 2. 先将这个ArrayList排序，找到最小两个节点，同时new一个新的节点，使其左节点指向稍微小的那个节点，右节点指向稍微大的那个节点。 3. 从ArrayList中去除刚才取出的两个节点，放入新的节点。 4. 循环第二步和第三步，知道ArrayList中就剩下最后一个节点。这个节点就是赫夫曼树的根节点这个算法还是蛮容易理解的，刚才所有的节点都是赫夫曼树的叶子节点，所有的非叶子节点都是我们新生成的。通过上面的这个算法，我们就能轻松的得到一个赫夫曼树。 赫夫曼编码计算机中的文件都是以二进制的格式存放的。我们先以字符串来举例。 java java java is good good but cpp cpp is best best 上面的这段话，在计算机中储存也是以二进制的文件进行储存的。我们知道一个字符对应了一个八位的byte，也就是一个ascii。那上面的数据在计算机中储存就是n*8bit。 这就是最直接的编码，每8位对应一个字符。 但是不难发现上面的字符串中存在不少的重复的字符。 j出现了3次，a出现了六次，空格出现了11次。 如果我们按照这些字符出现的顺序对其重新进行编码，不是就节省了不少的内存了吗？ 空格编为0，a编为1， o编为10， p编为11.。。。 但是这样也带来了更大的问题，比如说计算机中的11解码成aa还是p呢？？也就是说这样的编码会代码混乱，这样的编码不是一个前缀编码。前缀编码需要满足这样的条件，任何一个码不能是另外的码的前缀。 这些字符出现的顺序对其重新进行编码这种思路是对的，但是如何采取最优的措施呢？ 这不难想到上面说的赫夫曼树，字符出现的顺序就是字符的权重，构造一颗赫夫曼树或许能够解决我们的问题。 利用字符串来构造赫夫曼树首先我们要构造一个新的节点 class NewNode implements Comparable&lt;NewNode&gt;{ private Byte data;// 字母 private int weight;// 出现了多少次 private NewNode left; private NewNode right; public NewNode(Byte data, int weight) { this.data = data; this.weight = weight; } public Byte getData() { return data; } public void setData(Byte data) { this.data = data; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public NewNode getLeft() { return left; } public void setLeft(NewNode left) { this.left = left; } public NewNode getRight() { return right; } public void setRight(NewNode right) { this.right = right; } @Override public String toString() { return &quot;[data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;; } @Override public int compareTo(NewNode o) { return this.weight - o.weight; } public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } } 然后我们还需要统计每个字符出现的次数，将结果放入一个ArrayList中 /** * 由原始字节数组生成对应的集合 * @param bytes 原始字节数组 * @return 数值加权重的对应集合 */ public static ArrayList&lt;NewNode&gt; getNodes(byte[] bytes){ ArrayList&lt;NewNode&gt; nodes = new ArrayList&lt;NewNode&gt;(); //：使用map[key, value]遍历统计每个字符出现的次数 HashMap&lt;Byte, Integer&gt; counts = new HashMap&lt;Byte, Integer&gt;(); for (byte b : bytes) { Integer count = counts.get(b); if (count == null) { counts.put(b, 1); }else { counts.put(b, count+1); } } //：把键值对转为NewNode对象，并放入ArrayList中 for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) { nodes.add(new NewNode(entry.getKey(), entry.getValue())); } return nodes; } 这样这个ArrayList中就存放了字符和他的权重了。 然后我们可以利用上面的方法来构造一颗胡夫曼树。 /** * 生成一个赫夫曼树 * @param nodes 由原始字节数组形成的集合 * @return 赫夫曼数的根节点 */ public static NewNode createHuffmanTree(ArrayList&lt;NewNode&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); NewNode leftNode = nodes.get(0); NewNode rightNode = nodes.get(1); NewNode parentNode = new NewNode(null, leftNode.getWeight() + rightNode.getWeight()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } return nodes.get(0); } 这样一颗赫夫曼树就构建好了，但是如何得到我们之前说的那个最优的前缀编码呢？？？ 很简单当我们从一个节点走向他的左节点的时候，我们为编码加上0，向右走的时候加上1，因为赫夫曼树中的所有的非叶子节点都是null，有意义的仅仅是叶子节点。叶子节点是没有子节点的，所有这样生成的赫夫曼编码就是一种前缀编码。而且他也是最优的前缀编码。 获取赫夫曼编码/** * 获取赫夫曼编码表 * @param node 赫夫曼树的根节点 * @param huffmanCodes 用来储存赫夫曼编码的map * @param code 左走是0 右走是1 * @param stringBuilder 用来连接0和1 */ public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); stringBuilder2.append(code); if (node != null) { if (node.getData() == null) { getCodes(node.getLeft(), huffmanCodes, &quot;0&quot;, stringBuilder2); getCodes(node.getRight(), huffmanCodes, &quot;1&quot;, stringBuilder2); }else { huffmanCodes.put(node.getData(), stringBuilder2.toString()); } } } 可以给这个方法一些默认的参数 public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes){ getCodes(node, huffmanCodes, &quot;&quot;, new StringBuilder()); } 这样我们就得到了赫夫曼编码表。得到了赫夫曼编码我们就可以对数据进行压缩了。 压缩字符串/** * 使用赫夫曼编码压缩字符数组的长度 * @param contentBytes 要进行压缩的字符数组 * @param huffmanCodes 传入一个哈希Map，传出的就是 对应的赫夫曼表Map。可用于之后的解压！ * @return 返回压缩后的字节数组 */ public static byte[] zip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { ArrayList&lt;NewNode&gt; nodes = HuffmanTree.getNodes(contentBytes); NewNode root = HuffmanTree.createHuffmanTree(nodes); HuffmanTree.getCodes(root, huffmanCodes); String codes = HuffmanTree.huffmanCodes(contentBytes, huffmanCodes); // System.out.println(codes); int len = (codes.length() + 7)/8; byte[] by = new byte[len]; for (int i = 0, index=0; i &lt; codes.length(); i+=8) { String strBytes; if (i+8 &gt; codes.length()) { strBytes = codes.substring(i); }else { strBytes = codes.substring(i, i+8); } by[index] = (byte) Integer.parseInt(strBytes, 2); index++; } return by; } 上面的代码需要注意的是code（10100010011….)的长度不一定是8的倍数，最后的一个字符串可能是没有8位的，所以我们要进行一次判断。 至此，我们已经完成了压缩的所有的工作。进入主方法进行一次测试。 压缩前的长度：52 压缩后的长度：24 压缩率：53.84615384615385% 解压数据： java java java is good good but cpp cpp is best best 是否解压成功：true 赫夫曼编码表如下所示，可见确实是前缀编码。 {32=00, 97=010, 98=0110, 99=10101, 100=11100, 101=11101, 103=11110, 105=11111, 106=0111, 111=1011, 112=1100, 115=1101, 116=1000, 117=10100, 118=1001}生成的二进制补码如下所示，这个一看就比原来的少多了，毕竟这个字符中我估计加入了不少重复的字符。 01110101001010000111010100101000011101010010100011111110100111101011101111100001111010111011111000001101010010000010101110011000010101110011000011111110100011011101110110000001101110111011000解压字符串首先我们需要将一个byte转为一个二进制补码类型的字符串 /** * 将一个byte转为一个二进制的字符串 * @param flag 是不是最后一个不满8位的byte 看是否需要按位与来补位 true代表需要补高位， false代表不需要补高位 * @param b * @return 按补码返回的 正数的补码就是原码，负数的补码是反码+1 */ private static String byteToBitString(boolean flag, byte b) { int temp = b; if (flag) { temp |= 256;// 256: 1 0000 0000 } String str = Integer.toBinaryString(temp);//:返回二进制的补码 if(flag) { return str.substring(str.length()-8);//：只是取得后面的八位 }else { return str; } } 同样的，我们要考虑到最后几位的问题。还有补码的有关的操作我也在上面注释清楚了。 下面就可以来解压了 /** * 解压之前使用赫夫曼编码的数据 * @param contentBytes 压缩之后的字节流 * @param huffmanCodes 之前压缩的时候使用的赫夫曼编码map * @return 解压之后的字节数组 */ public static byte[] unzip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; contentBytes.length; i++) { byte b = contentBytes[i]; boolean flag = (i != contentBytes.length-1); stringBuilder.append(byteToBitString(flag, b)); } // System.out.println(stringBuilder.toString()); HashMap&lt;String, Byte&gt; reverseMap = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte, String&gt; val : huffmanCodes.entrySet()) { reverseMap.put(val.getValue(), val.getKey()); } int i=0; int count = 1; ArrayList&lt;Byte&gt; arrayList = new ArrayList&lt;Byte&gt;(); while (i &lt; stringBuilder.length() &amp;&amp; i+count&lt;=stringBuilder.length()) { Byte b = null ; while (i+count &lt;= stringBuilder.length()) { String str = stringBuilder.substring(i, i+count); b = reverseMap.get(str); if (b == null) { count++; }else { i += count; count = 1; break; } } arrayList.add(b); } byte[] resultBytes = new byte[arrayList.size()]; for (int j = 0; j &lt; resultBytes.length; j++) { if (arrayList.get(j) == null) { break; } resultBytes[j] = arrayList.get(j); } return resultBytes; } 上面将赫夫曼编码进行了对调键值，这样更有利于后面的解压。通过扫描的方式逐个进行配对。 至此，压缩和解压字符串的操作就都已经完成了。。。 等等，，不是将压缩和解压文件的吗，怎么只讲了字符串？？？ 其实刚才我们处理时并不是字符串，而是一个byte[]数组，我们只是把字符串转为了一个byte[]数组进行处理了。而任何文件都是以字节进行储存的，所以说这个解压和压缩的方法不仅适用于这个字符串还适用于各种各样的文件。如文本文件，视频，图片等，不过压缩的效率怎么样就不能保证了。只能说重复的越多，压缩的效率越高。对于文件的处理就是简单的加上Java当中IO流罢了。 直接上代码吧。 /** * 使用赫夫曼编码来压缩文件 * @param srcFile 要压缩的文件的原地址 * @param dstFile 压缩后的文件的地址 */ public static void zipFile(String srcFile, String dstFile) { FileInputStream is = null; FileOutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); byte[] b = new byte[is.available()]; is.read(b); HashMap&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); byte[] zipcontent = zip(b, huffmanCodes); // System.out.println(huffmanCodes); // System.out.println(new String(zipcontent).substring(1,10)); os = new FileOutputStream(dstFile); oos = new ObjectOutputStream(os); //：以对象流的形式写入， 方便之后的解码 oos.writeObject(zipcontent); oos.writeObject(huffmanCodes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { is.close(); os.close(); oos.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 需要注意的是：使用ObjecOutpuStream使用对象流的方式将对象写入文件中,利于后面解压的时候提取数据。注意：赫夫曼编码表需要写入到文件中,不然就没办法解压了！ /** * 使用赫夫曼编码来解压文件 * @param srcFile 需要解压的文件地址 * @param dstFile 解压后的文件地址 */ @SuppressWarnings(&quot;unchecked&quot;) public static void unzipFile(String srcFile, String dstFile) { FileInputStream is = null; ObjectInputStream ois = null; FileOutputStream os = null; try { is = new FileInputStream(srcFile); ois = new ObjectInputStream(is); byte[] zipBytes = (byte[]) ois.readObject(); HashMap&lt;Byte, String&gt; huffmanCodes = (HashMap&lt;Byte, String&gt;) ois.readObject(); // System.out.println(huffmanCodes); // System.out.println(new String(zipBytes).substring(1,10)); byte[] unzipBytes = unzip(zipBytes, huffmanCodes); os = new FileOutputStream(dstFile); os.write(unzipBytes); } catch (Exception e) { System.out.println(e.getMessage()); e.printStackTrace(); // System.out.println(e.getStackTrace()); } finally { try { if (is!=null) { is.close(); } if (ois!=null) { ois.close(); } if (os!=null) { os.close(); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 小结总的来说，上面所提供的压缩和解压文件的方式还是非常简陋的，不过还是足以让我们来了解压缩文件的本质是什么。所谓的zip 7z rar无损压缩都是采用的这个思路，利用重复！如果没用大量的重复，而是杂乱无规则的话，就是神仙来了都压缩不了1kb… ​ ———— Hony Sher 7/17/2019]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown的基本使用]]></title>
    <url>%2F2019%2F07%2F17%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown的基本语法MarkDown的基本介绍之前写笔记什么的基本上用的都是win10电脑上自带的oneNote 来写笔记的，总有点感觉写的没用那种程序员味，比起用 word 来说也好像差不了多少。 之后通过一个Up主了解到了 markdown这种语言，才明白原来程序员也用自己写笔记的专门的语言，hiahiahia。 *Markdown和HTML** 是兼容的，但是*markdown 要html的语法简单的多。下面就花几分钟的时间来熟悉一下Markdown这门语言。这里我使用的markdown编辑器是 vscode和typora，这两个编辑器都蛮好用的。 标题感觉这个标题就是最简单的了。标题和html一样分为7个大小 h1标题就是#， h2就是##，以此类催，没多加一个#标题就会变小一号。但是有要注意的是 打完#之后需要打一个空格才行，不然不会被markdown解析为标题。 # 这是一级标题 ## 这是二级标题 ... 上面我的那个标题用的是 ### 标题字体加粗语法：**加粗**; 我被加粗啦！ 斜体语法：*斜体* 我怎么斜了？？？ 删除线语法：~~删除线~~ 我不要被划线!，嘤嘤嘤 斜体加粗语法： ***斜体加粗** 就是这么强大的我！ 引用语法：&gt; &gt;&gt; &gt;&gt;&gt; 引用&gt; 再来一个&gt; 直接两个&gt; 这玩意好像真的没什么用。。 分割线语法：--- *** 三个或者三个以上的-和*都可以代表一个分割线，效果是一样的 图片语法：![图片的说明](图片的地址 &quot;移动到图片处显示&quot;) 这个图片着实令我有些头疼， 因为好像本地的图片不能弄到博客上面去。这里就去找一些网络图片吧。 ![来自我github上的一张图片](https://raw.githubusercontent.com/sheriby/cdn/master/img/custom/head.jpg ”我的头像“)超链接语法[超链接的文字](超链接的地址 &quot;超链接的说明&quot;) [我的博客](https://sheriby.github.io) 我的博客 列表无序列表语法：- + * 任意一种都可以, 注意都要有空格 - 列表内容 + 列表内容 * 列表内容 列表内容 列表内容 列表内容 有序列表语法：1. 2. 3. 数字加上点就行了 1. 列表内容 2. 列表内容 3. 列表内容 列表内容 列表内容 列表内容 多重的列表进行嵌套的时候加上三个空格就行了 内容 内容 内容 内容 内容 内容 内容 内容 表格表格的语法比较复杂一点，但是也容易理解和记忆 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码这个应该是最有用的了，虽然上面一直都在用但是现在才说。 语法 用``引入的内容就是代码。。。虽然可能并不是代码使用三个成对的```可以引入多行的代码，也可以在代码块中规定语言，有对应的语法高亮。 template &lt;typename T, typename U&gt; auto add(const T&amp; t, const U&amp; u) -&gt;decltype(t+u){ return t+u; } 结语基本上就上面的这些内容了，所以说蛮简单的，似乎五分钟都不需要就可以上手了。 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个博客 HelloWorld]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2HelloWorld%2F</url>
    <content type="text"><![CDATA[第一个博客 HelloWordpythonprint(&quot;Hello World!&quot;) c++#include &lt;iostream&gt; int main(){ std::cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;std::endl; return 0; } javapublic class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;Hello World!&quot;)； } } 友情链接Learn from codeSheep]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
