<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bootstrap栅格布局Less源码分析(i)]]></title>
    <url>%2F2019%2F12%2F08%2FBootstrap%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80Less%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Bootstrap栅格布局Less源码分析(i)前言Bootstrap是一个非常牛逼的前端框架，几乎所有人都在使用这个东西，因为Bootstrap移动优先的历练，有着非常出色的响应式布局。（所谓的响应式布局就是针对不同的设备（不同的屏幕的大小），显示的样式是不一样的）其中Bootstrap的源码都是使用Less这个非常牛逼的动态CSS语言，（上面我们刚刚介绍过）尤其是Bootstrap中栅格布局的Less源码的实现，更是值得我们每个人学习的。所以本次，我们就好好的分析一下栅格布局的Less源码。 开始Bootstrap使用的第一部就是下载Bootstrap，不过在有网络的情况下直接使用CDN也是可以的。Bootstrap的官网中有使用Bootstrap的基本使用模版。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt; &lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 观察一下模版（不看关于IE的那些hack），可以看到第六行是有关于移动设备的，是必须要加上的。不过很多情况下，我们还会使用如下的形式。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; 让网页不可以被放大或者是缩小，看起来更像是移动终端的原生应用。 然后就是第24行，引用了jQuery，Bootstrap是依赖jQuery的，不过如果我们都不使用Bootstrap的javascript的插件或者是功能其实后面的两个引用也没啥意义。 在Bootstrap中，所有的元素都被进行了优化，有了一些初始的样式。就算是不加任何的CSS，也不会想原生的那么丑。 栅格布局什么是栅格布局，简单的来说就是Flex伸缩布局，其实应该是反掉了，是先有了栅格布局才有了伸缩布局才对。 Talk is cheap, show me the code! &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;col-md-4&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;col-md-6&lt;/div&gt; &lt;div class=&quot;col-md-2&quot;&gt;col-md-2&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;div class=&quot;col-md-1&quot;&gt;.col-md-1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt;col-md-3&lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt;col-md-3&lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt;col-md-3&lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt;col-md-3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 上面就是一个简单的栅格布局，为了是栅格看起来更加的明显一点，我们可以给栅格一点儿样式。 [class*=&quot;col-&quot;] { padding-top: 15px; padding-bottom: 15px; background-color: #eee; background-color: rgba(86,61,124,.15); border: 1px solid #ddd; border: 1px solid rgba(86,61,124,.2); } 显示的样式如上图所示（图片是本地的，网上应该是看不到的。） 首先这个container容器是居中的，两边都有一定的间隙。那是因为Bootstrap中已经给container这个类设定了一些样式，还有一个容器叫做container-fluid（流体容器）。下面先来看看这两个容器的区别。 两个容器container和container-fluid的样式下面是.container的样式。 .container { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } @media (min-width: 768px) { .container { width: 750px; } } @media (min-width: 992px) { .container { width: 970px; } } @media (min-width: 1200px) { .container { width: 1170px; } } 两边设置了padding，而两边的margin都是auto表示其在水平方向上应该是居中的。(.container肯定是一个块元素的，比如最常见的div)。 后面的@media是媒体查询，根据设备的不同的大小，.container容器将有不同的表现。 大于等于1200px (lg) 此时.container的大小为1170px（两边还padding 15px）。这种设备一般是个人的pc，比如我的笔记本电脑。 大于等于992px， 小于1200px (md) 此时.container的大小为992px。这种设备一般是平板电脑之内的。 大于等于768px， 小于992px (sm) 此时.container的大小为750px。这种设备一般是大屏幕的手机。 小于768px (xs) 此时.container的大小没有限制，所以应该是auto。（注意auto并不是100%，两者不一样）这种设备一般是小屏幕的手机。 上面就是Bootstrap中的四个媒体查询的级别，不仅仅是在.container容器中，在整个Bootstrap中都是如此。每个级别都对应了两个字母，我标在了后面的括号中，含义分别如下。 lg -&gt; large md -&gt; medium sm -&gt; small xs -&gt; extra small下面是.container-fluid的样式 .container-fluid { padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto; } 经过我仔细的在源码中的查询，发现.container-fluid似乎咩有有关媒体查询的设置，那就意味这无论什么时候流体容器的大小都是auto。 当我们将上面的栅格布局的.container修改成.container-fluid之后我们会发现变成了这样子。 占据了100%的宽度，因为宽度是auto（将父元素撑满）。再次强调一下，auto和100%是不一样的，下面是对二者的说明。 width auto和100%的区别 width: auto 子元素（包括content+padding+border+margin）撑满整个父元素的content区域。 子元素有margin、border、padding时，会减去子元素content区域相对应的width值 父元素的content = 子元素（content + padding + border + margin ) width: 100% 强制将子元素的content区域 撑满 父元素的content区域 子元素有margin、border、padding时，不改变子元素content区域的width，而是溢出父盒子，保持原有值 父元素的content = 子元素的content 回归正题为什么要说到两个容器.container和.container-fluid呢，那是因为栅格的.row行必须要放置在这两个容器当中，以便为其赋予合适的排列（aligment）和内补（padding）。下面是官方文档中对栅格系统的一些说明。 “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。 通过“行（row）”在水平方向创建一组“列（column）”。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-* 不存在， 也影响大屏幕设备。 上面说的都非常的明白易懂，主要就来看看第五点和最后一点。 第五点的说明如果我们想创建列与列之间的间隙，我们需要通过padding而不是margin。为啥呢？我们使用的容器是.container，大小是确定的，而且是在父元素中居中的。当我们使用.col-md-4这种列的时候，因为.container默认就是12份，这个列的大小是确定的，就是.container的三分之一。Bootstrap在进行resetcss的时候给所有的元素都添加了一个我非常喜欢而且一直用的属性box-sizing = border-box。 box-sizing = border-box改变了CSS中盒子大小的计算方式。先来说说box-sizing的另一个取值——content-box。这也是我最初开始学习的盒子模型。当我们给一个元素设置大小的时候，其实只是设置了content了的大小。此时如果给元素设置padding，元素的可视区域的大小会变大，设置border的话也是如此。这种规定说实话我是很看不惯的。在CSS3中，我们使用box-sizing = border-box就代表，如果我们为元素设置大小，这个大小指的是border + padding + content，因此设置padding或者border并不会影响元素的可视区域的大小。(content会变小) 简单的总结一下就是。 border-box: width/height = content + padding + border content-box: width/height = content 因此我们设置padding的时候并不会改变元素的大小，元素的布局就没有改变，不过content之间确实是有了间距了。 如果我们设置的margin的话，元素的大小也没变，但是具有外边距了，原本完美的布局会因为多出来的外边距而变得一塌糊涂！下面是Bootstrap中列的源码。 .col-xs-1, .col-sm-1, .col-md-1, .col-lg-1, .col-xs-2, .col-sm-2, .col-md-2, .col-lg-2, .col-xs-3, .col-sm-3, .col-md-3, .col-lg-3, .col-xs-4, .col-sm-4, .col-md-4, .col-lg-4, .col-xs-5, .col-sm-5, .col-md-5, .col-lg-5, .col-xs-6, .col-sm-6, .col-md-6, .col-lg-6, .col-xs-7, .col-sm-7, .col-md-7, .col-lg-7, .col-xs-8, .col-sm-8, .col-md-8, .col-lg-8, .col-xs-9, .col-sm-9, .col-md-9, .col-lg-9, .col-xs-10, .col-sm-10, .col-md-10, .col-lg-10, .col-xs-11, .col-sm-11, .col-md-11, .col-lg-11, .col-xs-12, .col-sm-12, .col-md-12, .col-lg-12 { position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px; } 这一点中还有一个需要说明，默认.container是有15px的padding的，作为内容的.row是没办法占用padding这部分的空间的，但是如果我们设置了负值的margin就可以占据这部分的空间。在Bootstrap中，.row有如下的样式。 .row { margin-right: -15px; margin-left: -15px; } 最后一个点的说明上面的xs sm md lg就是之前我们说过的对于不同的设备的媒体查询。如果我们设置的是.col-md-4这个类在其他的设备中没有办法识别的，这就为我们为不同的设备提供了非常方便的方式。 比如说如下的代码 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-xs-6&quot;&gt;col-md-4 col-xs-6&lt;/div&gt; &lt;div class=&quot;col-md-6 col-xs-6&quot;&gt;col-md-6 col-xs-6&lt;/div&gt; &lt;div class=&quot;col-md-2 col-xs-6&quot;&gt;col-md-2 col-xs-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 在md的模式下显示如下。 在xs的模式显示如下。 从上图中，我们还可以看到xs下，.container的width是auto的。 不过上面我说md模式显示如下，不过我的电脑是lg模式啊，lg模式好像我们并没有为他设置显示的样式。 这就要讲到上面我说媒体查询的顺序必须是xs sm md lg这种从大到小的顺序了。lg模式是，会先应用xs的样式，然后看有没有sm的样式，然后一次往后，后面的覆盖前面的。所以这里lg应用的是md的样式，而sm应用的是xs的样式。 总结上面其实还是在简单的一步一步了解Bootstrap中的栅格布局，还没到看源码的时候呢。。。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Less</tag>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less的基本使用(iii)]]></title>
    <url>%2F2019%2F12%2F08%2Fless%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-iii%2F</url>
    <content type="text"><![CDATA[Less，更加高效好用的CSS(iii)前言前面的一个章节中我们详细的介绍了less中的最为重要的混合的知识，现在我们要进行说明的是less中的继承。继承这个玩意似乎并不是很重要，为什么呢？因为我在less的官网中没有找到任何有关的教程，就算是上网上去搜索相关的文章也没啥好看的，大多是三言两语，这就是继承什么什么的。在这里我们就来好好的看看less中的继承到底是个啥吧。 混合的一点缺陷在前面的几篇文章中把组合中我们常说的类之间的关系组合或者说混合进行比较，发现他们似乎真的是蛮相似的。现在又来了一个继承，这就不是相似的问题了，这是完全一样。不过这个既然是继承，解决的肯定是那种父类子类的那种拓展的问题。比如说，现在有一个基本的样式，但是在这个基本样式的前提下还有其他几个更加特殊的样式（也就是说在基本样式的基础上，增加了几个行的样式）。这样的问题该如何解呢？ 我想，人们的第一反应肯定是使用混合。将基本的样式写成一个混合，然后再特殊的样式中调用这个混合。比如如下的代码。 .basestyle { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; } .special-style1 { .basestyle(); padding: 20px; vertical-align: middle; } .special-style2 { .basestyle(); vertical-align: baseline; margin-top: 10px; } .special-style3 { .basestyle(); box-shadow: 0 0 3px black; border-radius: 10px; } 问题似乎很简单的就解决了（此时使用组合基类中没有使用括号，因为基类中的样式可能也要被使用，在没有使用参数的情况下是没有必要加上括号的）。不过先让我们来看一下这个编译的结果如何。 .basestyle { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; } .special-style1 { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; padding: 20px; vertical-align: middle; } .special-style2 { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; vertical-align: baseline; margin-top: 10px; } .special-style3 { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; box-shadow: 0 0 3px black; border-radius: 10px; } 说实话，不用我说是个人都应该能知道其中的问题所在——样式是真的赘余了。我们理应当使用,选择器将基类和子类的样式统统写在一起的。你要是说这种写法是否解决了这个问题，还真的是解决了这个问题，只能说解决的方式不够优雅，less给我们提供了一种全新的方式来解决这个问题——那就是继承。 继承的使用less中的继承也是使用extend关键词（可见Java的影响力是多么的大），不过使用的方式不像是组合的那个函数那样，而是有一点儿像CSS中的伪类（before, after, hover, focus），下面使用继承的方式解决上面的问题。 .basestyle { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; } .special-style1:extend(.basestyle) { padding: 20px; vertical-align: middle; } .special-style2:extend(.basestyle) { vertical-align: baseline; margin-top: 10px; } .special-style3:extend(.basestyle) { box-shadow: 0 0 3px black; border-radius: 10px; } 在对应的子类的后面写上:extend(需要继承的类)，之后子类就拥有了父类的所有的样式，而且是没有赘余的那种。上面的代码编译结果如下。 .basestyle, .special-style1, .special-style2, .special-style3 { background-color: red; color: #008000; margin-left: 20px; border: 1px solid blue; } .special-style1 { padding: 20px; vertical-align: middle; } .special-style2 { vertical-align: baseline; margin-top: 10px; } .special-style3 { box-shadow: 0 0 3px black; border-radius: 10px; } 这样的编译出来的代码才是真正的赏心悦目，足够的优雅。 其实继承也是足够的容易理解的，上面基本上就是继承的全部用法了，下面就简单的对继承进行一些说明。 继承的其他说明不能使用参数我们不能在继承中像组合那样子使用参数，也就是说继承是不够灵活的。其实仔细想想也是很容易想明白的，什么时候我们需要写有参数的继承呢？那么这个使用使用混合不是刚刚好吗？反正又不会重复。所以说继承中实在是没有必要拥有参数。 既然是肯定不能有参数，那么就意味着继承的基类是肯定要要less编译到CSS文件中去的，不过这似乎并不是一个问题。 不能使用变量选择器变量选择器是什么东西？Talk is cheap, show me the code! @selector = .parent-class; @{selector} { color: red; } .base-class:extend(.parent-class) {} // Error! .base-class:extend(@{selector}) {} // Error! 上面的两种写法都是错误的写法，不过这次说实话我也不知道为啥这个不可以用。既然人家已经告诉你这种情况下不可以使用继承，那么就避免在这种情况下使用继承吧。（不过说实话实现变量选择器就已经很少了，还要对它进行继承，这种情况属实时有点儿罕见的。） 可以使用嵌套选择器这种写法也是很少的我感觉，简单的了解一下就行了。 div { span{ color: red; } color: black; } .speclass { &amp;:extend(div span); } 上面我们顺便的补充了两个相关的知识点，继承不只是使用.类，其他的比如id tag都是可以的，只不过使用类是最好的罢了。还有就是继承的时候，也可以在类中使用&amp;:extend(继承)，因为&amp;代表的就是父类的选择器.speclass。 然后就是回到主题，嵌套的选择器div span也是可以继承的。 编译结果如下。 div { color: black; } div span, .speclass { color: red; } 精确匹配当我们使用继承的时候，继承的选择器必须要和我们定义的选择器完整的匹配。比如 div .a { color: red } .b:extend(.a) {} // Error! 虽然上面div .a和.a选择的都是同一个，但是如果只写一个.a，less是无法匹配样式的，我们必须将样式写全了才能够继承。 div .a { color: red } .b:extend(div .a) {} 分组选择器的继承问题.class1, .class2 { color: red; } .class1 { margning: 10px; } .class2 { padding: 20px } .base:extend(.class1, class2) {} 对于继承中的分组选择器会每个单独继承，所以上面的代码相当于如下。 .base { &amp;:extend(.class1); &amp;:extend(.class2); } 编译的结果如下。 .class1, .class2, .base { color: red; } .class1, .base { margning: 10px; } .class2 { padding: 20px; } 继承中属性的覆盖问题来想想这么的一个问题，如果我们当前类中和继承的类中有相同的属性会怎么样？当前的类会覆盖基类？还是和他们写的顺序有关？那就是实践一下看看到底会怎样。 .bbase { color: red; } .spe:extend(.bbase) { color: black; } 编译结果如下。 .bbase, .spe { color: red; } .spe { color: black; } 对.spe来说两个选择器的优先级是相同的，那么下面的子类中写的color就会覆盖上面的color。 不过这个顺序是固定的嘛？基类就要在上面，子类就要在下面？当然不是。 .spe:extend(.bbase) { color: black; } .bbase { color: red; } 现在我们将less中子类父类的位置换一下，看一下编译的结果。 .spe { color: black; } .bbase, .spe { color: red; } ( ⊙ o ⊙ )啊！子类中的属性竟然被父类给覆盖了，这岂不是滑天下之大稽？？要避免这样的结果，我们需要尽量将要被继承的类写在源文件的上面，防止父类覆盖子类这类事件的发生。 总结继承中的内容蛮少的，我们可以很简单的写完继承的基本上所有的内容，但是仅仅知道了继承是个啥，不知道继承怎么用也是没啥用的，后面准备针对bootstrap中的栅格布局的源码分析一下less的使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less的基本的使用(ii)]]></title>
    <url>%2F2019%2F12%2F07%2Fless%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8-ii%2F</url>
    <content type="text"><![CDATA[Less， 更加高效好用的动态CSS(ii)前言之前我们学过了less的结构化嵌套和变量，下面我们该学习一下less中的一些高端操作了。比如混合继承什么的，这些可都是高端操作！！这里我们就先来简单的聊聊混合。 简单的混合用法混合这个计算机名词我是真的没听过，不过要说是复合或者组合的话，我还清楚一点。两个类有一种关系叫做复合，在一个类中包含了另一个类，是一种has-a的关系。不知道混合和复合之间有什么关系。 官方文档对复合的解释是——混合（Mixin）是一种将一组属性从一个规则集包含（或混入）到另一个规则集的方法。那么这样看来混合和复合是真的一个意思嘛。 现在我们有一个样式需要使用，但是我们并不想将这个样式在需要的地方都写一遍，那么原生CSS中，我们做的事情就是将这些样式写成一个类，在需要的地方加上这个类就行了，这个解决办法其实还算蛮好的。但是有时候这个样式属性名都是一样的，但是里面个别的属性的参数不一致，这个时候该怎么做？那只能没辙了。原生的CSS是真的美欧办法来解决这个问题。那less肯定是可以为我们解决这个问题的。 现在我们有这样的一个样式。 .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; border-radius: 20px; } 此时有一个元素需要使用这个样式，我们只需要这样子做就行了。 .box1 { width: 200px; height: 200px; background: red; .bordered() } 编译出来的结果如下。 .bordered { border-top: dotted 1px black; border-bottom: solid 2px black; border-radius: 20px; } .box1 { width: 200px; height: 200px; background: red; border-top: dotted 1px black; border-bottom: solid 2px black; border-radius: 20px; } 这个编译结果我们其实不是很满意，上面的.bordered我们是当作一个混合来使用的，但是less也将其编译到了CSS代码中去了，这完全是一个没有用的的操作。不过是可以解决的，只需要在后面加上一个括号，less就知道你是想写一个混合，并不想将它作为一个CSS类来使用。 .bordered() { border-top: dotted 1px black; border-bottom: solid 2px black; border-radius: 20px; } 如我们想的那样，混合还可以拥有参数，less果然是强大，这混合加上的参数可以完美的解决我们的问题了。就比如上面的这个问题，边框可能需要是不同的颜色，边框的圆角也可能是不一样大的。 .bordered(@color: black, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; border-radius: @radius; } 上面我们不仅设置了参数，还设置了默认的参数。我们可以像下面这样使用这个混合。 .bordered() .bordered(red) .bordered(red, 40px) 因为函数的参数有默认值，是可以空着不写的。但是这并不代表我们不可以只对@radius赋值而缺省@color，我们可以使用下面的方式给形参（姑且这么说吧）赋值。 .bordered(@radius: 50%) 匹配模式上面就是不带参数和带参数（以及带上了默认的参数）的混合的用法，但是混合也并不是只有这么一点东西，下面需要了解的是组合的匹配模式。 首先是参数个数的匹配，下面是两个同名的函数，但是参数的个数是不相等的。 .mixins(@color, @size) { color: @color; font-size: @size; } .mixins(@opacity) { opacity: @opacity; } 和其他的语言一样(javasript这个东西似乎是一个意外)，函数的参数的个数也是函数的签名的一部分（强类型语言甚至函数的参数的类型也是函数的签名的一部分）。 .mixins(red, 10px); .mixins(0.5); 上面的调用的是不同的混合，这也算是一种简单的混合的调用。下面来介绍一个比较重要的混合模式。 还是使用上面的border作为例子，现在我们的需求是要有一个东西来做四个方向的边框的圆角，该整么办呢？我寻思这个应该是非常的好办的。直接撸四个混合分别叫做borderRadiusTopLeft。。。。等等等的，需要什么地方的混合就调用对应的函数就行了。不过这个东西是不是有一点点low呢？我们是否可以使用同一个函数完成这样的功能呢？毕竟咱们老年人记忆力差记不清那么多的函数。 .mixins(test, @parameter); 上面就是一个匹配模式，意思是调用这个函数的第一个参数必须是test，只有匹配了才可以调用。知道了这个功能我们可以很容易的写出需求的代码。 .border(topLeft, @color: red, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; border-top-left-radius: @radius; } .border(topRight, @color: red, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; border-top-right-radius: @radius; } .border(bottomLeft, @color: red, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; border-bottom-left-radius: @radius; } .border(bottomRight, @color: red, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; border-bottom-right-radius: @radius; } 这样我们就可以只使用一个函数完成上面的功能了（准确的来说是使用了四个同名的函数）。不过很容易看出一个问题，那就是上面的四个函数都有冗余的代码，重复了好多次，我们最好是将他们单独放置在一个组合中，然后在这四个组合中挨个进行调用。less早就想到了我们需要这个组合，所以说他已经提前为我们写好了。我们只需要将匹配的那部分改成@_（可以匹配任意的部内容），然后将公共的样式写在其中就行了。 .border(topLeft, @color: red, @radius: 20px) { // border-top: dotted 1px @color; // border-bottom: solid 2px @color; border-top-left-radius: @radius; } .border(topRight, @color: red, @radius: 20px) { // border-top: dotted 1px @color; // border-bottom: solid 2px @color; border-top-right-radius: @radius; } .border(bottomLeft, @color: red, @radius: 20px) { // border-top: dotted 1px @color; // border-bottom: solid 2px @color; border-bottom-left-radius: @radius; } .border(bottomRight, @color: red, @radius: 20px) { // border-top: dotted 1px @color; // border-bottom: solid 2px @color; border-bottom-right-radius: @radius; } // 调用上面的四个任意的混合的时候，都会先来调用这里的公共样式的混合。 .border(@_, @color: red, @radius: 20px) { border-top: dotted 1px @color; border-bottom: solid 2px @color; } 还有一个比较类似的东西，在C++的type_traits中也是可以看到的，那就是调用函数的值的条件检查。 .condition(@index, @para) when (@index = 1) { background-color: @para; } .condition(@index, @para) when (@index &gt;= 2) { color: @para; } .test5 { .condition(1, red); .condition(3, yellow); } 和上面一样，这也是两个同名的函数，参数也都是一样的，但是函数的后面跟着一个when条件。当index = 1的时候调用第一个函数，当index &gt;= 2的时候调用第二个函数。这个东西一般来说都是用于递归的。至于递归，这里就不多bb了，后面说到bootstrap源码的时候自然要说到递归的鬼东西。 上面的代码编译的结果如下。 .test5 { background-color: #ff0000; color: #ffff00; } 可变参数及arguments说到arguments就不得不提到javascript这门神奇的语言，还是和上面说的一样，JavaScript是一门函数的参数不是函数签名的语言，那么就导致了我们调用函数的时候根本不知道传入了什么东西。一个有两个参数的函数，我们可以不传参数，也可以传入一百个参数，这有点儿荒谬，不过有时候还是蛮方便的。javascript中将函数传入的参数都放置在一个数组arguments中，在函数中我们就可以直接遍历这个数组得到函数的所有的参数。 let sum = function() { let res = 0 for (var i = 0; i &lt; arguments.length; i++) { res += arguments[i] } return res } console.log(sum(1,2,3,4,5)) 上面的函数可以计算任意参数数字的和，但是这个函数甚至没有任何的参数。。。 下面就来介绍一下less中的arguments是如何使用的。 在less中arguments是代表组合中传入的所以的参数。比如下面的这个例子。 .arguments(@para1, @para2, @para3) { background: @arguments; } .test { .arguments(red, no-repeat, cover) } 编译出来的结果如下。 .test { background: #ff0000 no-repeat cover; } 虽然看起来是非常的方便，但是总感觉是没那么必要使用这个变量，就算不使用也问题不大。 不过骚年是否知道可变参数呢？如果我们使用了可变的参数根本就不知道参数的个数或者名字，那该如何直接使用呢？下面先来介绍一下什么是可变参数以及如何使用可变参数。 可变参数这个玩意很多语言都是有的，就连c++这们古老的语言都拥有可变参数的写法，形式就是...。在less中使用可变参数也是使用...表示很多个参数。既然是可变参数，那么就必须放在最后面，不然如果我们在可变参数的后面再跟着其他的参数，我们到底该如何使用呢？ .more-argu(@para, ...) { background: @arguments; } .test2 { .more-argu(10px, red, 20%, cover) } 上面就是可变参数的写法，不过上面的函数表示的是1-N个参数的函数，其实这样写是没啥意义的，因为想要取得可变参数中的内容就需要使用@arguments参数，但是@arguments表示的所有的参数，我们没有办法获取真的的可变参数中的内容。不过我们还是有办法的。 .more-argu(@para, @rest...) { background: @rest; } .test2 { .more-argu(10px, red, 20%, cover) } 为这些可变的参数取一个名字，一般情况下是使用的@rest（官方文档中是这么写的）。 混合的命名空间所谓的命名空间，我们最经常看到的地方就是在C++中，当我们写C++代码的时候可能会不由自主的打上一行using namespace std;其含义就是使用标准库中的命名空间，那么我们就可以使用标准库的中函数而不用每次都加上std::了。命名空间就是将不同部分的函数的作用范围隔离开。比如C++的标准库中有sort函数，然后你又写了一个sort函数，如果没有命名空间的话，两个函数就会出现重定义或者其他的什么问题，有了命名空间之后，我们就可以使用std::sort告诉编译器我要使用的是标准库的sort函数，而不是我自己写的sort函数。 #my-less-lib { .mixins() { background-color: skyblue; } } #other-less-lib { .minxis() { margin: 0; padding: 0; } } .test3 { #my-less-lib &gt; .mixins(); } .test4 { #other-less-lib &gt; .minxis(); } 上面的代码中就定义了两个不同的命名空间。my-less-lib和other-less-lib，两个命名空间中都有相同的名字的混合minxis。此时对他们我们就可以使用命名空间就行区别了。 上面的代码的编译结果如下。 .test3 { background-color: skyblue; } .test4 { margin: 0; padding: 0; } 还有所谓的条件命名空间，这里就不多扯蛋了，感觉应该是没啥用的东西。 将混合作为函数来使用这也是一种蛮高端的操作，我们可以将混合作为函数那样子进行使用。不过并不是我们想象中的在混合中使用return语句。就比如说我们讲sql中的存储过程作为函数来使用，也不是通过return的方式，而是传入out | in out参数来实现的。不过这里less中的混合作为函数来使用和他们都有一点点的不一样。 .average(@x, @y) { @result: ((@x + @y) / 2); prop: 20px; } div { // call a mixin and look up its &quot;@result&quot; value padding: .average(16px, 50px)[@result]; margin: .average(1px, 2px)[prop]; } 编译结果如下。 div { padding: 33px; margin: 20px; } 需要注意的是这个需要较高的less版本(less 3.5)。这里就简单的说到这了。 总结上面对less的混合的说明已经算是足够详细了，但是还有一个比较重要的less中的递归没有说，因为篇幅有限，还是留到下次再说吧。下面要对less中的继承进行一点说明。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[less的基本的使用]]></title>
    <url>%2F2019%2F12%2F06%2Fless%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Less， 更加高效好用的动态CSS(i)为什么会有less的出现如果要我说什么语言是写起来最烦人的，我恐怕会毫无疑问的说——肯定是CSS。原因恐怕是每个写过CSS的人很能理解的。简单的几十行代码还好，如果要是几百行上千行的CSS代码，HTML中一个div套着另一个div估计能套个十层，那种CSS代码真的非常的难以阅读了，除非是真的是隔几个样式协议注释这种的，要不然看起来是真的费劲。一千行的HTML代码看起来就是非常的清晰，因为他有结构，而CSS代码没有任何的结构可言，选择器一个套着一个，看起来非常的赘余，我们是否可以想写HTML那样写CSS呢？这是我刚开始写CSS的时候就在思考的问题。 LessLess是一门动态的CSS样式语言。正如他的名字那样，less的出现就是为了使我们写更加少的CSS代码，不仅如此，少的CSS代码还可以发挥更强大的作用。其实我们写的也不是原生的CSS的语法，而是使用less的语法，less的编译器会将我们的less语法编译成为CSS的语法，也就是说浏览器最终渲染的还是CSS，less只是一个中间产物罢了，不过这种中间产物可是一个开发利器。下面就从less的功能开始说起。 如何使用less使用less有如下的三种方式。 第一种是通过js在运行时渲染less文件。 &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;styles.less&quot; /&gt; &lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/less.js/3.10.0-beta/less.min.js&quot; &gt;&lt;/script&gt; 上面使用cdn的方式引用了less.min.js，同样的我们也可以通过下载这个文件到本地的方式进行引用。 需要注意的是上面的link的rel中的值是stylesheet/less，不是普通的stylesheet，为什么要如此呢？因为less.min.js需要找到这个属性的标签中的内容进行解析然后渲染到页面中。既然是使用js进行渲染的，那么肯定就是在运行的时候做的事情，这就极大的降低的效率，这种方式不是很推荐。不过如果就是写那么一点点less代码这种方式也是可以的。 第二种方式在Node.js的环境中使用less 先通过npm install -g less的命令安装less（前提是你的电脑中需要安装Nodejs而且你还是需要将其加入到环境变量中。然后通过lessc style.less style.css就可以将style.less这样的一个less文件编译成为style.css的css文件进行使用了。 第三种方式和第二种方式有点儿相似。 不过这里我们不需要安装Nodejs的环境，我们只需要下载一个less的桌面的实时编译软件。（如我现在使用的koala软件就具有这样的功能。）我们将CSS文件夹放入到该软件中，软件就会自动的讲我们写好的less文件编译成为同名的css文件。此时我们引用的是那个css文件，而不是less文件。同样的，在页面中，我们也不需要引入那个什么less.min.js文件对我们的less代码进行渲染了。因为我们给浏览器本身就是CSS文件。 这种方式也是现在我在使用的。不过说到底还是第二种方式最好吧。 结构化的嵌套正如我上面说到的问题，CSS代码没有结构，如果我们可以将CSS样式中进行嵌套那就好了。 比如说如下的CSS代码。 div.box { background-color: red; width: 200px; height: 200px; } div.box .minbox { background-color: aqua; width: 100px; height: 100px; } div.box p { font-size: 20px; color: blue; } div.box:hover { background-color: skyblue; } 现在的CSS代码还非常的少所以我们很容易的看清楚代码的结构，不过如果我们可以这样写的话，结构表现的可能就会更美好了。 div.box{ background-color: red; width: 200px; height: 200px; .minbox{ background-color: aqua; width: 100px; height: 100px; } p{ font-size: 20px; color: blue; } &amp;:hover{ background-color: skyblue; } } CSS的结构看的是一目了然，而且我们还可以通过像HTML那样代码的折叠观察我们真正需要注意的那部分CSS代码。可惜的是原生的CSS语法并不能满足我们这样的要求。不过试问，那个小大哥小大姐不想要这样子写代码呢？ less就提供了这样的写法。可以说认识了less之后，你就再也不想写原生的CSS代码呢，那简直就是一种酷刑。 上面的结构化嵌套的CSS代码其实就是使用less的语法写出来的。很容易理解和学习，不过如果仔细地观察的话，我们会看到一个非常默认的东西，那就是&amp;。因为写在div中的选择器选择的都是他的后代，不过我们是要div:hover这样伪选择器的需要的，如果我们就是直接写一个:hover就是相当于div :hover，这个是给div的所有的子类加上了一个hover，这样做肯定是不可以的。此时我们就需要使用&amp;。 &amp;表示的是当前选择器的父级，这样&amp;:hover就就是代表div:hover，此时就是给div加上了hover。 CSS中非常常见的一个类clearfix使用less语法可以写成下面的这样。 .clearfix{ display: block; zoom: 1; // 兼容旧版的ie &amp;:before, &amp;:after{ // 解决高度塌陷和子元素外边距传递的问题 content: &quot;&quot;; display: table; clear: both; font-size: 0; height: 0; visibility: hidden; } } 通过less的编译之后生成了如下的代码。 .clearfix { display: block; zoom: 1; } .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; clear: both; font-size: 0; height: 0; visibility: hidden; } 更多关于&amp;div.link { &amp; + &amp; { color: red; } &amp; &amp; { color: green; &amp;666{ color: red; } } &amp;&amp; { color: blue; &amp;777{ color: #00FFFF; } } &amp;, &amp;ish { color: cyan; } &amp; &gt; span { &amp;:hover { color: white; } } } 观察上面的选择器，有的都用了不止一个的&amp;，如果使用多个&amp;会发生什么呢？那就要看编译结果了。 div.link + div.link { color: red; } div.link div.link { color: green; } div.link div.link666 { color: red; } div.linkdiv.link { color: blue; } div.linkdiv.link777 { color: #00FFFF; } div.link, div.linkish { color: cyan; } div.link &gt; span:hover { color: white; } 很显然所有的&amp;都被直接替换成为了他们父级的选择器，如div.link。 需要的是替换的不只是父级的哪一个选择器，而是所有的选择器。 .grand { .parent { &amp; &gt; &amp; { color: red; } &amp; &amp; { color: green; } &amp;&amp; { color: blue; } &amp;, &amp;ish { color: cyan; } } } 被编译成了 .grand .parent &gt; .grand .parent { color: red; } .grand .parent .grand .parent { color: green; } .grand .parent.grand .parent { color: blue; } .grand .parent, .grand .parentish { color: cyan; } 注释在原生CSS中只有一种注释，那就是多行注释/* */，不过在less中我们也可以使用大多数语言使用的单行注释//了，这算是对我们这些喜欢使用//作为注释的一个体验上面简单的一个优化。 不过这还不是单行多行这么简单的一个区别。如果我们使用的是多行注释的话，使用less编译默认是将我们的注释编译到css文件中的，而单行注释是不会别编译到css文件中的。（所以什么见不得人的东西要写在单行注释中哦）。不过我们也可以修改less的编译选项，使其也不编译多行注释，甚至我们可以让他编译出来的CSS文件是一个compressed（压缩）过的版本。 变量变量的基本使用原生CSS中还有一个非常令人头疼的事情，就是没有变量。比如说如果我们在网页中经常要使用到一种颜色#ff6d3f，我们就得把这个颜色背下来，然后在需要的地方写下color: #ff6d3f或者backgroud: #ff6d3f。有一天突然又感觉这个颜色不是很好，于是又要换成#ee6dfe。就算是使用ctrl+h进行替换也是一件非容令人头疼的事情。这个时候有一个变量的好处就体现出来了。 @width: 10px; @height: @width + 10; @color: red; #header { width: @width; height: @height; background-color: @color; } 这样的less代码会被编译成为如下的CSS代码。 #header { width: 10px; height: 20px; background-color: #ff0000; } 通过@xxx: xxx;这种方式我们就可以定义一个变量了。不过我们是否可以使用一个变量作为一个属性的名字呢？或者是说作为选择器的名字呢？ 尝试下面的这种写法。 #header { width: @width; height: @height; background-color: @color; @m: 100px; @d { background-color: @color; } } 想象是非常的美好的，但是现实往往是非常的骨感。观察一下编译的结果。 #header { width: 10px; height: 20px; background-color: #ff0000; } @d { background-color: #ff0000; } @m这个属性发现都没有了，而@d这个选择器好像也要闹独立了，而且名字竟然还是@d，你说气人不气人。 经过查阅资料我们才知道，如果要使用选择器或者是属性名字的变量，在使用的时候需要加上大括号，比如上面的代码的正确的写法应该是这样子的。 #header { width: @width; height: @height; background-color: @color; @{m}: 100px; @{d} { background-color: @color; } } 此时的编译结果如下。 #header { width: 10px; height: 20px; background-color: #ff0000; margin: 100px; } #header div { background-color: #ff0000; } 这就是我们想要的结果。不过你可能带有疑问的是，为啥我们要将属性或者是选择器作为变量来使用呢？现在讨论这个问题有点儿太早了，等之后我们看bootstrap源码的时候就会知道这个东西有什么用了，这可是高端操作。 不仅仅是选择器和属性名，变量还有下面的这些用法。 // 作为URL的一部分 @img: &quot;../img/myimg&quot;; div { background: url(&quot;@{img}/hello.png&quot;) } // 作为import的一部分 // Variables @themes: &quot;../../src/themes&quot;; // Usage @import &quot;@{themes}/tidal-wave.less&quot;; // 我们可以通过变量引用另一个变量，不过这种写法确实是不常见 @primary: green; @secondary: blue; .section { @color: primary; .element { color: @@color; // @color 是primary @@color也就是@@color-&gt;@primary-&gt;green } } 变量的懒运算首先我们来一段JavaScript的代码。下面的代码是否会报错呢？如果不报错又会输出什么东西呢？ var a = b var b = 3 console.log(&#39;a = &#39;, a) // 输出还是报错呢？输出什么呢？ 估计只要是稍微有一点JavaScript的人都知道上面的代码是不会报错的，而是输出undefined。JavaScript运行的时候首先来处理变量的声明，被声明的变量还没有被定义，值为undefined。也就说上面的代码相当于这样子的。 var a = undefined var b = undefined a = b b = 3 console.log(&#39;a = &#39;, a) 为嘛要说到JavaScript中的这个玩意呢？那是因为less中的所谓的变量也有这么一手，不过两者是不怎么一样的。 .lazy-eval { width: @var; @a: 9%; } @var: @a; @a: 100%; 上面的less变量，我们也是在变量定义之前先来使用他的，这并没有报错，编译结果如下。 .lazy-eval { width: 9%; } 没有任何的问题，那是因为less会讲所有的变量声明的语句放在前面去执行，类似的@import语句也会放在最前面去执行，和JavaScript不同的是，没有所谓的undefined了。各种不同的变量可以和谐的相处。不过如果是相同的变量在同一个作用域中声明了两次的话，后面的还是会覆盖前面的声明的。如 .header { --color: white; color: var(--color); // the color is black --color: black; } 变量的作用域上面说到了在同一个作用域中声明同一个变量，那么不在同一个作用域中的同名是不是也会覆盖呢？多种其他语言的编程经验告诉我们这是不可能会进行覆盖的。比如上面的列中的两个@a的声明，不过这个还不够典型。看下面的这个例子。 @var: 0; .class { @var: 1; .brass { @var: 2; three: @var; @var: 3; } one: @var; } 编译的结果如下。 .class { one: 1; } .class .brass { three: 3; } 和我们之前的猜想是一致的，大括号中就是一个作用域。内部的作用域和外部的作用域的同名的变量是相互不影响，不会覆盖的，但是内部如果不是同名的变量的话，还是可以使用外部的变量的。 很多情况下这种写法也可以节省很多的代码量。 我们不仅仅可以在less中使用变量，可以看到的是，我们甚至还可以对这些变量进行加减乘除的运算。如上面的@height: @width + 10;就使用加法的运算。不过这个运算似乎是有点儿奇怪，因为看起来是10px + 10，一个是有单位的量，而另一个是没有单位的量，这样真的可以进行运算吗？答案是可以的，只要一个有单位就可以了哦。比如10 * 20px的结果是200px。只需要一个有单位。 避免编译对于上面的那个less中表达式的计算，现在又出现了一个问题，就是有些东西我不想less帮我进行编译，我想要css来计算他。比如说使用@width: calc(100% + 10px); 我们本来的目的想要想要其比父元素的大小还要大10px,经过less的编译之后变成了width: calc(110%);这个不是搞事情的嘛，这个地方less你就不要好心给我们办坏事了，这里不需要你的编译。这个时候我们就可以使用less避免编译的语法。 ~&#39;不需要less编译的内容&#39; 上面的代码就可以写成@width: ~&#39;calc(100% + 10px)&#39;;编译的结果为width: calc(100% + 10px); 不过此时又出现了一个问题。那就是@height: @width + 10这行代码会报错，因为less没有给你进行编译，less也不知道你是个什么玩意啊，less中的变量虽然表面上说是变量，但是实际上理解起来还是一个常量的。至于上面的这个问题该如何解决，可以根据具体的情况使用calc函数进行解决。 总结上面简单的介绍了less中最重要的两个用法，结构化的嵌套和变量，但是less强大的地方不仅如此，less还有更多的强大的地方是三言两语说不清的。不过这些东西我大抵也不会，，，看来还是需要好好学习了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL More]]></title>
    <url>%2F2019%2F10%2F30%2FSQL-More%2F</url>
    <content type="text"><![CDATA[SQL More前言前面我们学习玩了JDBC中基本上全部的内容，但是还没有说过SQL中的很多的基本的知识。刚好现在也在学习SQL这门课，那么就稍微的来学一下SQL中的几个基本的功能吧。 约束SQL中总共有四种不同的约束。他们分别是主键约束，唯一约束，非空约束，外键约束。其中前面的三个约束都是非常简单容易理解的，就是第四种约束其实是有点不好说的。不过还是一一说起吧。 主键约束所谓的主键是什么东西其实是不用多说了的，很简单的概括就是非空的唯一的字段。 create table tem(id int primary key, name varchar(10)); 在类型的后面加上primary key关键词表示这个字段将是作为主键来使用。 不过有时候我们发现主键设置错了，那么可以使用如下的命令删除之前设置的主键。 alter table tem drop primary key; 不过也有点时候我们也想在创建表之后添加主键。 alter table tem add primary key (id); 需要注意的是，后面的那个东西是需要加上()的，为什么呢？其实我也不是很清楚，因为不加上括号我发现竟然报错了。不过，其实我们知道主键并不是只能有一个字段，主键也可以有多个字段。此时这多个字段是非空唯一的，单个字段可以不是唯一的。如果要设置这样的主键，我们当然不可以使用这种方式。 create table tem(id int primary key, name varchar(10) primary key); 而是需要使用如下的方式，在最后声明主键。 create table tem(id int, name varchar(10), primary key(id, name)); 唯一约束这个就是字面上面的意思，就是这个键必须是唯一的。不能有重复的数据。设置的方式也非常的简单，而且也没什么好说的。 create table tem(id int default 1 primary key, name varchar(10) unique); 上面的default是给这个字段一个默认值（虽然给主键一个默认值是非常沙雕的，一般情况下都是给一个自动增长)。后面的unqiue就是唯一约束。需要注意的是，主键约束上面是不可以再加上unique的。 比如说，这就是一个错误的用法。 create table tem(id int primary key unqiue); 如果想要删除表中的唯一约束需要使用。 alter table tem drop index name; 如果要增加的话就是使用。 alter table tem add index (name) 非空约束这个也是很简单，直接加上一个not null就行了。 create table tem(id int primary key, name varchar(10) not null); 同样的，主键约束上面也是不可以加上not null的。 添加的修改非空约束都是比较简单的，直接使用alter xx modify xx就行了。 alter table tem modify name varchar(10) not null; //添加非空 alter table tem modify name varchar(10); // 删除非空 外键约束学习外键约束之前，我们首先要来了解一下什么是所谓的外键。现在比如说我们有如下的一张表，表中有如下的字段。 学号 姓名 年龄 性别 手机号 籍贯 学院 学院主任 前面是学生的基本的信息。后面是学院和系主任。很多人都是计算机系的，但是计算机系的主任就是那一个，如果按这个表的方式进行存储会造成很多数据的赘余。（其实是产生了传递依赖，违背了第三范式）。所以我们要将学院的信息专门弄一个表，然后将学生的信息表和这个表产生一定的关系。 学号 姓名 年龄 性别 手机号 籍贯 学院号 学院号 学院 学院主任 这时候两个表可以通过学院号进行联系。但是这似乎还不是很好。比如说我是可以插入不存在的学员号，或者是说随便修改学院表中的学院号。比如说现在只有1 2 3三个学院。我们无法插入学院号为4的学生。当还有学生表中还有学院号为1的学生的时候，我们是无法对学院表中的1学院号进行修改或者删除的。但是上面的表结构对这些都没有任何的限制，而使用外键就可以添加这些限制。 现在随便建立两个表来举例。 create table table2(id int primary key, name varchar(10) not null); 现在我们想要表2的id作为表1的外键(一般情况下都是需要主键的)，需要这样操作。 create table table1(id int primary key, userid int not null, foreign key(userid) references table2(id)); create table table1(id int primary key, userid int references table2(id) not null) foreigh key(userid) references table2(id)就是设置外键的操作。 我们也可以在表已经存在的时候添加外键约束。 ALTER TABLE 子表 ADD CONSTRAINT 外键名 FOREIGN KEY (关联字段) REFERENCES 主表(被关联的字段) on delete cascade on update restrict; 其中后面也可以增加on delete, on update。都有restrict, no action, cascade, set null四个属性。其中restrict, no action几乎是一样的，放到上面的例子中就是如果该学院还有人就无法删除学院。cascade就是如果我们删除学院，那么学院中的所有的学生都会被删除，这个东西很危险。。。set null。就是如果删除学院，那么学生表中该学院的学生学院号都会变成null，唉，无家可归的孩子，真可怜。 我们还可以对外键进行修改，不过我们需要知道外键的名字。如果我们使用上面的第一种方式建立外键，此时没办法给名字（我实在是没查到如何给名字，查名字这种事情非常的麻烦。）所以我们需要建表之后，使用这种方式创建外键。 alter table table1 add constraint sher foreign key (userid) references table2(id); 此时外键的名字就是sher，我们可以使用ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名;来删除这个外键。 alter table table1 drop foreigh key sher; 如果想要查看外键的名字，可以使用show create table xxx的方式查看创建的语句。比如这里使用show create table table1可以得到如下的内容。 | table1 | CREATE TABLE `table1` ( `id` int(11) NOT NULL, `userid` int(11) NOT NULL, PRIMARY KEY (`id`), KEY `sher` (`userid`), CONSTRAINT `sher` FOREIGN KEY (`userid`) REFERENCES `table2` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 | 原来在创建表的时候也是可以指定外键的名字的吖！！ 多表之间的关系所谓多表之间的关系，其实就是多个实体之间的关系。大抵上分为以下的三种关系——一对一，一对多，多对多。其中一对一的关系其实没有什么说的必要，既然是一对一的关系，为何不讲其放到同一个表中呢？下面主要就是来探讨一对多和多对多关系的处理。 一对多最典型的一对多的例子就是学生和班级之间的例子。一个学生只有一个班级，但是一个班级却有很多个学生。此时班级和学生之间的关系就是一对多的关系。比如下面的这个表。 学号 姓名 班级 班主任 001 张三 1801 章三 002 李四 1801 章三 003 王五 1802 王舞 004 赵六 1892 王舞 此时我们明显的发现，数据非常的赘余。我们知道了班级按道理来说就是知道了班主任。后面可能还有班级的语文老师，数学老师等等班级其他的信息。所以说直觉都告诉我们需要为班级另外创建一个表。 不过此时学生表和班级表如果建立联系？不就是学生表加上班级属性嘛。。其实不然，上面也讲过了外键，这里我们想要建立联系就需要使用外键。 学号 姓名 班级号（外键） 001 张三 1 002 李四 1 003 王五 2 004 赵六 2 班级号 班级名 班主任 1 1801 章三 2 1802 王舞 不过，我们为什么使用班级号而不是直接使用班级号呢？或许是有时候班级的名字也是需要修改的。最主要的就是创建班级表的时候我们是将班级号作为主键来使用的。(一般情况下都是使用一个id类似的东西来作为主键，而且可以设置为自增的)。 可以设置外键如下。 alter table stud add constraint stud_class foreign key (班级号) references class(班级号) 一般情况下是不是用中文作为列名的。。 至于设置主键自增的代码如下所示。 create table class(class_id int auto_increment primary key) -- 初始情况是从一开始，每次增加一的，不过我们也可以使用下面的方式进行调整。 SET @@auto_increment_increment=3; -- 将自增长步长设置为3 SET @@auto_increment_offset=4; -- 将自增长开始值设置为4 -- 也可以单独对这个表进行设置 alter table class auto_increment = 1000 -- 设置初始值 总结来说就是如果一对多的话，我们需要将“一”的那个表的主键作为“多”的那个表的外键。 多对多多对多的最典型的例子就是学生和课程之间的例子。一个学生可以选修多个课程，但是多个课程也可以被多个学生选取。这个时候就是多对多的情况。 此时我们发现多对多的情况下我们都无法将这写数据放入到同一表中。只能放入到多张表中。 学号 姓名 1 张三 2 李四 3 王五 课程号 课程名 1 语文 2 数学 上面是学生和课程表。想要描述这两个表之间的关系是没办法是用外键的，因为外键只有一个，没法对应多个课程。那么我们就需要使用一张表来描述二者之间的关系了。 学号 课程号 成绩 1 1 98 1 2 78 2 1 67 2 2 98 3 2 58 3 1 99 上面我们额外的增加的了一个字段——成绩，这很有必要。上面的表中的主键是(学号， 课程号)，由两个字段构成，这个之前也说过了，并不意外。其中学号是第一个表的主键，课程号是第二表的主键。由此可见，关联多对多的表的方法就是重新创建一个表格，将多表的主键作为联合主键。后面的那个成绩的那个字段其实是可有可无的，只是加上去看起来更顺眼一些，如果不加上的话，这个表完全就是表示学生和课程之间的选取关系。 子查询返回值本来是要说说三大范式的，但是转念一想，三大范式似乎是有点简单了，而且上面的基本上我已经潜移默化的说完了三大范式了。那么这里就说说子查询的情况吧。这里主要说的是子查询的返回值的使用。其中返回的结果主要是三种情况——单行单列、多行单列，多行多列。 单行单列产生单行单例的返回值很多情况下都是使用了聚合函数。聚合函数常用的就是一下的几种。 max min avg sum count、 select count(id) from stud; 此时返回的就是一个单行单列的表格，此时这个表格就可以作为一个数据来使用。正如一行一列的矩阵和普通的数是没有任何的区别的。 select * from stud where id = (select count(id) from stud); 这就是子查询的一个使用，其中运行的顺序是先运行子查询，然后再运行父查询。(括号是必不可少的)。 多行单列除了单行单列的数据可以作为普通的数据使用各种各样的操作云算法，多行单例的也是可以使用一个操作符的，那就是in 操作符。 select id, name from stud where id in (select id from stud where score &gt; avg(score)); 虽然这个例子写的非常的沙雕没有意义，但是很多的体现了使用in操作符作用与多行单列的表。 多行多列多行多列的数据是不可以使用任何的操作运算符，但是可以作为一个表格直接使用。比如说。 select * from (select * from stud where id &gt; 5) where name = &#39;sher&#39;; 此时子查询的结果就是一个表，也可以给这个表一个别名as，然后在后面使用的子查询的结果的表。 总结上面主要就是写了SQL中的三个内容。一个就是SQL中的四个约束的使用，二是如果处理多个表之间的关系。三是如何处理子查询的返回值的使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn JDBC-04]]></title>
    <url>%2F2019%2F10%2F29%2FLearn-JDBC-04%2F</url>
    <content type="text"><![CDATA[Learn JDBC-04前言之前说到了JDBC中的事务以及隔离性，后面还将CRUD操作进行封装，创建了一个DAO对象。不过如果需要获取一个连接，我们还是通过之前写的那个函数来获取连接。这样每次我们进行操作，或许都要获取一次连接，这极大的降低了效率。在创建线程的时候，我们使用线程池解决了这个问题。这里的或许数据库连接和创建多线程其实是一样的，都是一种比较耗时的操作，所以我们需要专门使用一个东西对他们进行管理。线程是线程池，数据库就是数据库连接池。 至于使用数据库连接池的好处和使用线程池的好处基本上是一样的。都是可以资源重用，效率更高，更好的管理等等一系列的好处。 数据库连接池在Java当中，数据库连接池使用javax.sql.DataSource来表示。不过这个DateSource只是一个接口，该接口在JDK中是没有实现的，不过有很多的开源的组织提供了实现。下面稍微来介绍一下三种数据库连接池的使用。 C3P0数据库连接池既然是开源软件实现的，我们就要上网上下载对应的jar包，然后导入到项目中。 和之前我们写jdbc.properties一样，我们要使用c3p0的话也是需要使用配置文件的。不过此时不是一个properties文件而是一个XML文件，名字也是固定的，必须要是c3p0-config.xml。文件中的内容大概如下。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;named-config name=&quot;c3p0mysql&quot;&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///sher?serverTimezone=UTC&amp;amp;rewriteBatchedStatements=true&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; 根据前面的name基本上也可以猜出来设置的是什么东西。其中name-config中的name属性不是随便写完就没事了的，后面是需要使用到的。不过我们也可以设置一下默认连接，那么下面使用的时候就不需要特别的指定要连接哪个数据库了。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;named-config name=&quot;c3p0mysql&quot;&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///sher?serverTimezone=UTC&amp;amp;rewriteBatchedStatements=true&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;default-config&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///sher?serverTimezone=UTC&amp;amp;rewriteBatchedStatements=true&lt;/property&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/default-config&gt; &lt;/c3p0-config&gt; 只要多写一个dafault-config就行了。 至于如果获取连接，方式是非常的简单。 private static DataSource cpds = new ComboPooledDataSource(); public static Connection getConnection() throws SQLException { return cpds.getConnection(); } 最重要的也就是new ComboPooledDataSource()这个东西了。 DBCP数据库连接池DBCP是一种比较常用的数据库连接池，是Apache开源组织提供的。其中Tomcat的连接池就是用的这个东西实现的。 和上面的那个一样，我们还是需要从网上下载对应的jar包，然后导入项目中。其中需要注意的是，这个commons-dbco是依赖另外的两个包的，所以我们还需要下载commons-logging和commons-pool，并将其导入到项目当中。 然后我们需要做的就是编写配置文件。和我们之前使用的那个jdbc.properties一样，DBCP也是需要我们编写properties文件，然后加载解析。 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///sher?serverTimezone=UTC&amp;rewriteBatchedStatements=true username=root password=root initialSize=10 还有其他的参数这里就不多说了，直接看看获取连接的操作。 private static DataSource source = null; static { try { Properties pros = new Properties(); InputStream is = Demo1.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); source = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { return source.getConnection(); } 最重要的也就是BasicDataSourceFactory.createDataSource(pros)这个东西了。 Druid数据库连接池这个连接池有上面的连接池的所有的优点，是目前最好的数据库连接池。而且这个东西是阿里巴巴开发的。这个东西和DBCP是非常类似的。我们还是需要编写配置几乎相同的配置文件。 driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql:///sher?serverTimezone=UTC&amp;rewriteBatchedStatements=true username=root password=root initialSize=5 然后读取配置文件，新建连接池。 private static DataSource source = null; static { try { Properties pros = new Properties(); InputStream is = Demo1.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pros.load(is); source = DruidDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection() throws SQLException { return source.getConnection(); } 操作基本上都是一样的。不一样的就是DruidDataSourceFactory.createDataSource(pros)，也就五个单词的不同罢了。 上面就是对三个数据库连接池的介绍，其实都调用这些东西都是蛮简单的，无非就是一个getConnection方法。有了上面的这三个东西，我们就不需要自己手写连接数据库的操作了。不过我们还是写了JDBCUtils中的很多的增删改查的操作，那么这些工作是否有其他人替我们已经完成了呢？当然是有的。 DBUtils和我们之前学完了IO之后，来了一个commons-io，我们做了事情，其实人家早就写好了更好的工具。我们写的都是没有必要的。同样的，我们学完了JDBC之后，commons-dbutils也完成了几乎所有的操作，我们也不需要写任何东西了，直接拿来就用就行了。 首先还是下载jar包，然后导入到项目当中去。 DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法 如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方 法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和 ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情 况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务， 然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在 关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做 了判断 public static void rollbackAndClose(Connection conn)throws SQLException 回滚事务然后关闭连接 public static void rollbackAndCloseQuietly(Connection) 不抛出异常。 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少 编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行 一个更新（插入、更新或删除）操作。 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的 键值 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 ….. 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句 的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 上面就是QueryRunner的使用，不过上面多次写到了ResultSetHandler. ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map 里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 主要使用的就是加黑的那几个。不过我们也可以选择自己来实现这个接口。可以选择使用匿名内部类的方式，不过lambda表达式是最好的，因为只有一个方法需要实现。 ResultSetHandler rsh = new ResultSetHandler() { @Override public Object handle(ResultSet rs) throws SQLException { if (rs.next()) { return new Student(rs.getInt(&quot;id&quot;), rs.getString(&quot;username&quot;)); } return null; } }; ResultSetHandler rsh = rs -&gt; { if (rs.next()) { return new Student(rs.getInt(&quot;id&quot;), rs.getString(&quot;username&quot;)); } return null; }; 关于JDBC的说明基本上就结束了。现在我们就可以将之前DAO中调用的我自己写的JDBCUtils的内容修改成为DBUtils中的方法了。经过我们的修改，BaseDAO就可以省略成这个样子，不可谓不简单。 package com.sher.dao; import org.apache.commons.dbutils.DbUtils; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.*; import java.lang.reflect.Field; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.*; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import static com.sher.java1.JDBCUtils.closeResource; /** * @author SHeR * @time 10/28/2019 6:16 PM * @describe */ @SuppressWarnings(&quot;all&quot;) public class BaseDao2&lt;T&gt; { private Class&lt;T&gt; type; private QueryRunner queryRunner = null; BeanHandler&lt;T&gt; beanHandler = null; BeanListHandler&lt;T&gt; beanListHandler = null; MapHandler mapHandler = null; MapListHandler mapListHandler = null; ScalarHandler scalarHandler = null; public BaseDao2() { Class&lt;? extends BaseDao2&gt; clazz = this.getClass(); ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); this.type = (Class&lt;T&gt;) actualTypeArguments[0]; queryRunner = new QueryRunner(); } public int update(Connection conn, String sql, Object... objs) { int count = 0; try { count = queryRunner.update(conn, sql, objs); } catch (SQLException e) { e.printStackTrace(); } return count; } public T getInstance(Connection conn, String sql, Object... objs) throws Exception { if (beanHandler == null) { beanHandler = new BeanHandler&lt;&gt;(type); } return queryRunner.query(conn, sql, beanHandler, objs); } public List&lt;T&gt; getInstances(Connection conn, String sql, Object... objs) throws Exception { if (beanListHandler == null) { beanListHandler = new BeanListHandler&lt;&gt;(type); } return queryRunner.query(conn, sql, beanListHandler, objs); } public Map&lt;String, Object&gt; getMapInstance(Connection conn, String sql, Object... objs) throws Exception { if (mapHandler == null) { mapHandler = new MapHandler(); } return queryRunner.query(conn, sql, mapHandler, objs); } public List&lt;Map&lt;String, Object&gt;&gt; getMapInstances(Connection conn, String sql, Object... objs) throws Exception { if (mapListHandler == null) { mapListHandler = new MapListHandler(); } return queryRunner.query(conn, sql, mapListHandler, objs); } public Object getValue(Connection conn, String sql, Object... objs) throws Exception { if (scalarHandler == null) { scalarHandler = new ScalarHandler(); } return queryRunner.query(conn, sql, scalarHandler, objs); } } 上面基本上已经没什么方法是我们直接写的了，不可谓不无脑，不可谓不简单！！！ 总结上面基本上就是介绍了几个工具的使用。首先是三个数据库连接池（基本上就是用最好的那个druid连接池，其他的不看都是可以的。），然后就是DBUtils的使用。然后我们还使用DBUtils改进了之前写的那个BaseDAO。那么到此JDBC的简单学习就结束了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn JDBC-03]]></title>
    <url>%2F2019%2F10%2F24%2FLearn-JDBC-03%2F</url>
    <content type="text"><![CDATA[Learn JDBC-03前言上面的一节中主要是说了Java和SQL中对应的类型，还有如何使用PreparedStatement对Blob类型的数据进行存取，最后我们还提到了如果进行高效的批量插入的操作。首先我需要使用PreparedStatement进行操作，因为这是经过了预编译的。然后我们使用Batch批处理的方式，极大的提高了批量插入的效率。最后一步，关闭MySQL的自动提交setAutoCommit(false)。(Oracle默认就是关闭自动提交的。如果不主动提交的话，数据就会消失。这点就很操蛋。)不过AutoCommit这个东西的用途不仅仅是用在这个批量插入上面来，其实这个东西还有更大的用途。这就是下面要说的事务。 事务事务的简单介绍上面说到了SQL语句是自动提交的，但是有时候我们需要几个SQL语句作为一个整体，要么这个整体执行成功，要么是全都不执行。比如说，甲向乙转账一百元。可以分为以上的三个步骤，首先查询甲的账号余额是否还有一百，然后甲的余额减去一百，最后乙的余额减去一百。重点就在后面的两步。如果是转换成为SQL语句的话，就是 update person set money = money - 100 where name = &#39;jia&#39;; update person set money = money + 100 where name = &#39;yi&#39;; 上面的两条语句应该就是上面我们说的事务的范畴。这两个语句要么就是都成功了，要么就是都失败。如果第一行执行了，到了第二行出现了异常，程序崩溃了。那么甲的一百块没了，但是乙并没有收到这一百块，这个问题就很大了，以后就没人去这个银行存钱或者进行转账了，毕竟这次是一百，下次可能就是一百万。不过该如何解决这个问题呢？我们可以在遇到异常的时候，把钱给甲转回去。这个方式肯定是不可行的。当我们系统出现异常的时候，如果我们之前做过了系统备份，我们就可以将系统还原到备份的那个时候。根据这个思路，我们可以在执行语句之前做一个备份，如果中途出现了异常，我们就还原到备份之前的状态。这样就不会出问题了。这其实就是数据库事务的处理的方式。 不过我们首先需要做的是让数据不可以自动提交，因为数据一旦提交了，就没办法回到之前的状态。数据在一下的两种状态是会提交的。 默认情况下，执行一个SQL语句就会自动提交一次。 当数据库连接关闭的时候会提交。 其中第一点，我们可以通过之前说的那个setAutoCommited(false)关闭默认的自动提交，使用commit方式手动提交数据。第二点，我们需要保持数据库的连接不要中断。这就要保证了执行上面两条SQL语句的必须是同一个连接，我们要将同一个Connection传入两个方式，最后关闭。 如果遇到了异常，我们需要进行数据的回滚。调用的是rollback方法。既然是出现了异常才会调用，那么这个方法必然是在catch语句块中进行调用的。 其中，上面的操作写成代码就是如下这个样子哒。 @Test public void test() { Connection conn = null; try { conn = JDBCUtils.getConnection(); conn.setAutoCommit(false); String sql1 = &quot;update person set money = money - ? where name = ?&quot;; JDBCUtils.update(conn, sql1, 100, &quot;jia&quot;); // System.out.println(10/0); String sql2 = &quot;update person set money = money + ? where name = ?&quot;; JDBCUtils.update(conn, sql2, 100, &quot;yi&quot;); conn.commit(); } catch (Exception e) { e.printStackTrace(); try { if (conn != null) { conn.rollback(); } } catch (SQLException ex) { ex.printStackTrace(); } } finally { try { if (conn != null) { conn.setAutoCommit(true); } } catch (SQLException e) { e.printStackTrace(); } JDBCUtils.closeResource(conn); } } 完成事务的时候尤其需要注意需要取消自动提交，还有就是必须保证是同一个连接，连接不能断开，如果断开了就会自动提交了。不过上面的代码还有一点是需要注意的。那就是finally语句中的setAutoCommit(true)，再次开启自动提交。既然下面都开关闭连接了，为什么还要做一个多余的动作呢？这个就要说到下面要说的数据库连接池这个东西了。和线程池是十分类似的，建立数据库的连接也十分的耗时。所以我们最好是维护一个连接池，当我们关闭连接之后，连接可能只是回到连接池中等待下一次的调用的。但是下一次的调用不一定是知道取消了自动提交的，所以我们需要将连接恢复到使用之前的状态。 事务与隔离 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发 生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的 数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其 他操作和数据库故障不应该对其有任何影响。 上面是事务的四个基本的属性。其中第一二四是非常容易理解的。难以理解的就是第三点——多个事务之间的关系。如果有多个事务同时操作同一个数据库，那么就会出现一定的问题。其中主要就是以下的三个问题。 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的 内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字 段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如 果 T1 再次读取同一个表, 就会多出几行。 其中，我们主要需要解决的问题是脏读和不可重复读。如果要解决幻读的话，数据库的效率就会变得特别的差，而且一般情况下我们只需要解决前面的两种就行了。MySQL默认替我们解决了不可重复读的问题，Oracle默认解决的是脏读的问题。 如果解决这些问题就需要对数据库的隔离属性进行一些设置了。 其中总共是分为四个级别。 READ UNCOMMITED 什么问题都没有解决。 READ COMMITED 解决了脏读的问题。(Oracle默认) REPEATABLE READ 解决了不可重复读的问题。(MySQL默认) SERIALIZABLE 解决了幻读的问题，但是直接变成了串行了，效率不高。 其中我们可以通过如下的方法来获取和设置隔离的级别。 System.out.println(conn.getTransactionIsolation() == Connection.TRANSACTION_REPEATABLE_READ); conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE); System.out.println(conn.getTransactionIsolation() == Connection.TRANSACTION_SERIALIZABLE); DAO所谓的DAO指的就是Date Access Object。是Java中用来访问数据库中的信息的类与接口。包括了对数据的CRUD（Create、Retrival、Update、 Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 。 其实我们上面已经做了DAO的一部分的操作了，就是我们之前写的那个JDBCUtils那个类。基本上就是涵盖了我们需要的所有的方法。不过我们还是需要进行一些改进。 其中获取连接关闭的连接的方式需要取掉，然后方法也不需要是静态的方法。我们可以指定泛型，而不是查询的时候给定参数Class对象。 package com.sher.dao; import com.sher.java1.Demo1; import com.sher.java1.JDBCUtils; import java.io.InputStream; import java.lang.reflect.Field; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.*; import java.util.*; import static com.sher.java1.JDBCUtils.closeResource; /** * @author SHeR * @time 10/28/2019 6:16 PM * @describe */ @SuppressWarnings(&quot;all&quot;) public class BaseDao1&lt;T&gt; { private Class&lt;T&gt; type; public BaseDao1() { Class&lt;? extends BaseDao1&gt; clazz = this.getClass(); ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); this.type = (Class&lt;T&gt;) actualTypeArguments[0]; } public int update(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } int res = ps.executeUpdate(); closeResource(null, ps, null); return res; } public T getInstance(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); T t = null; if (rs.next()) { t = type.getConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String columnLabel = metaData.getColumnLabel(i + 1); Field field = type.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, o); } } closeResource(null, ps, rs); return t; } public List&lt;T&gt; getInstances(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); List&lt;T&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) { T t = type.getConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String columnLabel = metaData.getColumnLabel(i + 1); Field field = type.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, o); } list.add(t); } closeResource(null, ps, rs); return list; } public Map&lt;String, Object&gt; getMapInstance(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); if (rs.next()) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String label = metaData.getColumnLabel(i + 1); map.put(label, o); } return map; } closeResource(null, ps, rs); return null; } public List&lt;Map&lt;String, Object&gt;&gt; getMapInstances(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String label = metaData.getColumnLabel(i + 1); map.put(label, o); } list.add(map); } closeResource(null, ps, rs); return list; } public Object getValue(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); if (rs.next()) { Object object = rs.getObject(1); return object; } closeResource(null, ps, rs); return null; } } 上面的BaseDAO其实是共有的，任何类型都是可以使用的。针对我们上面说到的一个表，我们需要另外的提供一个接口，要求实现里面的一些操作。 public interface StudentDao1 { String getName(Connection conn, int id); int getId(Connection conn, int name); Student getStudentByid(Connection conn, int id); Student getStudentByid(Connection conn, int min, int max); Student getStudentByName(Connection conn, String name); boolean addStudent(Connection conn, Student student); boolean removeStudentById(Connection conn, int id); boolean removeStudentByName(Connection conn, String name); boolean changeName(Connection conn, int id, String name); List&lt;Student&gt; getAllStudentsList(Connection conn); List&lt;Map&lt;String, String&gt;&gt; getAllStudentsMap(Connection conn); } 上面就是简单的写一写，对于这个表我们需要什么样的操作。最后我们需要继承上面的BaseDAO然后实现上面的这个接口。 package com.sher.dao; import com.sher.java1.Student; import java.sql.Connection; import java.util.List; import java.util.Map; /** * @author SHeR * @time 10/28/2019 6:40 PM * @describe */ public class StudentDAOImpl extends BaseDao1&lt;Student&gt; implements StudentDao1 { @Override public String getName(Connection conn, int id) { String sql = &quot;select username from test where id = ?&quot;; try { Object value = getValue(conn, sql, id); return (String) value; } catch (Exception e) { e.printStackTrace(); } return null; } @Override public int getId(Connection conn, int name) { String sql = &quot;select id from test where username = ?&quot;; try { Object value = getValue(conn, sql, name); return (int) value; } catch (Exception e) { e.printStackTrace(); } return -1; } @Override public Student getStudentByid(Connection conn, int id) { String sql = &quot;select * from test where id = ?&quot;; try { return getInstance(conn, sql, id); } catch (Exception e) { e.printStackTrace(); } return null; } @Override public List&lt;Student&gt; getStudentByid(Connection conn, int min, int max) { String sql = &quot;select * from test where id between ? and ?&quot;; try { return getInstances(conn, sql, min, max); } catch (Exception e) { e.printStackTrace(); } return null; } @Override public Student getStudentByName(Connection conn, String name) { String sql = &quot;select * from test where username = ?&quot;; try { return getInstance(conn, sql, name); } catch (Exception e) { e.printStackTrace(); } return null; } @Override public void addStudent(Connection conn, Student student) { String sql = &quot;insert into test values(?, ?)&quot;; try { update(conn, sql, student.getId(), student.getUsername()); } catch (Exception e) { e.printStackTrace(); } } @Override public void removeStudentById(Connection conn, int id) { String sql = &quot;delete from test where id = ?&quot;; try { update(conn, sql, id); } catch (Exception e) { e.printStackTrace(); } } @Override public void removeStudentByName(Connection conn, String name) { String sql = &quot;delete from test where username - ?&quot;; try { update(conn, sql, name); } catch (Exception e) { e.printStackTrace(); } } @Override public void changeName(Connection conn, int id, String name) { String sql = &quot;update test set username = ? where id = ?&quot;; try { update(conn, sql, name, id); } catch (Exception e) { e.printStackTrace(); } } @Override public List&lt;Student&gt; getAllStudentsList(Connection conn) { String sql = &quot;select * from test&quot;; try { return getInstances(conn, sql); } catch (Exception e) { e.printStackTrace(); } return null; } @Override public List&lt;Map&lt;String, Object&gt;&gt; getAllStudentsMap(Connection conn) { String sql = &quot;select * from test&quot;; try { return getMapInstances(conn, sql); } catch (Exception e) { e.printStackTrace(); } return null; } } 通过这种方式我们就可以使用经过封装之后的StudentDAOImpl来处理数据了。完全不用使用任何的SQL语句，因为SQL语句已经被封装到这个类中了。我们可以像使用Java中其他的类一样的使用这个类。不过需要注意的是每次调用方法的时候，我们还是需要将一个连接传入到方法当中去。 使用DAO基本就是一个模版的格式。首先是BaseDAO，这个东西只需要一个，因为这个是所有的类都可以使用的，而且这个类带上了泛型。然后我们需要针对特别的表，创建对应的JavaBean对象，分析我们需要使用到什么样的方法，编写XXXDAO的接口。最后继承BaseDAO&lt;XXX&gt;并且实现XXXDAO接口，这个类一般叫做XXXDAOImpl。通过上面的方式我们就完成了一个比较完整的一个DAO了。JDBC的学习基本上就要在此告一段落了。下面我们还需要学习的就是几种数据库连接池，还有就是apache的一个包DBUtils，就像之前说的那个Commons-IO一样，很多功能别人已经替我们实现了。不过我们还是需要自己写一遍才能明白其中的原理。 总结上面简单的介绍了数据库中的事务以及隔离级别，还有就是进一步对jdbc进行封装，写了一个DAO对象。不过这个DAO对象在之后还是需要进行改进的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn JDBC-02]]></title>
    <url>%2F2019%2F10%2F23%2FLearn-jDBC-02%2F</url>
    <content type="text"><![CDATA[Learn JDBC-02前言上面我们已经说完了如何对JDBC中的增删改查的操作进行封装。其中最为复杂的就是查询的操作。因为我们需要考虑返回值是什么东西，其中我们使用两种类型的返回值。一种是使用JAVA Bean对象作为返回值，此时我们需要根据表中的信息建立相对应的方式，然后再调用函数的时候传入Class对象。在函数中根据查询到的信息，然后使用反射的反思创建的对象，第二种方式是使用Map的方式，这种方式我们不需要根据表创建对应的什么东西，我们只需要将查询到的东西直接以键值对的形式放入Map中就行了。我个人感觉这种方式似乎是更不错的。 Java与SQL中的类型前面我们只接触到了SQL中的两种数据类型，一种是int，另一种是varchar(n)。这两种类型毫无疑问的是对应Java中的int和String类型的数据。但是SQL中还有其他的不少类型的数据，他们与Java中的类型的对应关系也是需要我们来掌握的，不然都不知道直接应该插入什么样的类型的数据了。 Java类型 SQL类型 boolean BIT byte TINYINT int INTEGER long BIGINT String CHAR, VARCHAR, LONGVARCHAR byte array BINARY, VARBINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 上面就是Java和SQL中的一些常用的类型的对应关系。这也是非常容易记的，不过需要注意的是后面的三个东西。他们是java.sql这个下面的而不是java.util下的。 不过也不是每一个SQL语言都有以上的内容的，这就是SQLtmd操蛋的地方，没有统一的标准。其中MySQL中有一个类型是DATETIME。DATETIME和TIMESTAMP是有有一定的区别的，TIMESTAMP只占用4个字节，表示的时间范围比较少。而DATETIME占用了八个字节，表示的范围很大。不过他们两个之间更大的一个区别是TIMESTAMP和时区有关，但是DATETIME和时区是无关的。 这里就不得不说如果我们需要插入一个时间的时候该怎么做了，我们只需要按照特定的时间的格式就可以了。在MySQL中的格式是%Y-%m-%d %H:%i:%s其中这是使用的24小时制。如果需要使用使用12小时制的话，需要使用的是%h并且加上代表am pm的%p。示例如下。 select date_format(ctime, &#39;%Y-%m-%d %H:%i:%s&#39;) from datetest; select date_format(ctime, &#39;%Y-%m-%d %h:%i:%s %p&#39;) from datetest; MySQL中没有to_char函数，这是真的头疼，数据库为什么不能同一呢？ 如果是使用的Oracle，格式是yyyy-mm-dd HH24:mi:ss，如果是返回12小时制的就将上面的24去掉就行了。 select to_char(ctime, &#39;yyyy-mm-dd HH24:mi:ss&#39;) from datetest; select to_char(ctime, &#39;yyyy-mm-dd HH:mi:ss am/pm&#39;) from datetest; 下面的那个十二小时制后面的那个am/pm的写法我也不确实是否是正确的，毕竟我现在只有MySQL的环境。其实上面的那个两个相比较的话，我是更喜欢下面的这种方式的，因为Java中使用的也是差不多这样的方式。yyyy-MM-dd hh:mm:ss是Java中日期常用的格式。上面的oracle之所以使用mi就是因为SQL语言是不区别大小写的，所谓无法区别month和minute。说起Java中日期的格式我们就在这儿另外插入一个话题。Java中的字符串和日期的格式转换。 public static void main(String[] args) { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss a&quot;); Date date = new Date(); String format = dateFormat.format(date); System.out.println(format); // 2019-10-23 07:12:07 PM } 也可以使用二十四小时的格式 public static void main(String[] args) { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = new Date(); String format = dateFormat.format(date); System.out.println(format); // 2019-10-23 19:13:13 } @Test public void test() { DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); try { Date date = dateFormat.parse(&quot;1111-11-11 11:11:11&quot;); System.out.println(date); } catch (ParseException e) { e.printStackTrace(); } } 使用SimpleDateFormat同样也可以将字符串转为日期(java.util.date)，需要注意的是，格式一定要对应，不然是会抛出异常的。 上面有点儿说多了，现在我们回到JDBC中的话题来，是否还有其他的类型数据被我们遗忘了。 操作BLOB类型数据除了上面的这些类型的数据之外，还有一个非常重要的数据类型，那就是——BLOB。MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 BLOB又分为一下的四种，不过除了大小之外，他们都是一样的。 类型 大小 TINYBLOB 255B BLOB 65KB MEDIUMBLOB 16M LONGBLOB 4G 这个BLOB可以是一张图片，也可以一个视频，可以是任何的一个文件。我们需要根据插入的类型的大小确定上面的对应的BOLB 的类型。不过需要说明的，如果在数据库中插入过多或者过大数据的时候，数据库的性能将会受到较大的影响。 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如 下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 这种BLOB类型的数据是无法想之前的那样值算个格式就可以处理的了，那么我们该如何来处理这个BLOB类型的数据呢？是使用Statement还是使用PreparedStatement呢？其实傻子应该都可以看出来是肯定不可能是使用这个垃圾的Statement的，加入说我们想要上传一个图片进入一个数据中的时候，我们总不能使用数据库指令拼接的形式吧。所以说，如果我们想要插入或者是读取BOLB类型的话，我们是只可以使用PreparedStatement这种形式的。不过问题在于，如何使用。类比一下我们处理文件的时候，或者说是通过网络来获取或者是发送信息的时候，我们使用的工具是什么东西呢？就是流，我们使用InputStream来读取流的信息，使用OutputStream来发送流的信息。通过PreparedStatement中的setBlob的方式，我们可以传入一个文件流，(比如说是一张图片)，我们就可以将这个图片写入到数据库当中去了。不过使用setObject的方式也是非常的正确的方式。 @Test public void test1() { BufferedInputStream bis = null; Connection conn = null; try { bis = new BufferedInputStream(new FileInputStream(new File(&quot;kawali.jpg&quot;))); conn = JDBCUtils.getConnection(); JDBCUtils.update(conn, &quot;insert into blobtest values(?)&quot;, bis); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null, null); if (bis != null) { try { bis.close(); } catch (IOException e) { e.printStackTrace(); } } } } 通过这种方式，我们就可以将一张可爱的图片写入到我们的数据库当中去。使用的方式就是之前我们已经说过的各种我们都已经封装好了的方法。不过此时如果我们需要读取的话，可就不是那么容易的了。 @Test public void test2() { Connection conn = null; BufferedOutputStream bos = null; try { conn = JDBCUtils.getConnection(); byte[] cblob = (byte[]) JDBCUtils.getValue(conn, &quot;select cblob from blobtest&quot;); assert cblob != null; InputStream binaryStream = new ByteArrayInputStream(cblob); bos = new BufferedOutputStream(new FileOutputStream(&quot;kawali-sql.jpg&quot;)); byte[] buff = new byte[1024]; int len = -1; while ((len = binaryStream.read(buff)) != -1) { bos.write(buff, 0, len); } } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null, null); if (bos != null) { try { bos.close(); } catch (IOException e) { e.printStackTrace(); } } } } 一开始我将getValue()的返回值转化成为了java.sql.Blob类型，但是发生了异常，看来不是使用getBlob方式似乎是不可以转化成为Blob类型的。如果可以转化成为Blob类型的话，我们可以使用getBinaryStream的方式获取InputSteram。然后通过这个InputStream创建一个OutputStream，然后将图片写入到文件当中去。不过即使不可以使用Blob的方式，我们可以将返回值转化成为一个byte[]的数组，然后通过ByteArrayInputStream的方式返回一个InputStream，后面的步骤就都是一致的了。 需要注意的是上面我使用的函数式getValue，这个纯属是一个意外，按道理来说我们使用使用getInstance或者是getMapInstance函数，不过这里我只有一个返回值，使用getValue完全就是图个方便而已。 批量插入数据上面我们研究完了如何使用PreparedStatement来读取或者是插入一个Blob类型的数据，而这种事情正是Statement做不到的事情，事实上尽管很多Statement能够做到的事情，我们也不会使用这个垃圾的Statement来做的。比如下面我们要说的这个批量插入的问题。 在SQL中很多的操作都是天生就是批量的，比如说删除，查找，和修改。如果我们不对此加以限制的话，我们会修改数据中的所以的数据的信息。不过唯独有一个语句是例外，那就是插入语句。我们在数据库中只能使用insert语句，一条数据一条数据的进行插入，这非常的难受。不过现在有了Java，我们可以使用for循环来帮助我们进行插入数据了。不过我们应该使用什么样的方式呢？什么样的方式是最好的呢？ 加入我们要想数据库中插入十万条数据。 先来考虑一下使用Statement的方式，emm，，这中方式真的需要考虑吗？别说插入的性能，光是拼接产生的sql语句的字符串都有上万条了吧。所以说这种方法是考虑都不用考虑的。 那么我们就只好使用PreparedStatement的方式了。 第一种方式@Test public void test3() { Connection conn = null; try { conn = JDBCUtils.getConnection(); String sql = &quot;insert into inserttest values (?, ?)&quot;; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) { JDBCUtils.update(conn, sql, i, &quot;stud_&quot; + i); } long end = System.currentTimeMillis(); System.out.println(&quot;Time: &quot; + (end - start) + &quot;ms&quot;); } catch (Exception e) { e.printStackTrace(); } finally { JDBCUtils.closeResource(conn, null, null); } } Time: 8097ms，插入一万条的数据只是花了八千多。select count(*) from inserttest;可以查询表中数据的数量。(也可以使用sqlyog，一种SQL的可视化的工具直接看)。 如果我们使用的是Statement，我敢保证一分钟之内是不可能完成了。现在我们来分析一下，为什么这种方式快。我们之前也说过了PreparedStatement是会经过预编译的。当我们多次使用的时候，不过多次编译。所以效率非常的快。 但是注意到，就像我们写入文件的的时候，是一个字节一个字节的方式写入文件的，而这里我们也是一次一次的进行插入的。此时我们多次和数据库进行互动，进行了一万次的提交。大大的降低了效率。于是写如文件的时候，我们使用了一个缓存数组，那么这里我们是否有相似的缓存的机制呢？ 第二种方式jdbc中确实有这种东西，就是Batch(批处理)。 @Test public void test4() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); String sql = &quot;insert into inserttest values (?, ?)&quot;; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) { ps.setInt(1, i); ps.setString(2, &quot;stud_&quot; + i); ps.addBatch(); if (i % 500 == 0) { ps.executeBatch(); ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(&quot;Time: &quot; + (end - start) + &quot;ms&quot;); } catch (Exception e) { e.printStackTrace(); } } 我们使用addBatch方法将语句放入批处理中，当满足一定的条件的时候，比如上面是，有五百个的时候，就提交一次。使用executeBatch的方法可以提交之前加入到批处理中的数据。不过别忘了，提交玩了之后，我们需要清空批处理中的数据，需要调用clearBatch方法。 这个方法运行的时间是Time: 7904ms,似乎是提升的不是很大。。。emm，看来这个方法并不是非常的管用。其实不是这样的，我们写入文件的时候使用缓存区，效率是之前的好多好多倍。这个时候之所以没有提升是因为MySQL默认是不开启批处理的功能的，我们需要在连接的时候加上参数rewriteBatchedStatements=true，这个也就是在我们的jdbc.properties文件中进行修改，不需要改动之前的源码，这就是使用资源文件的好处。 配置文件如下。 mysqlUser=root mysqlPasswd=root mysqlUrl=jdbc:mysql:///sher?serverTimezone=UTC&amp;rewriteBatchedStatements=true mysqlDriverClass=com.mysql.cj.jdbc.Driver 此时，时间是Time: 130ms，这个就不用多说了吧。效率是刚刚的。 如果我们插入一百万条数据的话，时间就是Time: 5770ms。如果是不使用批处理的话，这个时间是不敢想象的。不过这个一百万的速度还不是最快的，这还不是最好的方法。 第三种方式@Test @SuppressWarnings(&quot;all&quot;) public void test5() { Connection conn = null; PreparedStatement ps = null; try { conn = JDBCUtils.getConnection(); conn.setAutoCommit(false); String sql = &quot;insert into inserttest values (?, ?)&quot;; ps = conn.prepareStatement(sql); long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 1000000; i++) { ps.setInt(1, i); ps.setString(2, &quot;stud_&quot; + i); ps.addBatch(); if (i % 500 == 0) { ps.executeBatch(); ps.clearBatch(); } } conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;Time: &quot; + (end - start) + &quot;ms&quot;); } catch (Exception e) { e.printStackTrace(); } } 上面的代码相比与之前只是增加了第8行和第23行的代码。conn.setAutoCommit(false)是关闭Connection的自动提交事务。我们可以关闭这个东西，然后在最后在提交这个事务。 运行的时间是Time: 4525ms，提高的似乎不是很高。。。又是我操作的事务么？ :) 至于上面的commit的详细的用法，这就要到之后再说了。 总结上面我们主要就写了三个方面的知识，第一个是Java和SQL中数据之间的对应关系。第二个就是我们如何插入和读取Blob的数据。第三个就是如何更加高效的进行数据的批量的提交。后面我们将要讨论数据库事务和隔离的各种各样的问题了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn JDBC-01]]></title>
    <url>%2F2019%2F10%2F21%2FLearn-JDBC-01%2F</url>
    <content type="text"><![CDATA[Learn JDBC-01前言很久很久之前，我写过了一个笔记是关于MySQL中的增删改查的基本的操作，其中使用的就是JDBC来连接的数据库从而进行操作数据库。不过当时讲的也是非常的简单的，所以说这里需要来对JDBC的进一步的了解。所谓的的JDBC就是Java DataBase Connectity，使用Java进行数据库的连接的一个东西。不过数据库这种东西虽然是一种统一的SQL语言，但是每一个数据库其实都有很多的不一样的地方，而且每个数据库底层的实现也不是一样的。Java如何实现对这些数据库的连接呢？其实Java的库本质上是没有实现的，JDBC只是Javasun公司写的一个接口。接口里面有很多的抽象的方法和类，以及各种各样的接口。然后有各个数据库的厂商实现JavaJDBC中各种各样的接口，然后提供他们对应的数据库的类的驱动。下面我们需要使用的数据库就是当前最流行的开源的数据库系统MySQL数据库。 数据库的连接当我们下载MySQL数据库的时候里面就是有一个选项问我们需要使用哪一种驱动，此时一般情况下我们都是使用全选的。然后我们就可以去MySQL的安装的目录下找到Connect For J，里面存放的jar包就是JDBC的驱动。这里的驱动其实和平常意义上说我的驱动其实是一样的，比如说当我们使用莫一款硬盘的时候，电脑会告诉我们查询到未知的设备，正在安装驱动。这里的驱动其实就是厂家提供一个的一套软件，可以配置软件的运行。 加载和注册驱动MySQL的驱动是com.mysql.cj.jdbc.Driver(之前是com.mysql.jdbc.Driver，后来改了)。我们需要将jar包导入到我们idea的项目中来，然后加载和注册驱动。我们需要使用反射的方式来加载这个驱动。 使用的方式是Class.forName(“com.mysql.jdbc.Driver”);，方法的返回值是一个Class对象。我们也可以通过这样方式加载系统的类，比如如果我们想要得到String的Class对象，之前我们说需要通过对象.getClass或者是类.class的方式，但是我们也可以通过Class.forName(&quot;java.lang.String&quot;)的方式也是可以得到相同的Class对象的。 加载完驱动之后我们就需要进行注册驱动了。方式是DriverManager.registerDriver(com.mysql.jdbc.Driver)，其中DriverManager是java.sql下面的一个接口。然后各大厂商提供了实现，其实通常情况下我们是不进行注册驱动的，因为各大厂商在写Driver类的时候，在静态的代码块中已经进行注册驱动的操作。比如com.mysql.cj.jdbc.Driver类中就是如下的代码。 package com.mysql.cj.jdbc; import java.sql.DriverManager; import java.sql.SQLException; public class Driver extends NonRegisteringDriver implements java.sql.Driver { public Driver() throws SQLException { } static { try { DriverManager.registerDriver(new Driver()); // 已经进行类的加载 } catch (SQLException var1) { throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); } } } URL驱动都已经处理完毕了，不过我们还需要知道这个驱动需要连接到什么地方。我们需要提供给驱动的就是一个URL地址，从而建立数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议： JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库 提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 比如说我想要连接我的MySQL需要提供URL的是jdbc:mysql://localhost:3306/sher。其中前面的jdbc:mysql是使用mysql固定的协议。后面的localhost是一个ip地址，就是本机的地址127.0.0.1。3306是MySQL默认的端口号，一般情况下不需要进行修改。后面的sher是我需要连接的database的名字。我们使用数据库的情况下很多都是使用本机，所以中间的那个是可以省略的。于是就可以写成jdbc:mysql:///sher，是不是超级的方便呢。 至于其余的数据库的连接的方式这里就叭介绍了。毕竟我也不使用那些玩意呐。 用户名和密码有了驱动，还有了对应的URL，但是我们还是需要用户名和密码才可以登陆数据库。不过在此之前，我们需要确认一下我们i电脑中的MySQL服务是否已经打开了。可以打开cmd窗口，输入services.msc打开服务列表。如果没有打开的话，还可以通过使用管理员的方式打开cmd输入net start mysql57打开mysql服务。(我安装的是mysql57，而且一般情况下我的MySQL服务是关闭的，毕竟我也不经常使用这个玩意) 我们可以使用DriverManager.getConnection()方法建立到数据库的连接，方法中我们需要提供的参数有URL 用户名和密码。 连接的几种方式第一种方式@Test public void test1() throws Exception { Driver driver = null; driver = new com.mysql.cj.jdbc.Driver(); String url = &quot;jdbc:mysql:///sher?serverTimezone=UTC&quot;; Properties pros = new Properties(); pros.setProperty(&quot;user&quot;, &quot;root&quot;); pros.setProperty(&quot;password&quot;, &quot;root&quot;); Connection conn = driver.connect(url, pros); System.out.println(conn); } 直接依赖第三方的API进行了的创建，并且使用第三方类中的方法。不建议使用。 第二种方式@Test public void test2() throws Exception{ Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getConstructor().newInstance(); String url = &quot;jdbc:mysql:///sher?serverTimezone=UTC&quot;; Properties pros = new Properties(); pros.setProperty(&quot;user&quot;, &quot;root&quot;); pros.setProperty(&quot;password&quot;, &quot;root&quot;); Connection conn = driver.connect(url, pros); System.out.println(conn); } 这种方式第一种方式的不同是在于，我们是使用反射的方式来创建实例对象的，不在代码中调用第三方库的API，使用的都是Java中jdbc定义的接口，体现了面向接口编程的思想。 第三种方式@Test public void test3() throws Exception{ Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); Driver driver = (Driver) clazz.getConstructor().newInstance(); String url = &quot;jdbc:mysql:///sher?serverTimezone=UTC&quot;; DriverManager.registerDriver(driver); Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;); System.out.println(connection); } 通过上面我们说的那个DriverManager的方式来获取连接。 第四种方式@Test public void test4() throws Exception { String url = &quot;jdbc:mysql:///sher?serverTimezone=UTC&quot;; Connection connection = DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;); System.out.println(connection); } 驱动都可以不用加载了，也不用进行注册了，直接这么写完事了，比起上面复杂的代码是不是简单的飞起。不过这种方式还是有点儿问题的，当我们需要修改用户名，密码或者表名的时候，我们需要修改源代码。而源代码一旦修改就要进行重新的编译，所以上面说的那四种数据我们可以写入到文件中，需要的时候然后读取就行了。 第五种方式在项目的文件夹下创建一个jdbc.properties的配置文件。 mysqlUser=root mysqlPasswd=root mysqlUrl=jdbc:mysql:///sher?serverTimezone=UTC mysqlDriverClass=com.mysql.cj.jdbc.Driver当然里面我们还可以写其他的数据库连接的信息。 public static Connection getConnection() throws Exception { InputStream is = Demo1.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(&quot;mysqlUser&quot;); String passwd = properties.getProperty(&quot;mysqlPasswd&quot;); String url = properties.getProperty(&quot;mysqlUrl&quot;); String driverClass = properties.getProperty(&quot;mysqlDriverClass&quot;); Class.forName(driverClass); return DriverManager.getConnection(url, user, passwd); } 然后使用当前的类的加载器去加载这个文件，(其实我们也是可以使用FileInputStream的)，然后使用Properties类来读取文件中的key-value值。之后我们修改配置信息的时候就可以在配置文件中修改而不用重新编译源代码。 上面的第五种方式基本上就是我们连接数据库的最基本的操作了。不过需要注意的事，上面的方法中其实是会抛出很多的异常的，但是处于简单的处理，我就直接将异常抛出了，当异常信息需要处理的时候，我们还是需要使用try-catch-finnaly来处理一下异常的。 对数据库的基本的CRUD的操作所谓的CRUD就是Create Read Update Delete也就是增删改查的缩写。这四种操作也就是数据库操作的最基本的操作。不过即使我们是使用Java来操作数据库的，其实我们还是要写SQL语言的，也就是说Java只是提供了一个连接的环境，事实上我们操作数据库还是使用select update insert delete这种SQL语言。不过之前的文章中我们已经对这中基本的操作已经做了了解，这里简单的内容就不说了。就比如说PreparedStatement和Statement的区别。使用PreparedStatement可以避免SQL注入的问题，以及PreparedStatement进行了预编译的操作，可以极大的提升批量操作的性能。不过这里暂且不来讨论这些问题了。 其实所谓的增删改都是一样的操作，我们调用的时候都是使用executeUpdate，其实这三个操作基本上都是一样的，可以将其封装成为一个方法，至于查询可以封装成为另一个方法。不过在此之前，我们需要先来将数据库的连接与关闭的方法进行封装。 连接数据库获取连接public static Connection getConnection() throws Exception { InputStream is = Demo1.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(&quot;mysqlUser&quot;); String passwd = properties.getProperty(&quot;mysqlPasswd&quot;); String url = properties.getProperty(&quot;mysqlUrl&quot;); String driverClass = properties.getProperty(&quot;mysqlDriverClass&quot;); return DriverManager.getConnection(url, user, passwd); } 和上面的连接的数据库操作是一样的。 关闭数据库以及其他资源public static void closeResource(Connection conn, PreparedStatement ps, ResultSet rs) { if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } if (ps != null) { try { ps.close(); } catch (SQLException e) { e.printStackTrace(); } } if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } 增删改的操作public static int update(Connection conn, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } int res = ps.executeUpdate(); closeResource(null, ps, null); return res; } 其中这个函数的返回值是受到影响的数据条数。这里我们将连接是作为参数传递进来的，如果每个方法中都来创建一个连接，那么效率都会特别的差，而且关闭的时候我们也没有关闭传递进来的连接。尤其到了后面事务操作的时候，我们就能清楚的明白为什么要这么做了。 查询操作接下来就是最复杂的查询的操作，首先我们要思考一点，我们需要什么样的返回值。我们需要的返回的结果不应该是一个个字符串，我们需要的是一个对象或者是一个map(因为数据库中的数据是以键值对的形式来储存的)。首先我们来考虑一下返回值是一个对象的情况。这里我们需要操作的数据中有两个列id和username。我们如果需要返回一个对象，当然不可能查询的时候现造。我们需要对要进行操作的表写一个对应的类。 返回对象public class Student { private int id; private String username; public Student(int id, String username) { this.id = id; this.username = username; } public Student() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } @Override public String toString() { return &quot;Student{&quot; + &quot;id=&quot; + id + &quot;, username=&#39;&quot; + username + &#39;\&#39;&#39; + &#39;}&#39;; } } 这里我们就写一个这个表对应的一个对象Student，那么有了这个结构了我们就可以通过反射的方式创建对象并返回了。 public static &lt;T&gt; T getInstance(Connection conn, Class&lt;T&gt; clazz, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); // 获取有多少列 T t = null; if (rs.next()) { t = clazz.getConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String columnLabel = metaData.getColumnLabel(i + 1); // 获取列名 // 通过反射的方式来创建对象。 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, o); } } closeResource(null, ps, rs); return t; } 将Class对象传入方法中，通过反射的方式来创建对象。前面的操作是和增删改的操作是一致的。但是后面我们需要处理ResultSet这个东西。不过之前我们只是从ResultSet中获取某一个属性的值是什么，比如说getInt(id)，但是这里我们并不知道这里面的数据的名字是什么。不过API提供了一个结构给我们解决了这个问题。使用ResultSetMetaData可以获取ResultSet中列的类型和属性信息的对象。 不过需要注意的是，这个方法只可以返回一个值，就算是查询到了多个结果也只会返回结果的第一个。如果想要返回多个值的话，我们需要将返回值修改为List&lt;Student&gt;。 public static &lt;T&gt; List&lt;T&gt; getInstances(Connection conn, Class&lt;T&gt; clazz, String sql, Object... objs) throws Exception { PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); List&lt;T&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) { T t = clazz.getConstructor().newInstance(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String columnLabel = metaData.getColumnLabel(i + 1); Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, o); } list.add(t); } return list; } 返回Map这个方法和上面的获取一个的基本上是一模一样的。下面我们需要说的是返回一个Map，其实Map也是非常好的，我们不需要创建对应的对象。可以直接获取键值对然后放入Map中。 public static Map&lt;String, Object&gt; getMapInstance(Connection conn, String sql, Object... objs) throws Exception{ PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); if (rs.next()) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String label = metaData.getColumnLabel(i + 1); map.put(label, o); } return map; } return null; } 同样的，如果我们想要返回多条数据的话，我们需要返回者的类型是List&lt;Map&lt;String, Object&gt;。其余的基本上都是一样的。 public static List&lt;Map&lt;String, Object&gt;&gt; getMapInstances(Connection conn, String sql, Object... objs) throws Exception{ PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); ResultSetMetaData metaData = rs.getMetaData(); int columnCount = metaData.getColumnCount(); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); while (rs.next()) { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; columnCount; i++) { Object o = rs.getObject(i + 1); String label = metaData.getColumnLabel(i + 1); map.put(label, o); } list.add(map); } return list; } 其实还有一种查询的情况，不是查询这种数据，而是这种类型的查询。比如说select count(*) from test或者是select max(id) from test这种类型的查询，返回的都是一个值，这种类型的查询上面的方法是不适合的。我们需要使用特殊的方法进行查询。 查询特殊值public static Object getValue(Connection conn, String sql, Object... objs) throws Exception{ PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; objs.length; i++) { ps.setObject(i + 1, objs[i]); } ResultSet rs = ps.executeQuery(); if (rs.next()) { Object object = rs.getObject(1); return object; } closeResource(null, ps, rs); return null; } 其实这种方式的查询倒是最简单的，因为我们已经知道了只是返回一个数据了，那么我们处理的时候只需要返回那一个参数就行了。这就是对这种特殊值查询的处理。 总结上面我们先是了解了数据库的连接的操作，然后对JDBC的增删改查的操作进行了基本的封装，也算是对JDBC的一个基本的了解了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2019%2F10%2F19%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解前言注解其实是Java中非常重要的一个部分，而且也是C++中完全空白的一块知识。很多人会认为注解就是什么@Override和FunctionalInterface这种写不写都无所谓的提示性的东西。其实这种想法是完全错误的。Java中很多的框架都是需要借助注解来实现的。不过现阶段我们就简单的了解一下注解的使用就完事了。 注解的声明注解其实也是一个像类、接口一样的东西。之前我们学习反射的时候，也学到了可以通过反射来获取注解，甚至注解也可以对应一个Class对象。比如说Override.class我们也是使用过的。那么我们就从Override这个最常见的注解开始看起。 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } 这就是Override注解的声明。上面也有两个注解，但是声明里面什么都没有写。不过我们可以看出注解的声明和接口的声明是非常的类似的。我们使用@interface的方式来声明注解。注解中什么事情都没有干，其实注解中也干不了什么事情。我们需要使用反射的方式给注解赋予一定的功能。 有的注解中可以使用参数。比如我们经常使用的注解@SuppressWarnnings(&quot;all&quot;)，这个注解中我们给定了一个参数all，那么这个注解的声明又是如何呢？ @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE}) @Retention(RetentionPolicy.SOURCE) public @interface SuppressWarnings { String[] value(); } 其中上面也有几个注解。不过声明的里面就是String[] value()。这个看起来有点儿像是一个函数。其实不是函数，这就是注解中的参数，形式是类型 名字()。如果只有一个参数的话，建议使用value。其中上面的参数的类型是String[]代表可以接受多个值，比如说我们就可以使用@SuppressWarnnings(value = {&quot;unchecked&quot;, &quot;rawtypes&quot;})这种写法，不过由于只有一个属性而且名字还是value的话，我们就可以省略前面的value =可以直接写@SuppressWarnnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})，这就是为什么上面我们建议如果只有一个元素建议使用value作为名字。 元注解上面我们看到的注解的上面都有一些注解。这些注解是什么玩意呢？如果你看这些注解的代码的话，你还会发现这种注解的上面还会有自己。其实这些注解就是元注解，是用来描述注解用的。 元注解@Target表示的是下面的注解可以在哪儿出现。他的值是一个ElementType对象数组。其中共有一下的几个属性。 元素类型 应用于 ANNOTATION_TYPE 注解类型声明 PACKEG 包 TYPE 类和接口（包括Enum和注解) METHOD 方法 CONSTRUCTOR 构造器 FIELD 字段 PARAMETER 方法或者构造器的参数 LOCAL_VARIABLE 局部变量 TYPE_PARAMETER 类型参数 TYPE_USE 类型用途 其中@Retention是用于指定可以从哪里访问注解。有以下的三种选择。 类型 说明 RetentionPolicy.SOURCE 源码 RetentionPolicy.CLASS 类文件 RetentionPolicy.RUNTIME 运行期 其中第一个源码级别的就是，只有源代码处理器是可见的。比如上面我们提高的两个注解都是源码级别的注解。当.java文件编译成为.class文件之后，我们是无法访问到这个注解的。 其中类文件级别是默认的级别。如果我们不指定就是这个级别。此时.class文件中我们是可以访问到这个注解的。不过当.class文件在JVM中运行的时候，注解将会消失。 其中运行级别就是无论什么时候，注解都不会消失，此时我们可以通过反射来获取到注解并且对注解进行一些处理。这也就是意味着我们使用反射是无法访问到声明为RetentionPolicy.SOURCE或者RetenttionPolicy.CLASS的注解的，比如说上面的那个两个注解。一般我们声明注解的时候都需要声明为RUNTIME级别，因为我们需要使用反射去处理注解。 还有元注解@Documented是给javadoc这些文档化工具的提示的。@Inherited注解只用于类，表示这个注解是可以继承的，这个类的所有的子类都会拥有一个注解。@Repeatable表示这个注解可以在同一个地方被多次使用。不过我们需要做额外的工作。比如定义一个可以重复的@TestCase。 @Repeatable(TestCases.class) @interface TestCase { String params(); String expected(); } @interface TestCases { TestCase[] value(); } 此时当我们提供多个@TestCase的时候，会自动的装入@TestCases的容器中，这使得处理注解变得更为的复杂。 自定义注解现在我们就开始自定义一个注解用来练习，我们经常会使用toString()方法来输出类的信息。不过我们可能不想包含所有的实例变量或者是我们想跳过这个变量的名称。比如对Point类来说，我们更喜欢[5, 10]而不是Point[x = 5, y = 10]。此时我们可以自定义一个注解来实现这个功能。而且这个注解是对所有的类都是有效的。 @Target({ElementType.FIELD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @interface ToString { boolean includeName() default true; } 我们同样定义了两个类用于测试。 @ToString(includeName = false) class Point { @ToString(includeName = false) private int x; @ToString(includeName = false) private int y; public Point(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } } @ToString class Rectangel { @ToString(includeName = false) private Point topLeft; @ToString private int width; @ToString private int heighth; public Rectangel(Point topLeft, int width, int heighth) { this.topLeft = topLeft; this.width = width; this.heighth = heighth; } public Point getTopLeft() { return topLeft; } public void setTopLeft(Point topLeft) { this.topLeft = topLeft; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeighth() { return heighth; } public void setHeighth(int heighth) { this.heighth = heighth; } } 此时我们希望一个矩形输出可以是Rectangle[[5, 10], width = 20, height = 30]这样的。 不过在运行的时候我们是不可以修改一个类的toString方法的，所以我们只好使用反射的方法写一个格式化任何对象的方法。 运行时的注解处理之前我们说反射的时候，也已经说过了关于注解的API了。如果一个注解是不可重复的，我们一般就可以使用getAnnotation来定位他。如果是可重复的，那就比较复杂了，我们不可以使用getAnotation的方式，因为会返回null，因为这个可重复注解被装进容器注解中去了。此时我们需要使用getAnnotationByType方法，他会浏览容器，并返回可重复注解的数组。 下面我们就要开始使用反射来处理上面的@ToString注解了。 public class ToStrings { public static String toString(Object object) { if (object == null) { return &quot;null&quot;; } Class&lt;?&gt; clazz = object.getClass(); ToString tostr = clazz.getAnnotation(ToString.class); if (tostr == null) { return object.toString(); } StringBuilder result = new StringBuilder(); if (tostr.includeName()) { result.append(clazz.getSimpleName()); } result.append(&quot;[&quot;); boolean first = true; for (Field f : clazz.getDeclaredFields()) { tostr = f.getAnnotation(ToString.class); if (tostr != null) { if (first) { first = false; } else { result.append(&quot;, &quot;); } f.setAccessible(true); if (tostr.includeName()) { result.append(f.getName()); result.append(&quot; = &quot;); } try { result.append(ToStrings.toString(f.get(object))); } catch (IllegalAccessException e) { e.printStackTrace(); } } } result.append(&quot;]&quot;); return result.toString(); } } 然后我们可以在原来的类中测试。 public static void main(String[] args) { Rectangel rectangel = new Rectangel(new Point(5, 10), 20, 30); System.out.println(ToStrings.toString(rectangel)); // Rectangel[[5, 10], width = 20, heighth = 30] } 输出完全正确。不过需要注意的是，这个注解不仅仅是为上面的这两个类写的，如果我们新建一个其他的类，只要在对应的地方加上@ToString注解都是可以用的。比如说我们新建一个Student对象。 @ToString public class Student { @ToString private String name; @ToString private int age; @ToString private double score; private long qq; public Student(String name, int age, double score, long qq) { this.name = name; this.age = age; this.score = score; this.qq = qq; } } 然后写一个测试。 @Test public void test() { Student sher = new Student(&quot;sher&quot;, 18, 99.8, 10086); System.out.println(ToStrings.toString(sher)); // Student[name = sher, age = 18, score = 99.8] } 此时我们没有修改任何@ToString和ToStrings.toString()的任何代码，也完成了这个功能，可见注解的强大之处。上面我们是使用反射的方式在运行期间处理注解，其实我们还是可以在源码级别中处理注解，然后一起编译的。不过那种东西实在是有点儿复杂，不适合此时了解。 总结上面算是对注解的一个简单的了解，以及如何创建一个自定义的注解，然后使用反射的方式实现这个注解的功能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机中的泛型——类型擦除]]></title>
    <url>%2F2019%2F10%2F18%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%2F</url>
    <content type="text"><![CDATA[Java虚拟机中的泛型——类型擦除前言上面我们已经简单的介绍了Java中的泛型的基本的用法了。按理来说，已经足够我们昏头昏脑的去使用泛型了。一开始我们会感觉泛型是多么的简单，然后用着用着就会发现，泛型到底是个什么东西，越来越不能理解泛型了。此时，我们就需要进一步的去理解泛型，而不是将泛型局限在简单的加一个&lt;T&gt;上面。 类型擦除我们先来一个经典的测试题。 @Test public void test() { List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); System.out.println(list1.getClass() == list2.getClass()); } 请问上面的输出的什么？之前我们说反射的时候已经提及到了getClass是获取对应的类的唯一的那个反射对象。之前我们也说过List&lt;String&gt;，List&lt;Integer&gt;是完全没有关系的，但是他们的唯一的父类是List&gt;?&gt;。所以说上面的输出是false？？答案是错误的，上面的输出的结果是true。 我们发现输出的结果是class java.util.ArrayList，而ArrayList.class输出的结果也是这样。怎么会这样，我们的泛型信息呢？怎么丢掉了？？其实这就是类型擦除，泛型将在Java虚拟机中被擦除，也就是无论你在代码中写了什么泛型，Java虚拟机是不知道什么叫泛型的。 之前我们也说过了，泛型是JDK5之后才被引入的，之前的Java代码都是没有泛型的。比如我们使用ArrayList的时候，会这样使用。 @Test public void test1() { List list = new ArrayList(); list.add(&quot;sher&quot;); list.add(33); list.add(new Date()); list.forEach(System.out::println); } 这是之前我们使用ArrayList的方式，没有任何的泛型信息。ArrayList中可以存放任何类型的数据。嗯？可以存放任何类型的数据，那这岂不是更好了？？但是我们似乎没有必要去存放各种类型不同的数据，如果按照上面这样写的话，我们add的都只能是Object类型的对象。当我们使用get的时候返回的数据的类型也都是Object，我们还需要对其中的不同的对象进行转型，这很不方便而且非常不安全。因此，我们是非常的建议使用泛型的。但是我们之前都是没有泛型的，现在引入了泛型，这对Java之前的生态是不是有很大的影响呢？比如说之前的代码都不可以运行了。这当然是不可取的，Java可不是python，Java是一门非常向前兼容的语言。那么我们必然是可以讲ArrayList&lt;String&gt;传给之前接受ArrayList类型的方法。(里面存放的是Object类型的数据)。那么ArrayList相当于一个ArrayList&lt;Object&gt;吗？当然不是，至少ArrayList&lt;String&gt;是不可以赋值给ArrayList&lt;Object&gt;的。 @Test public void test2() { List list = null; List&lt;String&gt; list1 = null; List&lt;Object&gt; list2 = null; list = list1; // Right list2 = list1; // Error } 当我们定义一个泛型类型的时候，他会被编译成为一个原始的类型。比如说我们之前说的Entry&lt;K, V&gt;就会变成了。 public class Entry { private Object key; private Object value; public Entry(Object key, Object value){ this.key = key; this.value = value; } public Object getKey() {return key;} public Object getValue() {return value;} } 每一个K V都会被替换称为Object。不过这也不是必然的，如果我们的Entry的声明是这样的话。 public class Entry＜K extends Comparable&lt;? super K&gt; &amp; Serializable, V extends Serializable&gt; 编译之后就会变成如下的形式。编译之后的类型将会被类型上限说取代。 public class Entry { private Comparable key; private Serializable value; } 为什么key的Serializable丢失了呢？那是因为，如果类型有多个限定的话，将会被第一个限定取代。 但是有了类型擦除并不是代表着不安全，其实很安全，因为编译器会为我们做安全检查还有自动转换。我们无法将其他的类型的对象插入到List&lt;String&gt;中，但是也是有例外的时候。我们说过运行的时候是没有泛型的，此时我们就可以通过反射放入我们想要的对象。比如说如下的方式。 @Test public void test3() throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Class&lt;? extends List&gt; clazz = list.getClass(); Method add = clazz.getMethod(&quot;add&quot;, Object.class); add.invoke(list, new Date()); String s = list.get(0); System.out.println(s); } 上面的代码编译器没有给我们任何的警告，因为他自以为类型是安全的，list中只有String类型的变量，但是我们通过反射的方式放入了一个Date对象。因为运行期间泛型被擦除了，add方法变成了public add(Object e)，所以我们可以放入任何的对象。(我们通过反射寻找这个方法的时候也是Object.class)。 @Test public void test3() throws Exception { List&lt;String&gt; list = new ArrayList&lt;&gt;(); Class&lt;? extends List&gt; clazz = list.getClass(); Method add = clazz.getMethod(&quot;add&quot;, Object.class); add.invoke(list, new Date()); System.out.println(list.get(0)); // Error Date date = (Date) list.get(0); // Error Date date1 = (Date) (Object) list.get(0); // Right System.out.println(date1); Object o = list.get(0); o = (Date) o; System.out.println(o); } 需要或许数据是不可以直接进行转型的，需要转为Object类型才行。因为我们使用get方法的时候是默认进行了转型的。 需要注意的是，由于类型擦除的缘故，我们是没有办法在静态方法或者是静态字段中使用泛型的。 桥方法上面我们也基本明白了，类型擦除是简单的而且安全的，但是只是绝大多数情况是如此。不过编译器做的事情远比我们想的多，有时会合成桥方法。这只是泛型的实现的细节，我们并不需要去了解他。但是如果我们想要更加深入的了解Java中的泛型，还是有必要去了解一下编译器干了什么的。 public class WordList extends ArrayList&lt;String&gt; { public void add(String e) { return isBadWord(e) ? false : super.add(e); } ...... } 如果我们是这样使用的话。 WordList words = ...; ArrayList&lt;String&gt; strings = words; // It is right strings.add(&quot;C++&quot;) 上面的代码是完全没有任何问题的，第三行调用的什么函数？？按道理来说应该是WordList的add方法，但是真的可以调用到么？首先是调用ArrayList&lt;String&gt;中的add(Object e)(ArrayList&lt;String&gt;中是没有add（String str)的)，这是根据多态，然后应该调用。。。emm，多态？？哪儿来的多态？子类中只有一个add(String e)，这没有多态啊。所以不会调用子类的函数。但是经过实验，确实是调用了子类的函数了的。那么是如何实现的呢？肯定是通过多态实现，因为父类想要调用子类的函数只有多态这一条路。 为了做到这一点，编译器在WordList中添加一个桥方法，声明如下。 public void add(Object e) { add((String) e); } 这样就可以实现多态了。不过这个函数的多态调用通过了一个桥一样的东西，这就是所谓的桥方法。 当返回类型改变的时候，同样会生成桥方法。 public String get(int i) { return super.get(i).toLowerCase(); } 使用同样的方法，应该调用的是ArrayList中的Object get(int i)方法。但是WordList中没有对应的不同的函数，所以会在WordList中生成桥方法Object get(int i)，这个桥方法中会调用WordList中的String get(int i)方法。 你可能会想，不对啊，我寻思String get(int i)不是可以重写Object get(int i)方法的吗？没有桥方法不就是可以实现多态的吗？其实我们想多了，没有泛型的时候也是会生成桥方法的。上面的返回类型不一致之所以可以调用就是因为生成了桥方法，所以说桥方法不是泛型的专属。 不过桥方法也会导致其他的问题，最显著的问题就是方法的冲突问题，这里就不多说了。 实例类型变量与数组我们无法创建new T(...)或者new T[...]这样的表达式中使用类型变量。这些形式都是非法的，因为当类型T被擦除之后，编译器并不知道应该创建什么类型的变量。 public static &lt;T&gt; T[] repeat(int n, T obj) { T[] result = new T[n]; // Error for (int i = 0; i &lt; n; i++) { result[i] = obj; } return result; } 为了实现这个方法，我们需要提供类型的构战函数。 public static &lt;T&gt; T[] repeat(int n, T obj, IntFunction&lt;T[]&gt; ctor) { T[] result = ctor.apply(n); for (int i = 0; i &lt; n; i++) { result[i] = obj; } return result; } @Test public void test() { String[] hellos = repeat(3, &quot;hello&quot;, String[]::new); System.out.println(Arrays.toString(hellos)); } 除此之外，我们还可以使用反射的机制来完成构造函数的工作。 public static &lt;T&gt; T[] repeat(int n, T obj, Class&lt;T&gt; clazz) { @SuppressWarnings(&quot;unchecked&quot;) T[] result = (T[]) Array.newInstance(clazz, n); for (int i = 0; i &lt; n; i++) { result[i] = obj; } return result; } @Test public void test2() { String[] worlds = repeat(5, &quot;world&quot;, String.class); System.out.println(Arrays.toString(worlds)); } 不过需要注意的是，当我们使用ArrayList&lt;T&gt;的时候，我们是可以直接new的。 public static &lt;T&gt; List&lt;T&gt; repeat(int n, T obj) { List&lt;T&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) { result.add(obj); } return result; } @Test public void test3() { List&lt;String&gt; sher = repeat(3, &quot;sher&quot;); System.out.println(sher); } 当我们没有什么强有力的理由去使用原生数组的话，我们是没有必要绕道去想解决方法的，我们可以直接使用ArrayList，这样简单清晰的多。 另外的一个话题是实例化类型变量的数组。 ArrayList&lt;String&gt;[] lists = new ArrayList&lt;String&gt;[100]; 这种方式是错误的。因为类型擦除了，我们创建的是一个原始的ArrayList数组，可以添加任何类型的数据的ArrayList对象，比如说ArrayList&lt;Integer&gt;，ArrayList&lt;Data&gt;，因为这些东西在运行期间都是一样的。不过，ArrayList&lt;String&gt;[]这种语法是正确的，如果我们真的要使用这种看着都很难受的东西的话，我们需要这样使用。 @Test public void test4() { @SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;String&gt;[] lists = (ArrayList&lt;String&gt;[]) new ArrayList&lt;?&gt;[5]; System.out.println(Arrays.toString(lists)); } 不过还是要说的是，我们大可不必这么写，我们完全可以这么写。 ArrayList&lt;ArrayList&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(5); System.out.println(list); 这种写法才是我们推荐的，也是很多API所使用的写法。 总结上面基本上就是这次学习泛型的所有的东西了。其实还有一个细节是没有说的。在Java虚拟机中，类型擦除只是擦除那些实例化的变量，对于泛型类与泛型方法的完整信息在运行期间是可用的。不过这点确实是有点复杂，而且一点都不常用，所以此处直接略过了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型简介]]></title>
    <url>%2F2019%2F10%2F18%2FJava%E6%B3%9B%E5%9E%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Java泛型简介前言今天要说的是Java中的泛型，其实在C++中我们早就接触到了泛型，也感受到了泛型的强大。使用了泛型，我们可以不再为了不同的类型写多个相同的函数。比如说下面就是一个泛型的函数。 template &lt;typename T, typename U&gt; auto add(const T&amp; t, const U&amp; u) -&gt; decltype(u + t) { return u + t; } 通过上面的函数，我们就可以写出一个add函数，作用是将两个参数相加，但是这两个参数可以是任何的类型的。那么Java中有没有相似的泛型技术呢？其实是有的，在JDK5之后，Java也引进了泛型的技术。其实我们是经常见到泛型的，比如说 List&lt;String&gt; list = new ArrayList&lt;&gt;(); 其中&lt;String&gt;就是一个泛型，写法是和C++一致的(很有可能就是抄袭C++的，毕竟C++在泛型编程这一块是非常的强大的，最伟大的泛型编程的作品就是C++的标准模板库，也就是我们经常说的STL)。 那么下面我们就来介绍一下Java中的泛型吧。 泛型方法和C++一样，我们先来接触一下泛型的方法。当我们需要声明一个泛型方法时，我们需要在修饰符之后(public static)，返回类型之前写一个类型参数。语法如下。 public static &lt;T&gt; void swap(T[] array, int i, int j) { T temp = array[i]; array[i] = array[j]; array[j] = temp; } 这样我们就声明出了交换数组中某两个位置的函数了（这里为了简单没有检查范围）。 但是问题却出现了。 public static void main(String[] args) { int[] arr1 = {1, 2, 3, 4}; swap(arr1, 1, 2); System.out.println(arr1); } 上面的代码出错了，是什么没有符合这个类型的函数。其实这个问题我们之前也说过了，当我们使用泛型的时候，只可以使用对象类实现。比如我们只能使用List&lt;Integer&gt;而不可以使用List&lt;int&gt;。但是我们可以放int值进入啊，为什么这儿报错了呢？确实基本数据类型有装箱机制，但是int[]是没法转变成为Integer[]的。 public static void main(String[] args) { Integer[] arr1 = {1, 2, 3, 4}; swap(arr1, 1, 2); System.out.println(Arrays.toString(arr1)); String[] arr2 = {&quot;hello&quot;, &quot;world&quot;, &quot;sher&quot;}; swap(arr2, 1, 2); System.out.println(Arrays.toString(arr2)); } 我们可以使用上面的方式调用这个函数。但是，我就是想要int[]也可以用这个函数，有没有办法呢？其实是有办法的。 int[]是一个数组，那么Java中的数组是基本数据类型吗？不是，数组其实一个对象，泛型可以用于对象上面，那么当然是可以用于int[]上面的。但是，我们就需要之前学的反射的知识了。 public static &lt;T&gt; void swapPlus(T arr, int i, int j) throws Exception { Class&lt;?&gt; clazz = arr.getClass(); if (!clazz.isArray()) { return; } Object temp = Array.get(arr, i); Array.set(arr, i, Array.get(arr, j)); Array.set(arr, j, temp); } 这里我们使用的不是T[] 而是T，这样int[]就可以作为Object传入函数了。此时我们就可以通过反射的方式操作这个函数了。这个函数也是适用与其他的数组的，是一个通用的方法。 泛型类之前我们看的ArrayList，HashMap都是泛型类，甚至那个Entry也是一个泛型类。我们使用的时候都是这样子用的。HashMap&lt;K, V&gt;因为我们并不知道需要放入的键值的类型，只好声明为K V。等到我们使用的时候指定需要的类型是什么。比如说Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();后面的&lt;&gt;中可以省略类型声明，毕竟前面都已经写过一遍了。泛型类和泛型方法不一致的是，使用泛型类的时候需要我们指定类型。而泛型方法不需要我们提供类型，这一点和C++也是类似的。 泛型类的声明方式是在类名之后加上类型参数。 class A&lt;E&gt; { private E element; A(E e) { this.element = e; } public E getElement() { return element; } public void setElement(E element) { this.element = element; } @Override public String toString() { return &quot;A{&quot; + &quot;element=&quot; + element + &#39;}&#39;; } } 通过上面的方式我们就声明一个简单的泛型类，其中有一个私有的泛型的属性。 类中的类型参数类中的方法都是可以使用的，但是如果我们需要在类中声明额外的泛型方法，这当然也是可以的。我们可以将这个类型参数声明和泛型类的类型参数一致（不建议这么脑残），此时优先使用的是泛型方法的类型参数。 类型限定有时候我们需要对泛型的类型做一些限定，比如说这个类型必须要实现了Comparable接口才可以，此时我们可以这么写。 public static &lt;T extends Comparable&gt; void func(T t1, T t2) { if (t1.compareTo(t2) &gt; 0) { System.out.println(&quot;The fromer is bigger&quot;); } else { System.out.println(&quot;The Later is bigger&quot;); } } @Test public void test2() { String str1 = &quot;Hello&quot;; String str2 = &quot;World&quot;; func(str1, str2); } 此时调用func的参数必须要实现Comparable这个接口，如果没有实现这个接口是没法调用的。不过也可以有多个限定。 public static &lt;T extends Comparable &amp; Serializable&gt; void func(T t1, T t2) { if (t1.compareTo(t2) &gt; 0) { System.out.println(&quot;The fromer is bigger&quot;); } else { System.out.println(&quot;The Later is bigger&quot;); } } 使用&amp;符号相连，就想捕捉异常那样子一样。 通配符如果我们需要实现一个方法，用来处理Employee类的子类组成的数组，我们只需要讲参数声明为Employee[]就行了。比如说Manager是Employee的一个子类，此时Manager[]也是Employee的子类，因为Java中数组具有协变性。但是如果我们使用的不是原生数组，而是动态数组ArrayList呢？此时如果我们使用ArrayList&lt;Employee&gt;是没有用的。 @Test public void test4() { List&lt;Employee&gt; employeeList = null; List&lt;Manager&gt; managerList = null; employeeList = managerList; // Error employeeList.add(new Employee()); } 上面的代码告诉我们，其实List&lt;Manager&gt;不是List&lt;Employee&gt;的子类，是不可以进行赋值。如果第六行代码可以通过编译的话，那么第七行代码就是可以执行的，此时可以将一个普通的员工加入经理的数组中，这显然是不合适的。所以Java中禁止了这样的操作。Java中的数组虽然是具有协变性，但是如果我们将Employee对象放入到Manager数组中，也是会抛出异常的，所以说具有协变性非常的方便但是也有缺点。那么我们该如何解决这个问题呢？我们需要找到他们共同的父类，那是List&lt;Object&gt;吗？闭着眼睛想都不可能是的。如果是的话那就真的乱套了，不仅普通员工可以加入到经理的列表中，甚至什么老鼠猴子都是可以的。Java中提供了通配符?帮助我们解决这个问题。 List&lt;?&gt;就是任何的List&lt;xxx&gt;的父类，他自然也都是List&lt;Employee&gt;和List&lt;Manager&gt;的父类，不过这个题目中我们说的是所有的Employer子类，我们就应该使用List&lt;? extends Employee&gt; 不过我们使用add操作的时候，却发现了问题。编译器不允许我们进行添加数据。毕竟?可以是Employee的任何子类，所以我们是没有办法进行添加数据的。但是我们可以进行读的操作。因为只要是Employee的子类都是可以赋值给Employee的，不过也有一个例外的，我们可以想数组中添加null，比较任何对象都可以是null，添加null是肯定没有任何问题的，但是添加null真的有意义吗？ @Test public void test4() { List&lt;Manager&gt; managerList = new ArrayList&lt;&gt;(); managerList.add(new Manager()); List&lt;? extends Employee&gt; list = null; list = managerList; Employee employee = list.get(0); System.out.println(employee.getClass()); } 取出来的是Employee但是我们也可以将其强转为Manager，毕竟我们通过getClass可以知道其实这是一个Manager对象。 上面说的是子类型的通配符，其实还有一种父类型的通配符。上面的是有下界，这里是有上界。不过这两种通配符都是可以匹配自己的。比如说? extends Employee，此时Employee也是在这个范围之内的。? super Manager如是。 List&lt;? super Manager&gt;就代表着List中是Manager的父类，使用的方式比较相似。 @Test public void test5() { List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); employeeList.add(new Employee()); List&lt;? super Manager&gt; list = employeeList; list.add(new Manager()); list.add(new BigMan()); System.out.println(list); Object object = list.get(1); System.out.println(object.getClass()); } 不过需要注意的是，此时我们是可以进行读写两种操作的。? super Manager表示其中肯定是Manager的父类的类型。子类是可以赋值给父类的，此时我们就可以添加任何的Manager以及其子类类型的对象。(上面的BigMan是Manager的子类)。至于获取，我们并不知道我们将要获取到一个什么样类型的对象，但是既然是一个对象我们就可以将其赋值给Object，所以对于？ super Manager，我们是可以对其进行读写两种操作的。 ? super xx这种用法是经常用于函数式对象的参数。比如我们需要根据给定的属性打印出员工的姓名。 public static void printAll(Employ[] emps, Predicate&lt;Employee&gt; filter) { for (Employ e : emps) { if (filter.test(e)) { System.out.println(e.getName()); } } } 当然我们也可以使用一个lambda表达式来传递这个参数。 printAll(emps, e -&gt; e.getSalary() &gt; 10000); 不过有时候我们想要使用一个Predicate&lt;Object&gt;来替代他。 printAll(emps, e -&gt; e.toString().length() % 2 == 0); 这个没有任何的问题，因为toString方法其实是Object和他的子类共有的一个方法。不过Predicate&lt;Object&gt;和Predicate&lt;Employee&gt;是毫无关系的两个类。此时我们就需要使用Predicate&lt;? super Employee&gt;。 public static void printAll(Employ[] emps, Predicate&lt;? super Employee&gt; filter) { for (Employ e : emps) { if (filter.test(e)) { System.out.println(e.getName()); } } } 此时e是Employee的父类，他可以使用的方法，Employee也是可以使用的。 一般情况下，当给方法指定一个泛型函数式接口的时候，我们应当使用super通配符。 小提示： 很多的程序员喜欢使用PECS的方法来帮助直接来记忆。Productor生产者使用extends，Consumer消费者使用super。当我们从ArrayList中读取数据的时候，我们需要使用extends，此时是生产者。如果要将值传递给Predicate用来测试的时候，此时是消费者。 ​ —— 以上的部分内容来自《Core Java for the Impatient》 通配符捕获我们尝试使用通配符定义一个swap方法。 public static void swap(ArrayList&lt;?&gt; list, int i, int j) { Object temp = list.get(i); list.set(i, list.get(j)); // Error list.set(j, temp); // Error } 之前我们也说过了，这个时候我们是可以从数组得到数据，但是我们不可以对数据进行修改。那么我们到底该怎么做呢？ public static void swap(List&lt;?&gt; list, int i, int j) { swapHelper(list, i, j); } private static &lt;T&gt; void swapHelper(List&lt;T&gt; list, int i, int j) { T temp = list.get(i); list.set(i, list.get(j)); list.set(j, temp); } 上面就是通配符匹配I的例子。编译器虽然是不知道?到底是个什么玩意，但是知道它代表是某种类型，所以说调用一个泛型方法是没有问题的。也就是说swapHelper中的T捕获了，这个?，此时我们就可以使用T来声明变量。 但是这样做，我们得到了什么呢？直接使用swapHelper这个泛型函数不是更好。。。其实我也不是很能理解官方的说辞。说什么List&lt;?&gt;这样的API更加的友好，泛型函数不好。我倒是感觉反过来了。没学过?是什么含义的，估计死都不会用，但是看到泛型方法倒是很容易理解。 总结上面简单的介绍了Java中泛型方法、泛型类，以及通配符的使用。不过泛型还有很多需要注意的地方没有说。下面我们将会更加深入的Java中的泛型。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射是个什么鬼？]]></title>
    <url>%2F2019%2F10%2F17%2F%E5%8F%8D%E5%B0%84%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E9%AC%BC%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[反射是个什么鬼？前言看到这个题目，你可能要说这个题目是个什么鬼，但是我认为你更应该说反射是个什么鬼。其实反射也不是一个什么鬼，反射其实是和java中的类的加载机制息息相关的，不过这里我们就不深入底层。先直接简单的了解一下Java中的反射机制。先是会用，然后再去理解一下，为什么可以这么用。 对象是类？其实很久很久之前，我们就提到了反射，并且介绍了一点反射的用法。比如说我们将同步监视器的时候说可以使用类名.class作为类唯一的同步监视器。就在我们说到使用fastjson进对象进行深拷贝之后恢复这个对象的时候，也需要使用类型.class作为参数传入函数。我们发现函数的参数的类型是Class&lt;?&gt; clazz。这里的&lt;?&gt;就先不说了，可以留着以后专门来说。这个Class肯定是一个类名，那么类名.class是一个对象？？这个对象是干嘛用的？这是我们的疑问。那么我们就先从Class类的官方文档开始看起。 Class对象public final class Class&lt;T&gt; extends Object implements Serializable, GenericDeclaration, Type, AnnotatedElement T - 由此类对象建模的类的类型。 例如， String.class的类型是Class&lt;String&gt; 。 如果正在建模的类是未知的，请使用Class&lt;?&gt; 。 Class类的对象表示正在运行的Java应用程序中的类和接口。 枚举是一种类，一个注释是一种界面。 每个数组也属于一个反映为类对象的类，该对象由具有相同元素类型和维数的所有数组共享。 原始Java类型（ boolean ， byte ， char ， short ， int ， long ， float和double ），和关键字void也表示为类对象。 上面说了Class类的对象表示一个类？对象和类是怎么表示的？难道是类也可以看成是一个对象吗？要这么说还真的是可以的，毕竟我们创建类的时候也是按照一定的规则写的，比如各种属性，各种函数。不过，类可以看成是一个对象这个说法是错误的，可以说一个类可以对应是一个对象。而这个对象不是其他的，就是类名.class 下面我们创建了一个对象 class Student { private String name; private int id; public Student() { } public Student(String name, int id) { this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return &quot;Student{&quot; + &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; + &quot;, id=&quot; + id + &#39;}&#39;; } } 其中我们使用类名.class的方式就可以获取对应这个类的Class对象。 Class&lt;Student&gt; studentClass = Student.class; 如果我们需要的不是对象，而是基本数据类型，是不是我们就要使用他们的包装类呢？这里不是的。上面的文档也说了我们可以使用int.class、double.class甚至你还可以使用void.class。这简直是太神奇了！ 不过现在我们需要探讨的这个问题是，对象是不是唯一的呢？获取的方式是不是只有通过类.class这一种方式呢？ 其实我们也可以通过对象.getClass()的方式，得到这个类的Class对象。不同的对象是不是一样的呢？或者说这两种返回Class对象的方式返回的是不是一样的呢？ public class Demo1 { public static void main(String[] args) { Class&lt;Student&gt; studentClass = Student.class; Student student = new Student(); Student student1 = new Student(); System.out.println(student.getClass() == studentClass); // true System.out.println(student.getClass() == student1.getClass()); // true System.out.println(&quot;123&quot;.getClass() == String.class); // true System.out.println(Integer.class == int.class); // false } } 我们发现除了最后的一个是输出false其余的都是输出true，那么我们也就可以得知，每一个类对应的对象只有那唯一的一个，而且int.class和Integer.class是不一样的。包装类也是类，而int则是基本的数据类型，是不可以划等号的。那么这个类有什么作用呢？那就是要看这个类有什么样的方法。 &lt;U&gt; 类&lt;? extends U&gt; asSubclass(类&lt;U&gt; clazz) 类这个 类对象来表示由指定的类对象表示的类的子类。 T cast(Object obj) 施放一个目的是通过本表示的类或接口 类对象。 boolean desiredAssertionStatus() 如果要在调用此方法时初始化该类，则返回将分配给此类的断言状态。 static 类&lt;?&gt; forName(String className) 返回与给定字符串名称的类或接口相关联的 类对象。 static 类&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) 使用给定的类加载器返回与给定字符串名称的类或接口相关联的 类对象。 AnnotatedType[] getAnnotatedInterfaces() 返回一个 AnnotatedType对象的数组， AnnotatedType使用类型指定由此 AnnotatedType对象表示的实体的超级 类 。 AnnotatedType getAnnotatedSuperclass() 返回一个 AnnotatedType对象，该对象表示使用类型来指定由此 类对象表示的实体的 类类。 &lt;A extends Annotation&gt; A getAnnotation(类&lt;A&gt; annotationClass) 返回该元素的，如果这样的注释 ，否则返回null指定类型的注释。 Annotation[] getAnnotations() 返回此元素上 存在的注释。 &lt;A extends Annotation&gt; A[] getAnnotationsByType(类&lt;A&gt; annotationClass) 返回与此元素相关 联的注释 。 String getCanonicalName() 返回由Java语言规范定义的基础类的规范名称。 类&lt;?&gt;[] getClasses() 返回包含一个数组 类表示所有的公共类和由此表示的类的成员接口的对象 类对象。 ClassLoader getClassLoader() 返回类的类加载器。 类&lt;?&gt; getComponentType() 返回 类数组的组件类型的Class。 Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) 返回一个 Constructor对象，该对象反映 Constructor对象表示的类的指定的公共 类函数。 Constructor&lt;?&gt;[] getConstructors() 返回包含一个数组 Constructor对象反射由此表示的类的所有公共构造 类对象。 &lt;A extends Annotation&gt; A getDeclaredAnnotation(类&lt;A&gt; annotationClass) 如果这样的注释 直接存在 ，则返回指定类型的元素注释，否则返回null。 Annotation[] getDeclaredAnnotations() 返回 直接存在于此元素上的注释。 &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(类&lt;A&gt; annotationClass) 如果此类注释 直接存在或 间接存在，则返回该元素的注释（指定类型）。 类&lt;?&gt;[] getDeclaredClasses() 返回一个反映所有被这个 类对象表示的类的成员声明的类和 类对象的数组。 Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) 返回一个 Constructor对象，该对象反映 Constructor对象表示的类或接口的指定 类函数。 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回一个反映 Constructor对象表示的类声明的所有 Constructor对象的数组 类 。 Field getDeclaredField(String name) 返回一个 Field对象，它反映此表示的类或接口的指定已声明字段 类对象。 Field[] getDeclaredFields() 返回的数组 Field对象反映此表示的类或接口声明的所有字段 类对象。 方法 getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 类对象。 方法[] getDeclaredMethods() 返回包含一个数组 方法对象反射的类或接口的所有声明的方法，通过此表示 类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 类&lt;?&gt; getDeclaringClass() 如果由此 类对象表示的类或接口是另一个类的成员，则返回表示其声明的类的 类对象。 类&lt;?&gt; getEnclosingClass() 返回底层类的即时封闭类。 Constructor&lt;?&gt; getEnclosingConstructor() 如果此类对象表示构造函数中的本地或匿名类，则返回表示底层类的立即封闭构造函数的Constructor对象。 方法 getEnclosingMethod() 如果此类对象表示方法中的本地或匿名类，则返回表示基础类的即时封闭方法的方法对象。 T[] getEnumConstants() 返回此枚举类的元素，如果此Class对象不表示枚举类型，则返回null。 Field getField(String name) 返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段 类对象。 Field[] getFields() 返回包含一个数组 Field对象反射由此表示的类或接口的所有可访问的公共字段 类对象。 Type[] getGenericInterfaces() 返回 Type表示通过由该对象所表示的类或接口直接实现的接口秒。 Type getGenericSuperclass() 返回 Type表示此所表示的实体（类，接口，基本类型或void）的直接超类 类 。 类&lt;?&gt;[] getInterfaces() 确定由该对象表示的类或接口实现的接口。 方法 getMethod(String name, 类&lt;?&gt;... parameterTypes) 返回一个 方法对象，它反映此表示的类或接口的指定公共成员方法 类对象。 方法[] getMethods() 返回包含一个数组 方法对象反射由此表示的类或接口的所有公共方法 类对象，包括那些由类或接口和那些从超类和超接口继承的声明。 int getModifiers() 返回此类或接口的Java语言修饰符，以整数编码。 String getName() 返回由 类对象表示的实体（类，接口，数组类，原始类型或空白）的名称，作为 String 。 软件包 getPackage() 获取此类的包。 ProtectionDomain getProtectionDomain() 返回 ProtectionDomain 。 URL getResource(String name) 查找具有给定名称的资源。 InputStream getResourceAsStream(String name) 查找具有给定名称的资源。 Object[] getSigners() 获得这个类的签名者。 String getSimpleName() 返回源代码中给出的基础类的简单名称。 类&lt;? super T&gt; getSuperclass() 返回 类表示此所表示的实体（类，接口，基本类型或void）的超类 类 。 String getTypeName() 为此类型的名称返回一个内容丰富的字符串。 TypeVariable&lt;类&lt;T&gt;&gt;[] getTypeParameters() 返回一个 TypeVariable对象的数组，它们以声明顺序表示由此 GenericDeclaration对象表示的通用声明声明的类型变量。 boolean isAnnotation() 如果此 类对象表示注释类型，则返回true。 boolean isAnnotationPresent(类&lt;? extends Annotation&gt; annotationClass) 如果此元素上 存在指定类型的注释，则返回true，否则返回false。 boolean isAnonymousClass() 返回 true当且仅当基础类是匿名类时。 boolean isArray() 确定此 类对象是否表示数组类。 boolean isAssignableFrom(类&lt;?&gt; cls) 确定由此 类对象表示的类或接口是否与由指定的Class 类表示的类或接口相同或是超类或 类接口。 boolean isEnum() 当且仅当该类在源代码中被声明为枚举时才返回true。 boolean isInstance(Object obj) 确定指定的Object是否与此 Object表示的对象分配 类 。 boolean isInterface() 确定指定 类对象表示接口类型。 boolean isLocalClass() 返回 true当且仅当基础类是本地类时。 boolean isMemberClass() 返回 true当且仅当基础类是成员类时。 boolean isPrimitive() 确定指定 类对象表示一个基本类型。 boolean isSynthetic() 如果这个类是一个合成类，返回true ; 返回false其他。 T newInstance() 创建由此 类对象表示的类的新实例。 String toGenericString() 返回描述此 类的字符串，包括有关修饰符和类型参数的信息。 String toString() 将对象转换为字符串。 构造器我们发现方法多的不得了，但是每个方法似乎都是非常容易的理解的。比如说我们可以通过Class对象来新建类的对象。 @Test public void test() throws IllegalAccessException, InstantiationException { Class&lt;Student&gt; studentClass = Student.class; Student student = studentClass.newInstance(); System.out.println(student); } 只要使用newInstance方法就可以new一个这个类的对象。不过此时调用的是空参的构造器。不过IDE告诉我们这个方法已经从JDK9开始的时候就被废弃掉了。 @deprecated This method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The {@link java.lang.reflect.Constructor#newInstance(java.lang.Object...) Constructor.newInstance} method avoids this problem by wrapping any exception thrown by the constructor in a (checked) {@link java.lang.reflect.InvocationTargetException}. 反正上面就是说这个方法是怎么怎么有异常。推荐我们使用其他的方式替代他，不过我们现在正有这种想法，如果我们想要调用含有参数的构造函数，该怎么办呢？ 可以使用上面提供的getConstructor()方法。这个方法返回的是你想要的构造函数，比如说这里我们想要的是第一个参数是String，第二个参数是int。 @Test public void test1() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Constructor&lt;Student&gt; constructors = studentClass.getConstructor(String.class, int.class); Student sher = constructors.newInstance(&quot;sher&quot;, 10086); System.out.println(sher); } 上面使用的方法会抛出很多的异常，所以我们直接就throws Exception，不一一的try catch了。在我们使用了getConstructor方法之后，返回的是一个Constructor&lt;Student&gt;代表的是Student类的构造器，此时我们可以使用newInstance的方式来new一个对象，这也是官方文档中推荐我们使用的方式。 如果我们想要获取的是一个private的构造器通过上面的方式是否可以获取呢？ @Test public void test2() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Constructor&lt;Student&gt; constructor = studentClass.getConstructor(String.class); Student student = constructor.newInstance(&quot;sher&quot;); System.out.println(student); } 我们发现代码报了一个java.lang.NoSuchMethodException的错误。也就是说没有找到这个构造器，因为这个构造器我们声明是private的。那么是不是就没办法了呢？当然不是，我们可以通过getDeclaredConstructor方法获取到所有的构造器，无论是private public还是其他的，都是可以获取到的。 使用getDeclaredConstructor之后我们发现再次抛出了一个异常。java.lang.IllegalAccessException，我们想要使用一个私有的构造器，但是这是不合法的，所以编译器不允许我们这么干。但是，我们也可以让编译器闭嘴，只有给他一个true就行了。调用方法之前使用constructor.setAccessible(true);强制的将该方法变成可以访问的，这时候问题就解决了。 @Test public void test2() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Constructor&lt;Student&gt; constructor = studentClass.getDeclaredConstructor(String.class); constructor.setAccessible(true); Student student = constructor.newInstance(&quot;sher&quot;); System.out.println(student); } 其实constructor.setAccessible(true)不仅仅是使我们可以使用私有的方法，还有一个比较大的作用。当我们需要多次执行一个方法的时候，即使我们知道这个方法是public的，每次执行都会进行检查，而且这个检查非常的耗时间。此时我们就可以使用setAccessible(true)的方式关闭这个访问限定符的检查，从而提高效率。 方法上面说到的是构造器，我们也可以使用相似的方式得到方法然后调用。 @Test public void test2() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Constructor&lt;Student&gt; constructor = studentClass.getDeclaredConstructor(String.class); constructor.setAccessible(true); Student student = constructor.newInstance(&quot;sher&quot;); System.out.println(student); Method setName = studentClass.getMethod(&quot;setName&quot;, String.class); setName.invoke(student, &quot;hony&quot;); Method method = studentClass.getMethod(&quot;getName&quot;); Object invoke = method.invoke(student); System.out.println(invoke); } 此时调用方法的时候就不是使用newInstance，而是使用invoke方法。其中第一个参数是需要调用的对象。后面就是函数的参数。如果没有的话就不用填。可是为什么需要提供函数的调用的对象呢？因为我们这里我们获取的是非静态的方法需要对象才可以调用。如果我们获取的是静态的方法呢？此时没有调用的对象，我们直接将第一个参数赋值为null就行了。 @Test public void test3() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Method say = studentClass.getMethod(&quot;say&quot;, String.class); say.invoke(null, &quot;hello world&quot;); } public static void say(String string) { System.out.println(string); } 如果方法是私有的了的话，我们可以使用和上面的相同的方式来调用方法。使用getDeclaredMethod，并且使用setAccessible(true)就可以了。 我们看到Class类中的方法中，我们介绍的函数都有一个对应的加上s的函数。很容易理解使用getConstructors就是得到这个类的所有的构造器（public可以访问的）。如果是使用getDeclaredConstructors就是真正的返回所有的声明的方法。返回的类型是一个数组，我们可以使用增强的for循环来处理这个数组。 @Test public void test4() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Method[] declaredMethods = studentClass.getDeclaredMethods(); for (Method method : declaredMethods) { System.out.println(method.getName()); } } 属性类中除了方法，构造器之外，最常用的就是属性了。其实学会了一个之后学习其他的都是非常的轻松的，所以这里的属性其实是不用怎么说都应该很容易的明白的。 @Test public void test5() throws Exception { Student sher = new Student(&quot;sher&quot;, 11); Class&lt;?&gt; studentClass = sher.getClass(); Field name = studentClass.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(sher, &quot;hony&quot;); System.out.println(sher); Field staticField = studentClass.getDeclaredField(&quot;staticField&quot;); staticField.set(null, &quot;i am reflect&quot;); System.out.println(Student.staticField); } 注解除此之外，我们还可以获取某一个元素中注解。不仅仅是类中的注解，我们可以对Field Constructor Method对象调用getDeclaredAnnotations @Test public void test6() throws Exception { Class&lt;Student&gt; studentClass = Student.class; Annotation[] declaredAnnotations = studentClass.getDeclaredAnnotations(); System.out.println(declaredAnnotations.length); for (Annotation annotation : declaredAnnotations) { System.out.println(annotation); } } 这种方式只可以得到类上面的注解，对于类中的方法的注解通过这种方法是得不到的。需要注意的是此时Dwclared的含义发生了变化，因为注解是没有私有的这一个说法的。getAnnotations是获取所有的注解，包括自己声明的注解和继承的注解，但是使用getDeclaredAnnotaions就是获取自己声明的所有的注解。 我们也可以获取特定的注解，方式和上面是差不多的。 这里关于注解就不多讲了。其实使用反射来解析注解是一个非常重要的内容，但是放在这儿讲是非常的不合适的。 总结上面是极其极其简单的介绍了一下反射的使用，其实反射要讲的东西复杂的很，而且多得很，但是现在这个阶段是不合适的，所以我们这里只是简单的介绍一下，将来是肯定要深入了解反射这个东西的机会的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HastSet, HashMap(二) 看看源码]]></title>
    <url>%2F2019%2F10%2F16%2FHastSet-HashMap-%E4%BA%8C-%E7%9C%8B%E7%9C%8B%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HastSet, HashMap(二) 看看源码前言上面我们已经对Hash的工作原理，以及HashSet和HashMap的基本的介绍了。那么现在我们就直接从HashMap的原码开始看起吧。 HashMap源码先看一下HashMap的空参构造函数。 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } 里面对一个属性loadFactor做了一个赋值，其余的什么都没有做。联系到之前我们说的ArrayList的源码，我们不难猜出HashMap将在我们第一次使用put操作的时候加载底层的数据结构，实现了所谓的懒加载的机制。不过我们似乎先要将这个this.loadFactor搞清楚到底是个什么玩意。 /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * The load factor for the hash table. * * @serial */ final float loadFactor; 似乎什么也看不出来，这到底是一个什么玩意。不过按照中文的直译，这个东西应该被称为——装载因子。不过现在这个东西其什么作业我们还是不得而知，需要进一步的看源码。不过想要看懂下面的源码还是需要先来看看HashMap中有什么属性，也就是说用了什么结构。 table/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */ transient Node&lt;K,V&gt;[] table; 先看第一个，table。table前面有个限定词transient，这个之前也是说过的，加上了transient的属性在对象被序列化的时候将不会被序列化，也就是说不会被写入到文件中去。反序列化之后值将会被初始化。 看上面的注释，说这个table将会在第一次使用的时候被初始化，这正印证了刚才我们的猜想。后面还说了如果不够用的话这个数组将会扩容，一般规则是变成原来的两倍的大小，这个和Vector的规则是一致的。ArrayList的扩容规则是变成原来的1.5倍，StringBuilder则是变成原来的两倍加上2. 实际上这个table就是我们说的组成散列的那个数组，那么链表该如何来呢？我们看一下Node中的属性就明白了。 /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; ...... hash明显是用来存放放入的对象的hash值的，后面还有一个next属性，就是通过next属性，一个又一个的Node构成了一条链表。我们还注意到key是final的，但是value不是。那是因为如果我们插入相同的键的不同值，后面的那个值将会覆盖前面的值，所以不是vlalue不是final的。 entrySet/** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; Map.Entry这个类，我们之前也已经说过了，至于entrySet就是返回键值对的集合，如何使用我们之前也说过了，这里不在赘述。 threshold/** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; threshold是阈值的意思。不过这个东西比较有意思的地方是，竟然出现了单行注释//。emm，，有点儿奇怪。注释中说。这个阈值是table将要改变容量时大小的位置，后面还标注了capacity * load factor。容量乘以上面的提到的加载因子。那么谜团也就解开了，HashMap的扩容不是等到table放满了才扩容。比如说容量是16，默认的加载因子是0.75，那么等到table的被占用12个时候可能就要扩容了。当然这里扩容的具体的细节我们是不知道的。下面的单行注释就是一些细节上面的问题。 put源码其实要说的也就这几个属性，其他的属性还有点儿看不懂。还有一个属性是loadFactor之前已经说过了。 现在我们就好好的来看看put方法的源码。 /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key}. * (A {@code null} return can also indicate that the map * previously associated {@code null} with {@code key}.) */ public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; ....... 从put方法中，我们进入了putVal方法。其中hash函数是用来计算对象的hash值，这里可以不管他。不过我们可以稍微观摩一下hash函数的源码。 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 这里我们还是需要注意一点的，HashMap是可以放null值的。从上面的函数就可以看出来。如果放null的key的话，返回的hashCode的值是0。 putVal函数最后还有两个参数，其实不是很重要。onlyIfAbsent名如其意，只有当没有对象的键的时候添加，也就是说不要给我来所谓的替换值的操作。evict这个单词是真的不认识，不过注解中说如果是假的话，就开启创建模式。说实话有点懵。这里先不关注这个了。 直接看30行的那个if，此时table还没有创建，毫无疑问是空的，此时将进入resize函数。 /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 这个函数写的真的是，又臭又长，我有点儿不想看，嘤嘤嘤！！不过还是耐心来看一下吧。 首先看注释这个函数作用是，初识化table，或者对table进行扩容，扩容的规则是变成原来的两倍。 假如我们是以空数组初识化的目的来的，首先就会进入到26行的else语句块中，然后给数组的大小进行赋了一个默认值。 /** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 默认值是1 &lt;&lt; 4也就是16，至于为什么不直接写16，那当然是1 &lt;&lt; 4比直接写16的效率高啊。 新的阈值就被赋成了16 * 0.75f，也就是12。 通过31行代码，创建了table数组。而原来的数组就是空的。于是函数就直接返回了这个新创建的数组了。 假如我们是以扩容的数组的目的来到这个函数的，(这里就不探讨什么数组的长度直接超过了最大值的这种特殊的情况了)。其实将通过第一个if将容量和阈值变成原来的两倍。然后同样的通过31行代码新建了扩容后的数组。和初始化不同得是，此时将会进入39行的if中去。因为我们需要将原来的数组上面的数据拷贝到新创建的数组中来。看一下具体扩容的细节，我们发现了46行代码竟然判断了一下节点是不是TreeNode的节点。数组中挂的不应该是链表吗，怎么变成树了？难道说这也是HashMap的特殊手段吗？看到了48行代码中的else语句块，这个又是对链表的处理。 那么我们可以判定HashMap中table中储存的是既有链表又有树的。不过如何区分呢？这里还无从得知。 让我们回到putVal函数中去，通过resize函数，我们的table得到了初始化，下面就该放值进去了。其实这时候我们就不用考虑数组空还是不空了。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } 看一下上面的第6行。要提一下上面忘了说了的,(length-1) &amp; hash其实就是相当于length % hash这种取模运算，但是与运算的效率比较高，所以选择使用与运算。第六行中的(n-1) &amp; hash就是该对象应该放入table的第几个位置中。如果那个位置是空的，也就是说== null，那么直接放进去就行了（tab[i] = newNode(hash, key, value, null);）。 如果那个位置不是空的，那么就是按照我们之前说的那个原则进行判断。其中下面依旧提到了treeNode，这个我们之前是没有想到的，我们认为是只有链表的。先来一步一步看吧。 第10行的if如果进入了就相当于key是和那个位置的节点的key是一样的。不过为什么使用这种方式进行判断呢？ if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) 其实这也就是我们之前说过的。先判断hash值p.hash == hash，如果hash值都不想等那么两个对象肯定是不一样的。然后我们应该比较得是key是否相等。这里使用的是 (k = p.key) == key || (key != null &amp;&amp; key.equals(k)) 在Java中三个逻辑云算法的优先级是! &gt; &amp;&amp; &gt; ||。所以说上面的写法是后面的先结合。也就相当于。 (k = p.key) == key || (key != null &amp;&amp; key.equals(k)) 我们先比较key的地址，因为地址比较特别容易，如果地址相同，那么就是同一个对象，就没有必要进行equals操作了，因为equals操作可能是比较费时的，而且使用equals必须要key != null。然后13行就是处理树的操作。这里先不说。直接看一下后面的操作。 注意看一下第19行的操作binCount &gt;= TREEIFY_THRESHOLD - 1，其中binCount其实就是已经存在的链表的节点数-1，因为binCount是从0开始的。其中TREEIFY_THRESHOLD的声明如下。 /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; 其实无论是从这个变量的名字还是从文档的注释中我们都可以清楚的了解到，这个变量是用来标记什么时候一个链表将要变成一棵树。其实在JDK之前，我们使用的HashMap的底层都是使用数组加上链表来实现的，到了JDK8之后变成了数组加链表加红黑树的形式。众所周知，当链表变得很长的时候，查询的效率会变得特别的低，而如果我们使用树结构的话，将会大大降低我们的查询速度。如果binCount &gt;= TREEIFY_THRESHOLD - 1，就就代表这这个链表太长了，我们需要将其变成红黑树来存储。于是调用了函数treeifyBin(tab, hash);将链表变成了二叉树。 我们可以来看一看这个函数干了什么。 /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. */ final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { TreeNode&lt;K,V&gt; hd = null, tl = null; do { TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } } static final int MIN_TREEIFY_CAPACITY = 64; 看注释中的文档，如果数组的长度太小了的话，是不会将链表变成树的。其中，从第7行代码，我们可以得知，tab为空(这里明显不是空啊)或者是数组的长度太小（小于64）的话，会进行扩容而不是变树。然后下面就是变树的操作了，这里也不是二叉树专辑，所以不再介绍了。 我们继续回到putVal函数中，其中还有这样的代码。 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } 这里的e代表的是什么？其实就是查到了和所要插入的对象的键是相同的节点。这时候一般来说我们需要进行替换操作。不过这就要提到我们之前说的那个onlyIfAbsent参数了。如果这个参数是false的话，我们只有在值为空的时候才可以替换值。(键当然不是空的)。后面的函数就没啥好说的了。 不过还有一点是我们需要说的，就是对象插入链表是以何种方式的呢？请看第19行代码 p.next = newNode(hash, key, value, null); 其中这里的p是当前比较过后不相等的节点。此时我们新建一个节点，直接挂到这个节点的后面。(此时p节点的后面没有元素了)。其实这也是JDK8中采用的方式，JDK7之前采用的是使用新元素指向旧元素。但是JDK8使用的是旧元素指向新元素。这也被称为是七上八下。其实也就是JDK7中采用链表的头插法。JDK8中采用的是链表的尾插法，仅此而已。 至此，我们的put源码就都看完了。下面简单的说一下get的源码。 get源码/** * Returns the value to which the specified key is mapped, * or {@code null} if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * {@code k} to a value {@code v} such that {@code (key==null ? k==null : * key.equals(k))}, then this method returns {@code v}; otherwise * it returns {@code null}. (There can be at most one such mapping.) * * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it&#39;s also * possible that the map explicitly maps the key to {@code null}. * The {@link #containsKey containsKey} operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 相较于put方法，这个get方法可谓是简单的不要不要的。我们先通过hash找到数组的index。然后一次下去比较就完事了。不过还是要注意一下，下面到底是链表还是树，两者的比较的方法可是不同的。 总结上面简单的看了一下HashMap的源码，其实也就是put和get这两个方法，其实再说白了也就只是通过put方法简单的说明了Java当中HashMap底层的实现。看起来确实是蛮复杂的，但是如果仔细研究，认真阅读还是可以看懂大部分内容的。毕竟每一个方法上面都有详细的注释的说明。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HastSet, HashMap(一) Hash简介]]></title>
    <url>%2F2019%2F10%2F15%2FHastSet%2C%20HashMap(%E4%B8%80)%20Hash%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[HastSet, HashMap(一)前言之前我们学习C++ STL的时候也学到了set和map这两种数据结构。不过这里两种数据结构的实现似乎完全的不一样。C++中的是使用红黑书来实现的，而Java中的HashSet和HashMap明显是使用Hash这种结构来实现的。其实使用树还是hash在两种语言中都是有实现的。C++中的使用Hash实现的被称为unordered_set和unordered_map，而Java中使用红黑树来实现的被称为TreeSet和TreeMap。说实话C++中的这种起名方式是真的难听，而且不直观，他用的是是否有序来命令，Java中是使用底层的结构来命名。Java中使用TreeSet/Map其实是比较少的，因为如果要将一中数据放进去，那么这个类必须要实现排序的接口——Comparable。 Hash是什么？红黑树是什么玩意，这里我们就不详细的去了解了。但是如果连Hash都不知道的话，那么是没办法明白HashMap的。不过我们还是从HashSet开始说起。众所周知Set这个数据结构的要求是无序的，而且是不可以重复的。我们之前学过的存储结构有数组和链表。我们是否可以像ArrayList那样使一个数组来实现Set这个结构呢？当然是可以的。我们可以按顺序放，每次放入新的元素的时候就和前面的所有的元素比较一下。当我们放入了一万个元素的时候，需要和前面的一万个元素进行比较。这种效率简直是无与伦比的垃圾。如果是使用链表呢？？emm，，我想这个时候效率可能是更加的垃圾了。 那么该怎么办呢？ 不如来类比一下现实中的例子。假设我们的文件夹中有一万首歌，现在我们需要找一首歌的名字是《青花瓷》。按寻常的方法来做，那就是一首歌一首歌的找。(我为什么不能直接搜索呢？。。你搜索也就以电脑给你一个一个找的啊)。但是我们知道了这首歌是周杰伦的歌。如果我们存放歌曲的时候都按照歌手放一个文件夹的话，我们就可以直接进入到周杰伦的文件夹中去寻找，此时文件夹中歌曲的数目肯定是大大减小了，我们就可以更快的找到我们需要的歌曲了。(你怎么知道歌曲的歌手的？？因为歌曲名和歌手之前存在一种映射。。这里不考虑同名的歌多人唱的情况)。其实也很容易理解，我们讲放在书架上的书有序的排列，那么我们下次想要找到所需要的书的时候就会更加的简单。 不过如何将上面分类的思路运用到数据结构上面来呢？也就是说我们应该用什么样的标准来将数据进行分类呢？ 现在我们假设用一个长度为8的数组，需要将数据有顺序的放入这八个数组中。要用什么样的标准呢？上面我们提高了一个非常重要的点——歌曲名和歌手是一一对应的，我们知道了歌曲名那么就可以知道歌手。如果不是一一对应的，我们到底该去哪一个文件夹中去寻找呢？不过数据应该和什么类型的东西对应呢？很容易想到——整型。如果一个数据可以和一个整型相对应。也就是通过一个方法可以将一个类变成一串整型数据，那就搞定了。这个方法正是我们之前说过的hashCode方法。假如说对象A对应的整型是17。我们可以通过最简单的取模的算法（HashSet中肯定不是这么简单）将这个对象A放入数组的一号位。如果遇到了对象B对应的整型是20，但是二号位中没有数据，那么就直接落座。不过又来了个对象C对应的整型是9，它也应该放在一号位上，但是一号位已经是有A对象了的。那么该怎么办呢？这时候就需要比较一下他们对应的整型了。发现一个是17，另一个是9，不相等。那么C就直接挂在A的后面？通过什么方式？？当然是通过链表的方式啦。现在假如又来了个对象D对应的整型也是17。A和D对应的整型是相等的，但是他们自身不想等。这是不矛盾的。产生整型的算法只需要是函数那样，一个x又一个对应的y，但是一个y可能有好几个对应的x。此时和A比较发现对应的整型相等，此时还需要调用equals方法，如果这个方法还是返回true，那么就将D丢掉。如果是false，那么D就开始和链表中的下一个C进行比较。 通过上面的方式，我们实际上就构建出来一个哈希表，也就是经常说的散列。这个哈希表的样子是，一个数组中每一个元素都是一个链表，可以说这个结构是我们之前学的数组和链表的结合体。至于为什么叫散列，其实也是比较直观的，每一列都是不相连的。 使用散列的时候，每次我们想要插入一个数据的时候，首先是通过散列函数计算出他对应的整型，然后通过特定的算法计算出他所在的列。然后通过上满详细说的那种方式，选择插入还是放弃该数据。效率是提高了，但是使用的空间也更多了。 再次需要注意的是，如果两个对象的时候，也就是equals返回false的时候，hashCode方法返回的值必须都要是相等的。但是hashCode相等的时候，两个对象不一定是相等的。至于上面的规则是谁来实现的？那当然不是Java编译器来替我们时间，我们需要重写equals和hashCode方法来保证实现。之前说过的equals ==的时候也讲过了这个东西。 HashSet、HashMap其实，HashSet这个东西也是非常的少用的。我们这里主要说的还是HashMap，如果HashMap懂了，那么HashSet自然也就懂了。至于为什么呢？请看下面的代码。 /** * Constructs a new, empty set; the backing {@code HashMap} instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() { map = new HashMap&lt;&gt;(); } 可以看到HashSet里面使用就是一个HashMap来实现的，那么我们就直接看一下HashMap就行了。 HashMap的声明public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable public abstract class AbstractMap&lt;K,V&gt; extends Object implements Map&lt;K,V&gt; 上面的Cloneable和Serializable这两个接口，我们之前都是已经说过了的。至于父类AbstractMap这个类都是没有那么重要的，这个类只是提供了Map接口的骨架实现，以尽量减少实现此接口所需的工作量。 那么最重要的就是Map&lt;K, V&gt;这个接口。 void clear() 从该地图中删除所有的映射（可选操作）。 boolean containsKey(Object key) 如果此映射包含指定键的映射，则返回 true 。 boolean containsValue(Object value) 如果此地图将一个或多个键映射到指定的值，则返回 true 。 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回此地图中包含的映射的Set视图。 boolean equals(Object o) 将指定的对象与此映射进行比较以获得相等性。 V get(Object key) 返回到指定键所映射的值，或 null如果此映射包含该键的映射。 int hashCode() 返回此地图的哈希码值。 boolean isEmpty() 如果此地图不包含键值映射，则返回 true 。 Set&lt;K&gt; keySet() 返回此地图中包含的键的Set视图。 V put(K key, V value) 将指定的值与该映射中的指定键相关联（可选操作）。 void putAll(Map&lt;? extends K,? extends V&gt; m) 将指定地图的所有映射复制到此映射（可选操作）。 V remove(Object key) 如果存在（从可选的操作），从该地图中删除一个键的映射。 int size() 返回此地图中键值映射的数量。 Collection&lt;V&gt; values() 返回此地图中包含的值的Collection视图。 上面是Map中的抽象方法。其中Map中还有一个接口Entry，这是一个重要的接口。 boolean equals(Object o) 将指定的对象与此条目进行比较以获得相等性。 K getKey() 返回与此条目相对应的键。 V getValue() 返回与此条目相对应的值。 int hashCode() 返回此映射条目的哈希码值。 V setValue(V value) 用指定的值替换与该条目相对应的值（可选操作）。 其中，我们使用entrySet可以返回Map中的键值对，返回的是Set&lt;Map.Entry&lt;K, V&gt;类型。可以使用getKey，getValue方法获取键值对。 总结上面是对Hash做了一个初步的了解，下面就开始稍微看一下HashMap的源码吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2F2019%2F10%2F14%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList前言上面我们说完了Java中最重要的一个类——String，现在我们要说的同样是一个非常重要的类，也是最常用的一个集合ArrayList。现在我们就来简单的学习一下这个类的使用方式，然后简单的看一下这个类的源码。 ArrayList漫谈ArrayList声明先来看看ArrayList的声明。 public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; public interface List&lt;E&gt; extends Collection&lt;E&gt; 上面是ArrayList的声明，和与其有关的类或者接口的一些声明。现在就简单的介绍一下就完事了。 List&lt;E&gt;，Collection&lt;E&gt;：是两个基本的接口。其中Collection是Java中存储单列数据集合的接口，而List是存储有序的单列数据的集合，无序的接口是Set。使用双列数据也就是键值对的形式的接口是Map，其中Map和Collection是并列的。 RandomAccess是一个标记接口，表示这个集合是支持随机访问的，因为ArrayList的底层是使用数组来实现的，而LinkedList的底层是使用链表来实现的，不可以使用RandomAccess接口。 上面既然说了RandomAccess是一个标记接口，就代表这个接口是没有方法需要实现的。此接口的主要目的是允许通用算法改变其行为，以便在应用于随机访问列表或顺序访问列表时提供更好的性能。而Serializable也是我们常见的标记接口。 Cloneable其实也是一个标记接口，因为这个接口中其实没有方法需要实现的。这个接口代表这个类可以通过clone方法进行克隆。但是这个接口可以说又不是一个标记接口，因为实现这个接口我们都需要重写Object中的clone方法。我们来看一下Object中的clone方法。 @HotSpotIntrinsicCandidate protected native Object clone() throws CloneNotSupportedException; 注释HotSpotIntrinsicCandidate代表着该方法在HotSpot中有更加高效的实现，该高效的实现是基于CPU指令的。native关键词代表着这个方法不是使用Java代码实现的，据悉Java中大多数的native方法都是使用C++来实现的。native方法是没有方法体的。 另外需要注意的是这个方法是一个protected方法，外界是无法调用的。所以说我们实现了Cloneable接口之后还是要重写这个方法，将这个方法变成public的方法。 @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } 如何没有使用Cloneable接口，但是重写了clone方法并调用，会抛出java.lang.CloneNotSupportedException异常。还有一点需要注意的是，默认的clone是浅拷贝，对于引用类型的拷贝需要当心了！ Iterator接口是有迭代器接口，需要实现iterator方法返回一个迭代器。而一个迭代器又是实现了iterable接口，其中有迭代器的基本的next，hasNext，remove方法需要实现。 上面基本上就是对ArrayList声明的一些说明了。 ArrayLIst源码ArrayList的源码也是有几千行，但是这个看起来要比String类的源码舒服多了，没用那么多完全看不懂的地方了。我们还是从构造函数看起。 /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } 注释告诉我们他是创建了一个初始容量为10的一个数组。但是看起来没有那么简单。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 这个明明是一个没有长度的数组，我寻思你这个注释不是骗我的嘛。不过我们添加元素的时候ArrayList是如何做的呢？ public boolean add(E e) { modCount++; add(e, elementData, size); return true; } private void add(E e, Object[] elementData, int s) { if (s == elementData.length) elementData = grow(); elementData[s] = e; size = s + 1; } private Object[] grow() { return grow(size + 1); } private Object[] grow(int minCapacity) { return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); } private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt;= 0) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; } return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); } 上面是我们添加元素的时候的调用add所执行的函数。一开始elementData.length是为0的。然后调用了grow(1)开始扩容。关键是看一下函数newCapacity，第二十八行，二十九行的代码，DEFAULT_CAPACITY是10，通过上面的方式会创建一个长度为10的数组。看来ArrayList采取的是懒加载的形式，只有调用了add方法的时候才会去创建数组。不过如果是使用带参数的构造器的话，就不会懒加载。 public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); } } 其实上面的懒加载也是从JDK8之后改动的。JDK7及之前都不是懒加载，我们可以看一下Vector的源码。 public Vector(int initialCapacity) { this(initialCapacity, 0); } /** * Constructs an empty vector so that its internal data array * has size {@code 10} and its standard capacity increment is * zero. */ public Vector() { this(10); } 之所以改动的时候没有修改Vector的源码，是因为Vector在Java中是真的没有人使用了，所以写JDK的人不改进他的源码也是很正常的。想我vector在c++中那么牛逼，没想到在Java中竟然沦落到如此的底部，呜呼，哀哉！！ 再看一下那个newCapacity函数，感觉这个函数名字非常的熟悉。因为好像我们昨天看StringBuilder的源码，观察StringBuilder底层的数组的扩容的时候也看到了这个函数。不过StringBuilder的默认大小是16，扩容的规则是两倍加上二，但是ArrayList的默认的大小是10，扩容的规则是变成原来的1.5倍。Vector是变成原来的2倍。 我们发现出去对数组的基本的操作的API之外，ArrayList中竟然还常有三个内部类。他们分别是 private class Itr implements Iterator&lt;E&gt; final class ListItr extends Itr implements ListIterator&lt;E&gt; final class VectorSpliterator implements Spliterator&lt;E&gt; 看来这个三个都是迭代器，这里就不深入的了解了。ArrayList中也有获取这些迭代器对象的对应的方法。 public synchronized Iterator&lt;E&gt; iterator() { return new Itr(); } public synchronized ListIterator&lt;E&gt; listIterator() { return new ListItr(0); } public synchronized ListIterator&lt;E&gt; listIterator(int index) { if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); } @Override public Spliterator&lt;E&gt; spliterator() { return new VectorSpliterator(null, 0, -1, 0); } remove 方法ArrayList中有如下的两个方法。 public E remove(int index) public boolean remove(Object o) 这两个方法是不是有点不好呢？比如说如下的情况下。 public static void main(String[] args) throws CloneNotSupportedException { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.remove(1); System.out.println(list); } 那么到底是输出的是2 3还是1 3呢？也就是调用的是哪个函数呢？或许会有点儿疑惑，但是毫无疑问会调用remove(int index)这个函数，虽然int会执行装箱的操作，但是如果存在不用装箱就可以调用的函数，那他为何还需要装箱呢？如果我们真的是需要调用remove(Object o)的话，我们需要这样子写list.remove(Integer.valueOf(1));。 遍历ArrayListpublic static void main(String[] args) throws CloneNotSupportedException { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 其实如果要使用这种方式的话，还不如使用增强for循环来实现呢。 使用这个迭代器也是可以的，两个迭代器比起来只是listIterator的方法更多一点而已。可以添加也可以前后的移动。 public static void main(String[] args) throws CloneNotSupportedException { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); ListIterator&lt;Integer&gt; integerListIterator = list.listIterator(); while (integerListIterator.hasNext()) { System.out.println(integerListIterator.next()); } for (int val : list) { System.out.println(val); } list.forEach(System.out::println); list.stream().forEach(System.out::println); } 同样的后面也有两种不是很常用的遍历方式。 ArrayList的拷贝思来想去说一说关于拷贝的问题的。其实也就是拷贝是浅拷贝韩式深拷贝的问题。clone是浅拷贝，Collections.copy也是浅拷贝。然后普通数组的拷贝方法System.arraycopy和Arrays.copyOf也都是浅拷贝。 其中Collections.copy的使用如下所示 public static void main(String[] args) throws CloneNotSupportedException { List&lt;CA&gt; list = new ArrayList&lt;&gt;(); list.add(new CA(&quot;sher&quot;)); list.add(new CA(&quot;hony&quot;)); list.add(new CA(&quot;honysher&quot;)); List&lt;CA&gt; temp = Arrays.asList(new CA[list.size()]); Collections.copy(temp, list); System.out.println(temp.get(0).name == list.get(0).name); } 使用方式，说实话蛮沙雕的。而剩下的两个函数我写一下声明就行了。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); public static int[] copyOf(int[] original, int newLength) 其实这个copyOf也是用arraycopy来实现的。 public static int[] copyOf(int[] original, int newLength) { int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 上面我们提到的所有的拷贝都是浅拷贝，那么该如何实现深拷贝呢？所谓的深拷贝就是递归的拷贝，遇到引用就要直接拷贝他的源头而不是拷贝引用。我记得之前说IO的时候说过一个东西叫序列化。也就是DataInput/OuputStream这个玩意。我们序列化的时候会保存所有的引用的源头，以便于后面我们读取的时候可以恢复到之前的一模一样的状态。如果只是保存引用，那就直接GG了。我们似乎可以通过序列化的方式进行深拷贝。 public static void main(String[] args) { List&lt;CA&gt; list = new ArrayList&lt;&gt;(); list.add(new CA(&quot;sher&quot;)); list.add(new CA(&quot;hony&quot;)); list.add(new CA(&quot;honysher&quot;)); ObjectOutputStream oos = null; ObjectInputStream ois = null; List&lt;CA&gt; temp = null; try { ByteArrayOutputStream baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(list); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ois = new ObjectInputStream(bais); temp = (List&lt;CA&gt;) ois.readObject(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } finally { if (oos != null) { try { oos.close(); } catch (IOException e) { e.printStackTrace(); } } if (ois != null) { try { ois.close(); } catch (IOException e) { e.printStackTrace(); } } } System.out.println(temp.get(1).name); System.out.println(list.get(1).name); System.out.println(temp.get(1).name == list.get(1).name); } 通过上面的方式我就完成了对ArrayList的深拷贝，但是前提是ArrayList中数据的类型的类必须要实现java.io.Serializable接口，不然程序是会报错的。 不过这个序列化来进行深拷贝的方式效率是比较低的，但是也没办法，似乎也没有什么其他的方法。 但是对于一种特殊的情况还有一种简单的方式。利用JSON字符串的性质。不过也有一个限制，那就是对象的所有的成员都要是基本的数据类型，或者是String也可以的。 这里使用到了阿里巴巴的FastJSON的jar包，不是用的Java原生的类库。 @Test public void test() { CA sher = new CA(&quot;sher&quot;); String str = JSON.toJSONString(sher); CA temp = JSON.parseObject(str, CA.class); System.out.println(temp.name); System.out.println(sher.name); System.out.println(sher.name == temp.name); } 如果是ArrayList那是没办法使用这个方法的。 @Test public void test2() { List&lt;CA&gt; list = new ArrayList&lt;&gt;(); list.add(new CA(&quot;sher&quot;)); list.add(new CA(&quot;hony&quot;)); list.add(new CA(&quot;honysher&quot;)); String str = JSON.toJSONString(list); List&lt;CA&gt; temp = JSON.parseObject(str, List.class); // System.out.println(temp.get(1).name); // System.out.println(list.get(1).name); // System.out.println(temp.get(1).name == list.get(1).name); } ArrayLIst与Vector之前也说过了ArrayList和Vector是相似的，不过一个是线程不安全，一个是线程安全的。那么是不是如果考虑到线程安全的情况下我们就要使用Vector呢？当然不是，Vector这么垃圾，其实也没有人去使用他。我们可以这样把ArrayList变成一个线程安全的容器。 @Test public void test3() { List&lt;CA&gt; list = new ArrayList&lt;&gt;(); list.add(new CA(&quot;sher&quot;)); list.add(new CA(&quot;hony&quot;)); list.add(new CA(&quot;honysher&quot;)); List&lt;CA&gt; cas = Collections.synchronizedList(list); } 此时这个cas就是一个线程安全的容器了。 其实我们可以使用这样的集合java.util.concurrent.CopyOnWriteArrayList，这是专门为了多线程设计的ArrayList的变种。 总结上面就简单的学习了一下ArrayList的使用。看了声明和源码以及一些常用的方法。后面还说到了ArrayList的浅拷贝与深拷贝的问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String, StringBuilder and StringBuffer]]></title>
    <url>%2F2019%2F10%2F13%2FString-StringBuilder-and-StringBuffer%2F</url>
    <content type="text"><![CDATA[String, StringBuilder and StringBuffer前言String类可谓是我们最常用的一个类了，但是对于这个类我们是否是真的了解呢？之前我们早就已经说过了String对象是一个不可变的对象，在说到基本数据类型的包装类的时候，我们也提高了String的常量池。虽然关于String，我们已经讲了不少，但是都是太过于零散，这里我准备看看String类型的源码是如何的。 String漫谈String的声明首先看一下String的声明是如何的。 public final class String extends Object implements Serializable, Comparable&lt;String&gt;, CharSequence String类是final的，也就是我们是无法去继承String类的。 Serializable是一个标记接口，代表String对象是可以序列化的。 Comparable&lt;String&gt;是比较器。String类实现了自然排序，所以很多排序的操作时，我们并不需要指定一个比较器给String。(String的排序是按照字典顺序的，源码太复杂了，这里就不贴出来了) CharSequence其实就是字符串的意思，其中只是提供了可以作为字符的基本方法。如 char charAt(int index)，我们或许String对象的第几位的字符的时候不可以使用[]。比如说下面的代码示例。 String a = &quot;abc&quot;; char b = a[1]; // Worng char b = a.charAt(1); // Right int length()。既然是字符串，那肯定是有长度的。 CharSequence subSequence(int start, int end)。这个方法倒是有点儿想String类中的subString方法有点儿类似了。 String toString()。这个方法其实每一个类都是有的，但是CharSequence接口将这个方法设置为抽象方法，这也是理所应当的，作为一个字符串toString的时候肯定是要输出点内容的。因为toString方法默认输出的是 getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()) 上面就是对String类的声明做了一个简单的了解。现在就让我们看看String的源码，看看为啥这个东西是不可变对象。要看一个类首先是从这个类的构造器开始看起。不过String的构造器实在是太多了，我们就从官方文档中的说明开始看起。 String的源码String str = &quot;abc&quot;; 相当于 char data[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; String str = new String(data); 文档中说这是一样的，但是依据我们之前所学的知识，这个是完全不一样的。上面的str在Java的常量池中，而下面的str是在堆中的。 不过我们要来看一看String类是如何通过char[]创建String对象的。 public String(char value[]) { this(value, 0, value.length, null); } String(char[] value, int off, int len, Void sig) { if (len == 0) { this.value = &quot;&quot;.value; this.coder = &quot;&quot;.coder; return; } if (COMPACT_STRINGS) { byte[] val = StringUTF16.compress(value, off, len); if (val != null) { this.value = val; this.coder = LATIN1; return; } } this.coder = UTF16; this.value = StringUTF16.toBytes(value, off, len); } 上面的第四个参数应该是一个返回值没有被用到的，但是又必须在函数的参数列表中存在的一个东西。因为我稍微看了一下源码，第三个参数基本上都是null。初始化中使用到了两个字段value和coder。这个coder明显是一个编码的措施，那么这个value应该就是String内部用来存储数据的东西。 @Stable private final byte[] value; private final byte coder; // LATIN1 or UTF16 其实我们可以取消对coder的关注了。只用看value。他的声明是private final byte[]。 第一点，String的内部不是使用char[]来储存的。因为之前观察C++的string的源码，其实就是维护了一个char*。一个字符串使用byte[]作为底层，这真的很意外。我使用的jdk版本为jdk12，或许是我的jdk版本太高了，因为我之前在网上查阅资料的使用我看源码还是private final char[] value呢。为什么会变成byte[]呢？根据我查阅的资料，这个改变是从jdk9开始的，目的是为了节省字符串的内存占用从而优化性能。 第二点，value被声明为是final的，而且还加上了注解@Stable，这说明了这个数组是稳定的不可变的，这也就解释了为什么String是一个不可变的对象。 这样我们基本上也就了解了String对象是如何存储的，以及为什么是一个不可变的对象。String类的原码有几千行，这并不是我们都需要看的，这里我们其实源码看的已经够了。 但是对于下面的代码，我确是有一个疑问。 String str = new String(&quot;abc&quot;); 这个到底是调用什么构造器呢？按道理来说应该是String(String str) @HotSpotIntrinsicCandidate public String(String original) { this.value = original.value; this.coder = original.coder; this.hash = original.hash; } 那么仅仅是一个“abc”就可以作为是一个String吗？那么这个abc又是调用的什么构造器呢？这看起来是一个无限循环的问题。不过需要注意的是单独的“abc”还真的是可以作为String来使用的。 System.out.println(&quot;hello world&quot;.toUpperCase()); 就比如说这行代码是没有任何问题的。其实上面是有String对象的产生的，只不过是编译器给你生成的，就像我们之前说的内部类那一块一样。 String str = &quot;hello world&quot;; System.out.println(str.toUpperCase()); 其实是上面这样子的，hello world这个对象是位于常量池中的。后面的str.toUpperCase()产生了一个新的String对象，不过这个String对象是位于堆中的。也就是说，如果我们使用如下的代码的时候。 String str = new String(&quot;abc&quot;); String xx = &quot;abc&quot;; String str = new String(xx); 会生成两个String对象，一个位于常量池中，一个位于堆中。至于常量池中的String是如何创建的，这就不是我们可以通过阅读源码就可以解决的问题了。 String相加众所周知，C++是一门支持云算法重载的牛逼的语言，但是Java中是不支持运算符的重载的。不过有一个东西是非常的例外的，就是Strnig中的重载了+与+=。至于如何实现的这个肯定是没办法从源码处得知的了。 String str = &quot;a&quot; + &quot;b&quot;; 按道理来说，我们知道String是一个不可变的对象。所以说应该是创建了两个String然后连接起来。但是真的如此吗？其实不是的，JVM可是非常聪明的，他会只创建一个ab字符串，然后直接把地址赋给str。 String a = &quot;a&quot;; String str = &quot;1&quot; + a + &quot;2&quot;; 看一下上面的代码，那么以我们聪明的JVM来说，也应该是直接创建1a2。不过，可能JVM要让你失望了。普遍的说法是会生成字符串1a，1a2。如果+的时候，存在已经定义过的变量，那么JVM就不会直接搞天神下凡似的直接创建目标字符串。而是一个一个创建。但是我上网查阅了资料，发现懂汇编的大佬使用javap -c反编译字节码文件的时候，发现实际上JVM是创建一个StringBuilder，然后使用append方法来连接字符串。 String str = &quot;&quot;; for(int i = 0; i &lt; num; i++) { str += &quot;a&quot;; } 如果我们使用的是这样子的话，那就很恐怖了，每一次循环都会生成一个StringBuilder对象来连接字符串，效率是非常的低下。此时我们应该使用如下的方式。 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; num; i++) { sb.append(&quot;a&quot;) } 这样的话，就只会产生一个StringBuilder对象了。 上面是看了其他的对字节码的反编译才知道其实JVM连接字符串的使用都是使用创建StringBuilder对象然后使用append方法的形式进行连接的。其实String类中也有一个方法用于字符串的连接，不过这个方法是不涉及到StringBuilder的，其实我一开始以为+就是使用concat方法的，没想到是使用StringBuilder。 public String concat(String str) { if (str.isEmpty()) { return this; } if (coder() == str.coder()) { byte[] val = this.value; byte[] oval = str.value; int len = val.length + oval.length; byte[] buf = Arrays.copyOf(val, len); System.arraycopy(oval, 0, buf, val.length, oval.length); return new String(buf, coder); } int len = length(); int olen = str.length(); byte[] buf = StringUTF16.newBytesFor(len + olen); getBytes(buf, 0, UTF16); str.getBytes(buf, len, UTF16); return new String(buf, UTF16); } StringBuilder与StringBuffer前面谈及String相加的时候，提到了StringBuilder。其实通过名字也可以知道，StringBuilder使用构建String的，其底层的存储字符串的数组应该是可变的。 public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, Comparable&lt;StringBuilder&gt;, CharSequence 这个声明是jdk11中的声明，多出了一个继承的类？？？jdk8中是直接继承Object的。看来是我太落后了，不过也没关系，我们直接看一下AbstractStringBuilder。 abstract class AbstractStringBuilder implements Appendable, CharSequence 其中用来储存数据的数组的声明为 byte[] value; 不是final的，说明其是可变的。我们使用这个类主要就是使用append方法。那么我们就来简单的看一下append方法。StringBuilder中的append方法，其实是使用的AbstractStringBuilder中的append方法。这个方法是对Appendable接口的一个实现。 @Override public AbstractStringBuilder append(char c) { ensureCapacityInternal(count + 1); if (isLatin1() &amp;&amp; StringLatin1.canEncode(c)) { value[count++] = (byte)c; } else { if (isLatin1()) { inflate(); } StringUTF16.putCharSB(value, count++, c); } return this; } 这里是添加一个字符，看第三行，是确保value数组中是否可以放下这一个字符。 private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code int oldCapacity = value.length &gt;&gt; coder; if (minimumCapacity - oldCapacity &gt; 0) { value = Arrays.copyOf(value, newCapacity(minimumCapacity) &lt;&lt; coder); } } private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = value.length &gt;&gt; coder; int newCapacity = (oldCapacity &lt;&lt; 1) + 2; if (newCapacity - minCapacity &lt; 0) { newCapacity = minCapacity; } int SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder; return (newCapacity &lt;= 0 || SAFE_BOUND - newCapacity &lt; 0) ? hugeCapacity(minCapacity) : newCapacity; } 可见，如果容量够那就直接放入那个字符。如果是没有足够的容量的时候，value数组会进行扩容。扩容的规则就在上面的newCapacity函数中，一般是二倍加上二，如果还不够大的话就变成minCapacity(也就是加上之后的长度)。但是数组的长度是有限制的，最大也不能超过那个值。 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 不过，这个值，，，也是非常大了！！ 再来看一下StringBuilder的构造函数。 @HotSpotIntrinsicCandidate public StringBuilder() { super(16); } @HotSpotIntrinsicCandidate public StringBuilder(int capacity) { super(capacity); } @HotSpotIntrinsicCandidate public StringBuilder(String str) { super(str.length() + 16); append(str); } 可见，如果无参的话，默认的存储数组的大小是16。如果给定了一个String作为参数，那么默认的存储数组的大小就是str.length()+16。看来jdk的编写者是非常喜欢16这个数字的。 上面对StringBuilder的讲解基本上就结束了，至于StringBuffer，我感觉是不需要讲的。其实这个StringBuffer是和StringBuilder是一样的，不过StringBuilder是线程不安全的，但是StringBuffer是线程安全的。StringBuffer很多的方法都加上了synchronized用来同步。这个就有点像ArrayList与Vector和HashMap与Hashtable。都是一个是线程不安全，一个是线程安全。(其实不一样的地方还是非常多的！) 总结上面就通过源码简单的学习了一下Java当中的String，StringBuilder以及StringBuffer的使用。不过基本上还是蛮简单的看源码的，没有很复杂的地方。还有就是关于String对象的常量池机制和什么==什么东西的，之前都是讲过的，这里就不再提及了。 参考文章Java 深究字符串String类(1)之运算符”+”重载 OpenJDK源码阅读解析：Java11的String类源码分析详解]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-06]]></title>
    <url>%2F2019%2F10%2F13%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-06%2F</url>
    <content type="text"><![CDATA[Java中的多线程-06前言之前我们已经说完了线程的创建的两种方式，线程的三种同步措施，发生了死锁应该如何应对以及线程之间的通信。基本上多线程中的基本知识都已经提及到了。这里我们讲到谈及的是JDK5之后新增的创建线程的方式，以及线程池的基本知识。前面我们也提到了JDK5中新增加的一个锁——ReentrantLock，可以手动的加锁和释放锁，减少了JVM的调度，提高了效率。 Callable接口实现Callable接口也可以创建线程，这是JDK5中新增加的。不过我们已经有了一个实现多线程的接口Runnable，那么这两个接口有什么不同的地方呢？看一下官方文档对这个接口的说明。 @FunctionalInterface public interface Callable&lt;V&gt; 返回结果并可能引发异常的任务。实现者定义一个没有参数的单一方法，称为call 。 Callable接口类似于Runnable ，因为它们都是为其实例可能由另一个线程执行的类设计的。 然而， Runnable不返回结果，也不能抛出被检查的异常。 该Executors类包含的实用方法，从其他普通形式转换为Callable类。 V call() // 计算一个结果，如果不能这样做，就会抛出一个异常。 之前我们说过Runnable中的run方法是void run()，没有返回值并且不可以抛出异常。所以说我们实现这个方法的时候，也不可以用返回值，也不可以抛出异常。(子类重写父类的函数不给抛出范围更大的异常) 相比与Runnable来说，Callable的更能更加的强大。 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 那么这个FutureTask又是个什么鬼？ FutureTase实现了两个接口，一个是Future接口，一个是Callable接口，其中Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。 public class Demo9 { public static void main(String[] args) { Task task = new Task(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task); Thread thread = new Thread(futureTask); thread.start(); System.out.println(&quot;Main Thread&quot;); try { System.out.println(futureTask.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } System.out.println(&quot;Main End&quot;); } } class Task implements Callable&lt;Integer&gt; { @Override public Integer call() throws InterruptedException { int i = 1; int sum = 0; Thread.sleep(5000); while (i &lt;= 100) { sum += i++; } return sum; } } 上面就是这个类的具体的用法，其实背后的原理是非常的复杂的，但是这里我就只是做一个简单的了解。不可能深入的探究到底这个FutureTast做了什么事情。 可以看到使用实现Callable接口创建多线程的时候，首先我们需要创建Callable的实现对象。然后将其丢入FutureTask的构造函数之中，从而得到了一个FutureTask对象。然后还是像使用Runnable接口一样，将其放入到Thread类中，使用start方法进行执行。最后使用futureTask.get()方法可以取得线程计算的结果。不过主线程在进入到futureTask.get()的时候，如果我们创建的线程还没有计算结束，主线程会进入阻塞状态，直到等到线程计算的结果出来得到返回值。当然也可以通过get方法的参数设置等待的最长的时间是多少。 还有方法比较的常用。比如说cancel方法可以取消执行此任务。isDone方法可以返回是否任务已完成。这里就不多加演示了。 使用线程池上面说到了可以使用Callable加上FutureTask异步的获取线程的返回值。这里我们需要说的是另外的一个创建线程的方式，也是最常用的方式——使用线程池。 经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完 放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。 使用线程池有以下的好处。 提高了相应的速度（减少了新建线程的时间） 降低了资源的消耗（重复利用线程池中的线程，不需要每次都创建） 便于线程的管理。 corePoolSize:核心池的大小 maximumPoolSize:最大的线程数。 keepAliveTime:线程没有任务时最多保存多长的时间会终止。 那么我们该如何新建一个线程池呢？JDK5中直接给我们提供了现成的API——ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)：执行任务，有返回值，一般用来执行 Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n); 创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor() ：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运 行命令或者定期地执行。 比如说之前写的那个生产者和消费者的模式就可以使用线程池来创建线程。 public class Demo10 { public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); Clerk clerk = new Clerk(); executorService.execute(new Productor(clerk)); executorService.execute(new Productor(clerk)); executorService.execute(new Consumer(clerk)); executorService.execute(new Consumer(clerk)); executorService.execute(new Consumer(clerk)); executorService.shutdown(); } } 使用线程池将会更加的简洁明了，而且效率只会更加的高。 上面只是使用线程池执行Runnable，也可以使用线程池执行Callable。比如上上面写的那个Callable的例子就可以这么写。 @Test public void test() { ExecutorService executorService = Executors.newCachedThreadPool(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Task()); executorService.submit(task); try { System.out.println(task.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } 其实都是相似的，线程池的内部也是使用Thread的，所谓的线程池就是对多个Thread进行封装罢了。除了上面的代码可行之外，我发现不使用FutureTask好像也是可行的。 @Test public void test() { ExecutorService executorService = Executors.newCachedThreadPool(); // Future&lt;Integer&gt; submit = executorService.submit(new Task()); // FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(new Task()); Future&lt;Integer&gt; submit = executorService.submit(new Task()); try { System.out.println(submit.get()); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } 使用submit的方法的返回值就行了。如果是第一种方式，也就是把futrueTask传递个submit的参数的话，返回值类型是Future&lt;?&gt;，下面调用submit.get()是null值。可见如果使用futureTask作为参数的话就只能使用futureTask来获取线程的执行的结果，如果只是我们写的Callable的话，使用submit方法的返回值就行了。 总结上面的知识其实是非常复杂的，不过说过了，我们只是简单的了解一下，懂基本的使用方式就行了，所以很多细节我们都没哟深究，也没有参考什么很多别人写的很深入的文章和资料。其实多线程的基本知识的学习，到此基本上就结束了。下面准备搞一下Java中的集合的使用，比如看看源码还是其他什么的，不可能是死板的学习API的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-05]]></title>
    <url>%2F2019%2F10%2F12%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-05%2F</url>
    <content type="text"><![CDATA[Java中的多线程-05前言本来是想接着上面的那个写的，不过想到每次都写的非常的长也是没什么道理可言的。这次就多拆分一下下。 线程间的通信前面我们已经说了不少的多线程了，但是多个线程之间到底是如何通信呢？这个问题我们之前就提出来了。我们使用多个线程都拥有的实例变量，并且使用了线程同步的机制，使得我们可以使用多个线程一起输出0~100。这算是线程通信的一个方面。但是如果我们需要的是要两个线程一个一个输出该如何做呢？有人说那好办，我让一个线程输出玩之后使用yield方法，放弃他的资源，让另一个线程进入。如此下去不就可以实现多线程轮流输出了嘛。但是我们很明白的是，yield方法虽然会放弃当前线程的资源，但是这并不意味这另一个线程就会抢到执行的机会。放弃资源的线程还是有机会抢到线程的，所以说这个方式是错误的。 至于如何实现这个功能，就需要新的方法。那就是我们之前说过的方法。wait()与notify()方法。 下面是有关的方法的说明。 wait()： // 令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源， // 而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒， // 唤醒后等待重新获得对监视器的所有 权后才能继续执行 notify()： // 唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll()： // 唤醒正在排队等待资源的所有线程结束等待. 注意： 注意上面的方法都提到了同步资源这个事。因为这几个方法只有在同步代码块或者说值同步方法中才可以调用。如果不在其中的话，会抛出java.lang.IllegalMonitorStateException。 和yield，sleep方法不同的是，上面的三个方法是由同步监视器来调用的。而同步监视器可以是任何的对象。这就说明了上面的三个方法肯定是Object中声明的方法。 那么我们回到之前的问题中，如何让两个线程一个接着一个的输出0-100中的所有的数。 class WaitThread implements Runnable{ private int i = 1; private final Object mObject = new Object(); @Override public void run() { while (true) { synchronized (mObject) { mObject.notify(); if (i &lt;= 100) { System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i); ++i; } else { break; } try { mObject.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } } 这里我们没有使用this作为同步监视器，就是为了更好的说明wait和notify的方法是由同步监视器来调用的。如果是把this作为同步监视器的话，那么我们只需要使用wait()和notify()，可以省略了调用的对象this。 首先线程一进入了同步代码块，第九行使用了mObject.notify()唤醒一个因为wait()而进入阻塞状态的线程。但是此时没有线程因为wait进入阻塞状态，所以此时改行代码是无效的。等到输出了1之后，使用了mObject.wait()方法，该线程进入了阻塞状态。注意这个阻塞状态是sleep的阻塞状态是不一样的，此时线程会暂停，但是线程还是会释放同步监视器。因为线程一释放了同步监视器，线程二得到了同步监视器，进入了同步代码块。此时执行了mObject.notify()，刚才因为使用了wait()方法而进入阻塞状态的线程一被唤醒。但是唤醒之后是不会立马执行的。线程一会等在原地等待得到了锁。等到线程二也执行到了mObject.wait()方法，线程二暂停，线程一得到了锁，继续执行之后的代码。然后重复操作。 通过上面的操作就可以实现交互输出的功能。不过有一点需要注意的是，使用wait方法之后，线程虽然释放了锁，但是线程还是处于同步代码块中。 上面我们已经说明了wait和notify方法的使用。还有一个notifyAll方法我们还没有进行说明。其实和名字也是可以简单的的看出了的。notify是从因wait阻塞中的线程中随机取一个唤醒。上面的问题中其实只有一个线程，所以说唤醒的肯定是唤醒另一个线程。notifyAll方法是将所以的因为wait方法而进入阻塞状态的所有的线程。不过需要注意的是，所谓的唤醒并不是直接就执行了，而是进入抢夺锁的线程池中抢夺锁，抢到了锁之后从之前因为wait阻塞的断点处继续执行。 生产者与消费者 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品 上面是多线程中的一个经典的例题。这个问题中会出现一下的两个问题。 生产者比消费者快时，消费者会漏掉一些数据没有取到。 消费者比生产者快时，消费者会取相同的数据 如何解决这个问题，我们就需要使用上面学的线程通信的知识来解决。 首先是雇员的实现，雇员有从生产者中那儿取得产品，像消费者送产品的职责。 class Clerk { private int product = 0; public synchronized void addProductor() { if (product &gt;= 20) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { product++; System.out.println(&quot;ADD---&gt;product = &quot; + product); notifyAll(); } } public synchronized void getProductor() { if (this.product &lt;= 0) { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else { System.out.println(&quot;GET---&gt;product = &quot; + product); product--; notifyAll(); } } } 添加产品和取得产品的方法中都是相似的。里面都有wait方法和notifyAll方法。当生产的产品达到20件的时候，生产者的线程将会被阻塞，但是当产品小于20的时候，会调用notifyAll方法唤醒之前沉睡的生产者线程，不过为什么是notifyAll呢？那是因为生产者可能是不止一个的。消费者也是同样的道理。通过这种方式我们就解决了上面我们提出的问题。 class Productor implements Runnable { private Clerk mClerk; public Productor(Clerk clerk) { this.mClerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(new Random().nextInt(100)); } catch (InterruptedException e) { e.printStackTrace(); } mClerk.addProductor(); } } } class Consumer implements Runnable { private Clerk mClerk; public Consumer(Clerk clerk) { this.mClerk = clerk; } @Override public void run() { while (true) { try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } this.mClerk.getProductor(); } } } public class Demo8 { public static void main(String[] args) { Clerk clerk = new Clerk(); Thread thread = new Thread(new Productor(clerk)); Thread thread1 = new Thread(new Consumer(clerk)); Thread thread2 = new Thread(new Consumer(clerk)); thread.start(); thread1.start(); thread2.start(); } } 上面的代码中，我并没有设置什么时候停止运行，也就是生产者会一直生产，消费者也会一直消费下去。 一般来书生产者是有一个终止条件的，之前学爬虫的时候也学到了使用多线程的方式进行爬虫。虽然没有谈及线程通信，但是用到了生产者与消费者的模式。其中生产者一直爬取所需要的url，而消费者可以通过url进行下载数据。通过多线程加上这样效率高的模式，爬虫的效率可以提升好几倍。 总结上面就是wait和notify[All]方法的使用，以及使用这两个方法进行简单的线程之间的通信。至此，多线程的学习基本上就要告一段落了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-04]]></title>
    <url>%2F2019%2F10%2F12%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-04%2F</url>
    <content type="text"><![CDATA[Java中的多线程-04前言上面我们说到了线程同步的时候需要注意的事项了。学会了使用三种方式——使用synchronized同步代码块，同步代码方法，以后使用jdk5新增的ReentrantLock的方式，手动为同步代码块加锁和解锁。我们还知道了同步代码块的范围是需要注意的。太大了的话，效率会非常的低。如果范围太小了的话，又不能保证多线程的安全性。最后我们也提到了单例模式中的双重验证的方式，不过没有细讲。这里就先说说这个。 单例模式中的双重验证class Singleton02{ private static volatile Singleton02 INSTANCE; private Singleton02() { } public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } } 这里如果我们使用得是这样的锁. public static Singleton02 getInstance() { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } return INSTANCE; } 这个是绝对可以保证线程安全的。但是后面的线程并不会去修改内容，只是读取内容，所以说后面的线程就没有必要在锁外去等待，这种锁的效率是非常的低的。 public static Singleton02 getInstance() { if (INSTANCE == null) { synchronized (Singleton02.class) { INSTANCE = new Singleton02(); } } return INSTANCE; } 如果使用的是这样的锁，这就是完全错误的，很容易看出来可能有多个线程都进入if中了，从而也就会创建出了多个线程，这就不是所谓的单例模式了。 像上面的这种使用双重验证的方式来增加多线程的效率的方法其实是非常的好用的。 线程死锁线程的同步虽然很好用，但是不能瞎用。随意的嵌套锁可能会导致线程的死锁。所谓的死锁可以用筷子来举例子。两个人需要吃饭，但是只有一双筷子。按道理来说应该是一个一个来吃。但是一个人获取了筷子A，另一个人获取了筷子B。此时他们都在那儿等待另一个放开筷子，从而自己可以得到两个筷子。这种情况下两种线程都会进入阻塞状态。程序将会失去相应，但是此时不会报任何的错误，也不会抛出任何的异常。 比如如下的代码中就会出现死锁的情况。 public class Demo5 { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { new Thread(()-&gt;{ synchronized (lock1) { System.out.println(&quot;thread1 get lock1&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lock2) { System.out.println(&quot;thread1 get lock2&quot;); } } System.out.println(&quot;thread1 end&quot;); }).start(); new Thread(() -&gt;{ synchronized (lock2) { System.out.println(&quot;thread2 get lock2&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (lock1) { System.out.println(&quot;thread2 get lock1&quot;); } } System.out.println(&quot;thread2 end&quot;); }).start(); } } 我使用匿名内部类的形式创建了两个线程，其中还使用了lambda表达式。可以清晰的看到两个线程都存在锁的嵌套的问题。第一个线程是先去获取第一个锁然后获取第二个锁才能做完事情。第二个线程恰好是相反的。当他们都获取一个锁的时候，都想要获取另一个锁，导致了线程的阻塞。这就是多线程中的死锁的问题。死锁问题的原因其实非常的简单就是锁的嵌套。因此在使用的同步的时候我们要尽量不要去使用锁的嵌套。使用锁嵌套进可能会导致死锁问题，而且最为关键的是死锁问题不是每次都能表现出来的。比如说上面的代码中如果我没有使用sleep的话，绝大多数的情况下都是正常运行的。而且基本上都是线程一先结束然后线程二结束。 解决死锁问题的答案很简单就是将嵌套的锁分开。 public class Demo5 { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { new Thread(() -&gt; { synchronized (lock1) { System.out.println(&quot;thread1 get lock1&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } synchronized (lock2) { System.out.println(&quot;thread1 get lock2&quot;); } System.out.println(&quot;thread1 end&quot;); }).start(); new Thread(() -&gt; { synchronized (lock2) { System.out.println(&quot;thread2 get lock2&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } synchronized (lock1) { System.out.println(&quot;thread2 get lock1&quot;); } System.out.println(&quot;thread2 end&quot;); }).start(); } } 不过问题就是在于，我们是否可以清楚的知道我们写的代码是否会出现死锁的问题。比如说如下的代码。 public class Demo6 { public static void main(String[] args) { CA a = new CA(); CB b = new CB(); new Thread(() -&gt; { a.foo(b); }).start(); b.bar(a); } } class CA { public synchronized void foo(CB b) { System.out.println(&quot;CA.foo&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } b.last(); } public synchronized void last() { System.out.println(&quot;CA.last&quot;); } } class CB { public synchronized void bar(CA a) { System.out.println(&quot;CB.bar&quot;); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } a.last(); } public synchronized void last() { System.out.println(&quot;CB.last&quot;); } } 虽然上面的代码写的是没有任何的实际的意义的。但是也是可以说明很多的问题的。我们只是在两个类中使用了几个同步方法，不过却意外的发生了死锁的问题。仔细看一下代码其实很容易的看出。两个嵌套的锁就是两个类的this。虽然我们没有写出synchronized代码块的嵌套。但是两个不同类的同步的方法就已经相当于是同步的嵌套了。然后主方法中有两个线程，一个占用了一个this，这样就会导致线程的死锁。 总结上面主要就是说了一个死锁的问题，其实本来要在后面接着写线程通信之间的问题的。但是感觉线程通信这一块应该有蛮多的东西可以吹的，如果接在这个后面应该会蛮长的，那么就下一个里面再写吧。不过这次写的这个确实有点儿少了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-03]]></title>
    <url>%2F2019%2F10%2F11%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-03%2F</url>
    <content type="text"><![CDATA[Java中的多线程-03前言前面说到了多线程之间同步的问题了。不过使用的例子确实几个线程输出数字，不是非常的形象。这里我们可以将情景改一下，改成火车站几个不同的窗口进行售票。如果不同的窗口售出同一张票或者说售出不存在的票问题就大了。其实代码和之前的还是一样的，只不过多加了一个情景罢了。 买票经过情景的变化，我将代码也进行了修改。 public class Demo3 { public static void main(String[] args) { Client client = new Client(); Thread thread1 = new Thread(client, &quot;售票窗口一&quot;); Thread thread2 = new Thread(client, &quot;售票窗口二&quot;); Thread thread3 = new Thread(client, &quot;售票窗口三&quot;); thread1.start(); thread2.start(); thread3.start(); } } class Client implements Runnable { private int ticket = 100; @Override public void run() { while (ticket &gt; 0) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;: &quot; + ticket); ticket--; } } } 其中上面的Thread.sleep是为了模拟网络的延迟，只一次我将网络的延迟降低了一点点。我们发现有很多的票没有卖出去，还有很多的票卖出去了好多张。关键是有点窗口还卖出去的负数的票。这个问题就很大了。 前面我们也说过了这是由于线程之间不同步导致的，我们需要采取一定的手段使得线程同步。最简单的方式就是将线程之间产生纠葛的地方转为单线程来执行。Java中提供了这样的一个工具。 线程同步机制我们可以通过synchronized关键字，添加线程同步代码块。格式为 synchronized(同步监视器){ ...// 需要同步的内容 } 通过上面的格式就可以构建出一个同步代码块，此时代码块中只能是单线程执行。不过这是如何实现的呢？那个同步监视器又是什么鬼？ 别看同步监视器这个名字多么的高大上。其实任何的对象都可以作为同步监视器来使用。线程想要进入同步代码块的时候将取得同步监视器。此时外面的想要进入代码块的线程因为没有取得同步监视器所以会在代码块的外面进行等待。这也就是我们之前说的，等待锁同步的时候，线程会进入阻塞状态。这个锁就是通常意义上面的同步监视器。当线程离开同步代码块的时候将返回同步监视器。这样其他的线程就可以进入代码块。因为一次只能进入一个线程的缘故，同步代码块中的内容可以认为是单线程执行的。 不过需要注意的是，同步监视器必须要是多个线程唯一的。如果每个线程的锁都是一样的，那么就起不到同步线程的作用了。在上面的例子中，我们可以使用如下的方式。 class Client implements Runnable { private int mTicket = 100; private final Object mObject = new Object(); @Override public synchronized void run() { synchronized (mObject) { while (mTicket &gt; 0) { try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } Thread.yield(); System.out.println(Thread.currentThread().getName() + &quot;: &quot; + mTicket); mTicket--; } } } } 这里使用的private final Object mObject就是一个同步监视器，而且是满足同步的需求的。所有的线程都是共用的这一个同步监视器。不过如果是使用继承Thread方式创建的线程要使用private static final Object mObject的方式，原理和上面的mTicket是相似的。 不过同步监视器要求是对象就可以。我们可以使用一个Dog类的对象作为同步监视器。不过有一个最方便的对象就是this，因为this对象也是唯一的。不过并不是所有的时候都可以使用this作为同步监视器的。比如使用继承Thread方式创建线程的话，每一个线程都有自己单独的一个this，此时就不可以把this作为同步监视器。不过，此时也有一个特别的对象可以作为同步监视器。在Java中，类其实也可以说是一个对象。每一个类都对应了一个Class对象，就是类名.class，这个对象是类唯一的，所以说是可以作为同步监视器的。关于这个类的具体的知识要等到之后谈到反射的时候才能够详细的说说了。 class Mythread extends Thread { Mythread(String name) { super(name); } Mythread() { super(); } private static int num = 1; @Override public void run() { synchronized (Mythread.class) { while (num &lt;= 100) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(getName()+&quot;: &quot;+num); num += 2; } } } } 上面就是使用反射对象作为同步监视器。 使用同步监视器虽然是解决了线程的同步问题，但是由于锁的存在，多线程之间会存在阻塞，所以被锁住的代码的执行效率甚至是还不然单线程的。所以说我们要尽量的减少同步代码块的大小。不过是要在保证数据的安全的情况下的。比如上Client类中，我们使用同步代码块将整个方法都包住了。那么可不可以少包那个while呢？比较那么地方也没有对数据进行操作。我稍微的实验了一下，结果是没有任何的问题的。但是分析一下。加入说现在还有最后的一张票。一个线程已经进入同步代码块，但是还没有进行num--的操作，此时另一个线程也进入了while，虽然进不了同步代码块，但是等到上面的线程走了，也会进入同步代码块中，所以说这样是不安全的。不过这个代码块也不是越大越好，太大了是完全没有多线程的效率的。我们要保证一个合适的位置。比如我们之前说过的单例模式。其中使用二次判断的方法，既安全也提高了多线程的效率。这个方法是多线程中经常会碰到的。 除了同步代码块之外，还可以使用同步方法。其实所谓的同步方法和同步代码块都是一样的。只要是方法内的所有的内容都是需要同步的话，我们就可以将这个方法声明为同步方法。 public synchronized void method(){ ...// method content } public static synchronized void method{ ...// method content } 其实也就是类型之前加了一个synchronized关键词。不过给静态方法加锁和给非静态方法加锁还有点儿不一样。给非静态方法加锁相当于这样。 public void method(){ synchronized(this){ ...// methon content } } 而给静态方法加锁相当于 public static void method(){ synchronized(ClassName.class){ ...// methond content } } 一个加的是对象锁，一个加的是类锁，这点需要注意一下。 释放锁线程取得锁之后什么时候会释放锁，这也是一个需要清楚的问题，正如我们需要明白线程的生命周期一样。 当线程在同步代码块或者方法中遇到了错误或异常，或者是已经执行完毕之后，会释放持有的锁。不过当线程在同步代码块中执行wait方法的时候也会释放持有的锁，当前线程会暂停，等待其他的线程调用notify方法来唤醒这个线程。这两个方法等到之后再说吧。 更多的情况是不会释放锁的。比如说调用sleep方法或者是调用yield方法，线程都只是暂停下来，但是不会将手中的锁释放。还有一点就是当其他的线程使用之前我们不推荐使用的方法suspend将线程挂起之后也是不会释放锁的，线程会暂停执行，知道调用了resume方法。 JDK5之后的锁从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同 步锁对象来实现同步。同步锁使用Lock对象充当。 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象 加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是``ReentrantLock`，可以 显式加锁、释放锁 使用的方式如下。 class A implements Runnable { private final ReentrantLock mLock = new ReentrantLock(); private int num = 100; @Override public void run() { mLock.lock(); while (num &gt; 0) { System.out.println(num); num--; } mLock.unlock(); } } 这种方式相比于synchronized的就是要手动的开锁和关锁。使用这种方式的话，JVM会使用更少的时间来调度各个线程，所以说这种方式有更好的性能。 总结上面简单的谈及了Java中线程同步的方式，还有线程同步中需要注意的问题。不过线程同步这一块还有一个比较重要的问题，那就是死锁的问题还没有说。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-02]]></title>
    <url>%2F2019%2F10%2F10%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-02%2F</url>
    <content type="text"><![CDATA[Java中的多线程-01前言之前我们说过了创建线程的两种方式。一个是继承java.lang.Thread类，重写run方法，然后使用start方法来启动这个线程。另一个就是实现Runnable接口，实现其中的run方法，然后通过构造函数将这个类传递给一个java.lang.Thread类，然后使用start方法启动线程。实际上这两种创建线程的方式是统一的，不过要说区别还是有的。 多个线程之前我们使用多线程都是让多个线程都输出0-100的所有的奇数。那么如果我们想要多个线程同时不重复的输出多个奇数该怎么办呢？如果我们使用第一种继承Thread的方式。 public class Demo1 { public static void main(String[] args) { Thread thread = new Mythread(&quot;线程一&quot;); thread.start(); Thread thread2 = new Mythread(&quot;线程二&quot;); thread2.start(); // Thread.currentThread().setName(&quot;主线程&quot;); // for (int i = 0; i &lt; 100; i++) { // if (i % 2 == 0) { // System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i); // } // } } } class Mythread extends Thread { Mythread(String name) { super(name); } Mythread() { super(); } private static int num = 1; @Override public void run() { while (num &lt;= 100) { System.out.println(getName()+&quot;: &quot;+num); num += 2; } } } 这里只是简单的遍历一下100以内的所有的奇数，没有加什么奇数的判断。不过多个线程之间是如果交流的。这里我们使用了一个静态字段private static int num。通过Thread继承的线程，他们都是属于Mythread这个类的对象。如果我们想要一个类的多个对象之间共享数据，那么就可以通过静态成员的方式，因为静态成员是属于类的，而类只有那一个。 如果我们使用的是Runnable接口？ public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread); thread1.setName(&quot;线程一&quot;); thread1.start(); Thread thread2 = new Thread(myThread); thread2.setName(&quot;线程二&quot;); thread2.start(); // Thread.currentThread().setName(&quot;主线程&quot;); // // for (int i = 0; i &lt; 100; i++) { // if (i % 2 == 0) { // System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); // } // } } } class MyThread implements Runnable { private int num = 1; @Override public void run() { while (num &lt;= 100) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + num); num += 2; } } } 这里我们使用的是private int num，是一个实例成员而不是上面那样的那个静态成员。为什么呢？因为MyThread这个类其实只有一个，上面的多个线程都是通过同一个MyThread对象传参而创建的。其实使用实现Runnable接口这个方式是具有一定的优势的，因为是基于同一个对象，这些线程天生具有数据共享的优势。 不过，问题就在于上面的两个操作是否可以满足我们的期望呢？这个待我们学习一下线程的生命周期再说。 线程的生命周期前面我们说过了线程就像一个人，有出生也有死亡。不过这个只是线程的开始和结束，那么线程是否有其他的中间状态呢？ 线程总共分为一下的五个阶段。 上面的两张都形象的显示了线程的生命周期。下面我们就以下面的这张为例子进行说明吧。 新建首先是新建状态。这个也就是之前我们说的线程的出生。调用start方法之后线程将会进入新建状态。 就绪其实是就绪状态。当线程进入新建状态之后就会进入就绪状态。所谓的就绪状态就是等待cpu的调度。之前也说过，所谓的多线程其实并不是同时进行。而是每个线程都执行一段时间。那些没有被执行的线程就处于就绪状态等待cpu的调度。其实关于线程的调度这个还有一个知识点，就是线程的优先级。多个线程都处于就绪状态，等待线程的调度，不过这样的调度是否有优先级呢？就比如说我们都在排队买东西，这是突然来了一个VIP客户，直接插到我们前面去了，因为他拥有更高的优先级。 线程的优先级是可以设置的，就像设置线程的名字一样。有setPriority和getPriority方法。setPriority的参数是0-10的int类型的书。不过Thread类中定义了三种线程优先级的常量Thread.MIN_PROORITY, Thread.NORM_PRIORITY和Thread.MAX_PRIORITY。他们对于的枚举值分别是0 5 10。其中如果我没有对线程的优先级进行设置的话，线程的优先级将就是Thread.NORM_PRIORITY。不过需要注意的一点是，线程优先级高并不是意味着他将总会抢到低优先级的线程的资源。即使线程优先级是10也有可能被优先级是0的给抢占了资源。就好比100度的水也有不少的分子运动的比0度的水中的分子还慢。这个东西满足的是一种统计规律。 运行当处于就绪状态的线程得到了CPU的调度权之后，将会进入运行状态，此时将会运行线程中的run方法。不过之前我们也说过CPU的调度是轮换的，有可能CPU就调用你1ms就调用其他的线程去了。不过此时线程的run方法还没有结束，此时线程将会返回之前的就绪状态。还有另外的一种情况，不是cpu剥夺调度的资源，而是线程自身志愿放弃调度资源。在线程运行的时候调用yield方法线程就会自动放弃处理器资源。 不过上面有一个要点就是，即使线程失去了资源了。也就是从运行状态回到了就绪状态，他依旧可以参与下一轮线程的抢夺。也就是说我调用yield方法之后，我自愿放弃了我拥有的资源，不过下一轮又抢到了，你这个就没办法了，别的线程是真的抢不过你这个欧皇啊！ 阻塞不过运行的时候也不一定会安全的回到就绪状态。有可能在运行的过程睡着了进入阻塞状态。比如说调用了Thread.sleep方法，线程就会如同方法那样睡着了。此时就是进入了阻塞状态。不过此时这个线程不会占用CPU的资源。毕竟只是你自己睡着了，如果你还占用资源的话，其他资源不也就都跟着你睡着了嘛。Thread.sleep接受一个long参数，代表的是要睡着的时间。时间到了之后，线程就会回到就绪状态，重新去抢占资源进入运行状态。 不过还有其他的方式进入阻塞状态。比如说IO操作的时候。这个应该是最容易理解的。比如我们使用scanner.next()的时候，程序会停下来，知道我们通过控制台输出信息并且按下回车键之后才会继续运行。其实程序停下来，主线程就是进入了阻塞状态了。 还有一个比较重要的方式join方法，图中没有谈到。当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止。也就是说在线程二中调用线程一.join()的时候，线程二将会进入阻塞状态，知道线程一死亡。比如说线程二要做的时候必须在线程一做完他的事的基础上就可以使用join方法。 还有其他的进入阻塞的方式，比如上面写的，等待同步锁，等待通知。还有suspend方法，不过这个suspend方法已经被废弃了，建议不要使用。童谣的还有resume方法，可以强行从阻塞进入就绪状态，和suspend是一对的。不过都是存在安全隐患的，不建议使用。 死亡人终有一死，线程也是如此，每一个线程的最终目的地就是死亡。只不过通往死亡的道理可能有差别罢了。可能是run方法结束了，或者是线程运行的时候出现了异常或者错误。亦可能是调用了stop方法。不过这个方法也是不建议使用的。 其他方法上面说了线程的生命周期，同时也说了不少的方法。现在还有几个方法需要补充的。比如说isAlive方法，可以判断线程是否还存活着。getState方法可以返回线程的状态。Thread类中有一个枚举类State定义了不同的状态。有NEW RUNNABLE BLOCKED WAITING TIMED_WAITING TERMINATED。其中多了一个TIMED_WAITING，官方文档中的解释是，这个状态是长时间的处于WAITING状态。 还有一个比较重要的概念。守护线程。Java中的线程分为两种用户线程和守护线程。Java的垃圾回收器GC就是一个守护线程。简单的来说守护线程就是来守护其他的线程的，如果要守护的线程结束了，那么守护线程也就没有运行的意义了。我们可以是Java中的setDaemon(true)方法将线程设置为当前线程的守护线程。 public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread); thread1.setName(&quot;线程一&quot;); thread1.setDaemon(true); thread1.start(); Thread thread2 = new Thread(myThread); thread2.setName(&quot;线程二&quot;); thread2.setDaemon(true); thread2.start(); System.out.println(thread1.getState()); Thread.currentThread().setName(&quot;主线程&quot;); for (int i = 0; i &lt; 10; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } System.out.println(&quot;主线程结束&quot;); } } 此时当主线程结束的时候，线程一、二都会相继结束，因为他们是主线程的守护线程。不过主线程结束之后可能还会有输出，那个只是输出的延迟而已。 线程同步问题上面已经说完了线程的生命周期以及线程的常用的一些方法。现在我们该回到我的正题上面来了，使用静态成员或者是实例成员变量的方式是否可以正确的工作呢？ 看一下输出的结果如何。 线程一: 1 线程二: 1 线程一: 3 线程二: 5 线程一: 7 线程二: 9 ...... ...... 线程二: 93 线程一: 95 线程二: 97 线程一: 99 上面省略了中间的部分，其实那部分都非常的正常，不过前面的两个1是什么意思。其实这个结果还不是很明显，然后我们来线程中加入sleep来模拟网络的延迟。 class Mythread extends Thread { Mythread(String name) { super(name); } Mythread() { super(); } private static int num = 1; @Override public void run() { while (num &lt;= 100) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(getName()+&quot;: &quot;+num); num += 2; } } } 看一下有了延迟之后的输出如何 线程一: 1 线程二: 1 线程一: 5 线程二: 5 线程一: 9 线程二: 9 线程一: 13 线程二: 13 线程二: 17 线程一: 17 ...... ...... 线程二: 89 线程一: 89 线程一: 93 线程二: 93 线程一: 97 线程二: 97 线程一: 101 或许是我这个延迟设置的有点高？？？这个输出简直是瞎扯，全是bug？不过是什么导致的呢？ 我们先来考虑开始的情况，首先线程一进入了while循环，不过遇到了sleep，就睡了一会，线程二也是如此，进入了while，之后睡了一会。然后线程一输出了1，在22行代码还没有执行的时候，线程二也输出了1。后面的道理也是如此，这就是为什么同样的数值我们总是输出了两次。 再来看看最好的情况。此时num的值是99，所以线程一进出了，但是线程二还在执行加二的操作。等到线程一进入了while之后，num就变成了101，所以就输出了101。 上面就是对这个结果的分析。从上面我们可以看到问题所在了。线程之间不是同步的。多个线程同时执行这段逻辑使得这个逻辑变得残破不看。 一般来说，当涉及多多个线程共享数据的时候，我们就要考虑线程同步的问题了。不过如何同步线程呢？我们说过这个逻辑是单线程的逻辑，那我们就只能做一点牺牲强行将执行这段代码的多线程变成单线程。把多行道的车变成单行道怎么做呢？就是将收费站那样做。限制每次只能有一个车过。 总结上面主要介绍了线程的生命周期，还有Thread类的主要的方法，还有就是提出了待解决线程的同步问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多线程-01]]></title>
    <url>%2F2019%2F10%2F09%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B-01%2F</url>
    <content type="text"><![CDATA[Java中的多线程-01前言前面我们学习了Java8中一些新的特性，不过那些基本上都是支线剧情。主线剧情我们已经走完了Java中IO，现在就要开始另一个主线剧情了——Java中的多线程。这也是非常重要的一个部分。下面就来简单的学习一下吧。 什么是多线程说到多线程，这又得说到我们说设计模式的时候说到的那个单例模式了。正常情况下，饿汉式单例模式是不会出现问题的，但是一旦进入了多线程的环境的时候，代码就会出现很大的问题。那么究竟是为什么会出问题呢？多线程到底又是什么呢？ 计算机中有很多的进程，比如说现在我的电脑中开着很多软件。qq是一个进程，微信也是一个进程。每一个程序都是一个进程。我们的计算机就是多进程的。每个进程都有多个线程。比如QQ中和不同的人聊天，每一个聊天窗口就可以看出是一个线程（其实聊天窗口也应该是多线程的）。如果QQ是单线程的，我们每次只能和一个人聊天，而不能同时和多个人聊天，这该多无聊。（不对啊，有人找我用QQ聊过天吗？笑cry） 把上面的例子类比到我们的Java程序中来。也就是说如果我们的Java程序一次只可以干一件事情，那么就是单线程的，如果同时干多件事情，那么就是多线程的。简单一点来说就是，如果我们可以只用一条线就可以将代码中所有的操作连接在一起，那么就是单线程，若是出现了分叉，那就是多线程的。不过众所周知，Java中程序运行的都是按照从上到下的顺序来执行的，怎么可以同时执行多个操作呢？ 我们当然是不可能通过之前是方式来创建多线程的操作的，所以Java提供了一个类java.lang.Thread，通过这个类，就可以实现多线程的操作。 java.lang.Thread上面我们说到了多线程的实现和这个类有关，那么我们就来学习一下这个类的有关的信息。 java.lang.Object java.lang.Thread public class Thread extends Object implements Runnable 线程是程序中执行的线程。Java虚拟机允许应用程序同时执行多个执行线程。 每个线程都有优先权。 具有较高优先级的线程优先于优先级较低的线程执行。 每个线程可能也可能不会被标记为守护程序。 当在某个线程中运行的代码创建一个新的Thread对象时，新线程的优先级最初设置为等于创建线程的优先级，并且当且仅当创建线程是守护进程时才是守护线程。 当Java虚拟机启动时，通常有一个非守护进程线程（通常调用某些指定类的名为main的方法）。 Java虚拟机将继续执行线程，直到发生以下任一情况： 已经调用了Runtime类的exit方法，并且安全管理器已经允许进行退出操作。 所有不是守护进程线程的线程都已经死亡，无论是从调用返回到run方法还是抛出超出run方法的run 。 至于这个类的构战方法和实例方法现在暂且不看了。其实上面的东西也没有什么看的必要。不过官方文档下面给我们的信息是非常重要的。在jdk1.5之前，我们可以使用两种方式创建线程。一种方式是继承Thread类，另一种方式是实现Runnable接口。 创建一个线程继承Thread类现在我们想要使用多线程的方式输出0-100之中所有的偶数。首先是第一中方式，继承Thread类。 但我们需要创建一个线程的时候，需要一下的几个步骤。 写一个类继承Thread类 重写类中的run()方法。 创建这个类的实例 调用类中的start()方法。 public class Demo1 { public static void main(String[] args) { Thread thread = new Mythread(); thread.start(); System.out.println(&quot;Main Function End!&quot;); } } class Mythread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(i); } } } } 比如说上面的代码就是按照上面的步骤创建的一个多线程。那么如何证明这个是多线程呢？Java程序中原来就是一个单线程执行的，这个线程是主线程。主线程从main函数开始执行。执行到run之后，开启了一个新的新的线程。此时这个新的线程和主线程是同时开始运行的。所以此时我们执行这个代码，输出的结果可能就是Main Functin End先开始输出了。 不过为什么我们重写的run方法，要启动线程却要调用start方法呢？我们是否可以直接调用run方法？确实是可以直接调用run方法的，不过这个就不是多线程了，而就是一个普通的类的调用。此时Main Function End肯定是最后输出的。所谓的start方法其实是java.lang.Thread这个类的专门用来启动线程的方法，我们不通过这个start方法是没有办法启动一个线程的。至于run方法，在java.lang.Thread类中其实也是有实现的，不过按道理来说应该是一个抽象函数，为什么会有实现呢？这里可以以后再说。 现在我们要是两个线程去输出结果，现在应该怎么办呢？很简单，再次调用一下start方式不就可以了？不过很遗憾，这个方式是大错特错的。这样做会抛出一个java.lang.IllegalThreadStateException异常，一个线程只能够被启动一次。其实之后我们就会明白了，一个线程就像一个人，调用start就相当于出生了，run方法执行完毕就相当于死亡了。你想要一个线程起死回生这明显是不可能的事情。不过我们可以再生一个线程。（正如你的爸妈觉得你太笨了，是没办法把你塞会娘胎里重新生一次，不过他们可以选择再生一个，蛤蛤蛤）。 不过现在还是有问题，我们搞不清楚现在是谁输出的啊？其实我们可以通过getName()方法得到线程的名字。我们可以让主线程也参与到输出中来。不过如何获取主线程的名字？我们可以使用Thread.currentThread().getName()方法获取运行当前的代码的代码的线程名字。对于前面的Thread及其子类说，可以直接使用getName()方式。（相当于this.getName()) public class Demo1 { public static void main(String[] args) { Thread thread = new Mythread(); thread.start(); Thread thread2 = new Mythread(); thread2.start(); for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName()+&quot;: &quot;+i); } } } } class Mythread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(getName()+&quot;: &quot;+i); } } } } 上面其实就是三线程的代码了。观察其中的一段输出结果。 main: 18 Thread-1: 38 Thread-0: 20 Thread-1: 40 main: 20 Thread-1: 42 Thread-0: 22 Thread-1: 44 Thread-0和Thread-1是自动给我们直接创建的线程的编号。当然我们也可以通过setName()方式给我们的线程起一个名字。不过这个操作我们必须要在这个线程调用start方法之前使用。给主线程起名字就和上面得到主线程的名字一样，可以使用Thread.currentThraed().setName()。不过除了上面的方法之外，我们还可以直接在构战函数中给定线程的名字。因为我发现Thread类有如下的构造函数。 Thread(String name) // 分配一个新的 Thread对象。 不过构造函数式无法继承的。我们需要在MyThread中写一个Mythread(String name)构造函数，不过空参构造函数也是必须的。 Mythread(String name) { super(name); } Mythread() { super(); } 上面是关于线程名字设置的一些bb，不过现在让我回到输出的内容中来。我们发现这三个线程的输出是有交互的。这足以说明这三个线程是并行的了，也就是这三个线程是同时进行的。 *注意： * 上面我说这三个线程的同时进行的。其实这是一个误解。其实同一个时间上其实还是只有一个线程被执行。因为我们的CPU同一个时间段只可以执行一个操作。那我们为什么说他们是并行的呢？那是因为CPU切换的速度非常快，他可能是执行这个线程一点点时间，然后去执行另外的线程，然后再次切回到这个线程。这个切换的时间非常的短。正是因为时间非常的短，我们才会说这个是可以看成是多线程的。正如我们看的电影，其实就是一张张图片连续切换。有的是一秒六十帧，有的是八十帧，还有的是一百二十帧。正是因为切换的速度非常的快，我们才感觉这个是连续的。如果每秒就放几张 。。。emm，这不是PPT吗？ 实现Runnable接口上面我们使用的方式是继承的方式来实现创建线程。不过这可能会带来一个比较大的问题。众所周知，Java中的类都是单继承了。如果我们继承了Thread这个类，那么我们就无法继承其他的类。比如上面我们的Mythread如果应该是MyTinythread的子类，但是因为继承Thread就无法继承MyTinythread了。所以说使用继承的方式来实现多线程倒是有点限制。不过Java中接口是没有个数限制的，你要是本事大，你实现一百个接口也没有人管你。所以现在我们需要使用接口的方式来实现多线程的操作。 因为说实在的，上面我们创建多线程的操作。除了写个run函数，其余的操作都是没有用的操作。我们甚至可以使用匿名内部类的方式来创建一个多线程，比如。 new Thread(){ @Override public void run() { System.out.println(&quot;Hello World&quot;); } }.start(); 经过我们之前的学习，匿名内部类这个玩意是和接口有点儿关系的。这个接口应该是只有一个void run()方法来需要我们实现的。这个接口就是Runnable接口。 public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread = new Thread(myThread); thread.start(); } } class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } 我们可以通过上面的方式来创建一个多线程。 要注意的是，虽然我们的MyThread类实现了Runnable接口并且实现了其中的run方法。我们是不可以使用myThread.start()方法来启动这个线程的。因为MyThread没有启动线程的能力。而接口也只是一个协议，这只是告诉别人，我实现了一个方法void run()。并没有其他的信息。我们想要启动线程，还是要借助java.lang.Thread类。 我们发现java.lang.Thread中还是有这样的构造函数。 Thread(Runnable target) // 分配一个新的 Thread对象。 Thread(Runnable target, String name) // 分配一个新的 Thread对象。 不过现在问题也来了，我们实现了这个接口，但是我们调用start方法启动的不应该是Thread中的run（上面我们推测应该是一个抽象方法的）吗？和接口中的run又有什么联系呢？我们来看一下源码就好了。 @Override public void run() { if (target != null) { target.run(); } } 可以看到如果我们没有传递Runnable接口的话，这个函数确实是什么都不会做。如果我们使用继承的方式的话，这个函数应该是被覆盖了的，当时我们猜测父类中的函数应该是抽象函数就是没有考虑到构造函数中还可以使用Runnable接口。如果使用Runnable接口的话，target就不会是null。然后就会调用接口中的run方法。 下面我们继续来探讨一下上面谈过的问题。 第一个设置线程的名字。可以通过上面的第二个构造函数来传递名字参数。（此时不需要我们写其他的构造函数了）。不过也可以通过在调用start方法前，使用thread.setName()的方式。 第二个获取线程的名字。依旧可以使用getName()的方式。不过需要注意的是，在MyThread中，我们不可以使用getName()的方式来获取线程的名字了。因为此时这个类已经不是Thread的子类，也不存在getName()这个方法了。如果在这个类中，我们需要使用像获取主线程的名字那样的形式Thread.currentThread().getName()的方式。 第三个就是如果我们此时还想要开始一个同样的线程应该如何？继续new一个MyThread??当然不是，我们说过线程有生有死，不能起死回生。但是MyThread并不是一个线程。我们想要重新创建一个线程的话，只需要new一个Thread，然后继续将MyThread作为一个Runnable参数传递出去就行了。 public class Demo2 { public static void main(String[] args) { MyThread myThread = new MyThread(); Thread thread1 = new Thread(myThread); thread1.setName(&quot;线程一&quot;); thread1.start(); Thread thread2 = new Thread(myThread); thread2.setName(&quot;线程二&quot;); thread2.start(); Thread.currentThread().setName(&quot;主线程&quot;); for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } class MyThread implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { if (i % 2 == 0) { System.out.println(Thread.currentThread().getName() + &quot;: &quot; + i); } } } } 总结上面只是简单的介绍了一下两种创建线程的方式，至于其他更加深入的就要等到下次再讲了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的StreamAPI]]></title>
    <url>%2F2019%2F10%2F07%2F%E5%BC%BA%E5%A4%A7%E7%9A%84StreamAPI%2F</url>
    <content type="text"><![CDATA[强大的StreamAPI前言其实之前已经说了不少的有关Java8的新的特性的话题了，比如说最重要的lambda表达式，还有之前说的那个函数式接口与方法引用都是Java8中的一大更新。不过Java8中两大最重要的改变，第一个是lambda表达式，第二个就是我们接下来要说的强大的StreamAPI了。Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这 是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程 序员的生产力，让程序员写出高效率、干净、简洁的代码。 StreamAPI的基础知识那么StreamAPI到底是一个什么玩意呢？所谓的Stream就是流的意思，大抵就是处理数据用的玩意。Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进 行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种 高效且易于使用的处理数据的方式。这么说可能是有点儿懵逼的感觉，Stream是一种处理集合数据的算法或者说结构吗？不全是。那么？Stream到底是什么呢？ Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是数据，Stream讲的是计算！” 关于Stream有三大需要注意的地方。 Stream自己不会储存元素，他只是用来处理元素用的。 Stream不会改变源对象，他之后将源对象经过处理之后返回一个新的Stream Stream的操作是延迟执行的，他只会在需要结果的时候才去执行。 关于Stream的操作，主要分为一下的三个步骤： 创建一个Stream；从一个数据源中获取一个需要处理的流。这个数据源多半是集合。 中间操作；对这个流进行处理。 终止操作；结束对这个流的操作。 创建StreamStreamAPI这个玩意不像之前的东西，这个东西就是要按照规矩来一步一步的来学，毕竟他就是一个API而已。那么我们先从如何创建一个Stream开始说起。 前面说了，最常用与stream的就是Java中的集合。那么第一种方式就是。 从集合中创建一个Stream集合的最终父类是Collection，在Java8种这个接口被扩展了。增加了两个新的方法。 default Stream&lt;E&gt; stream() // 返回一个顺序流 default Stream&lt;E&gt; parallelStream() // 返回一个并行流 也就是说有了一个集合，我们就可以通过stream或者parallelStream方法返回一个stream对象。比如说。 public class Demo { public static List&lt;Student&gt; getList() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(&quot;sher1&quot;, 18, 88.3, 110)); list.add(new Student(&quot;sher2&quot;, 28, 188.3, 2110)); list.add(new Student(&quot;sher3&quot;, 38, 288.3, 3110)); list.add(new Student(&quot;sher4&quot;, 48, 388.3, 4110)); list.add(new Student(&quot;sher5&quot;, 58, 488.3, 5110)); list.add(new Student(&quot;sher6&quot;, 68, 588.3, 6110)); list.add(new Student(&quot;sher7&quot;, 78, 688.3, 7110)); list.add(new Student(&quot;sher8&quot;, 88, 788.3, 8110)); return list; } public static void main(String[] args) { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; studentStream = list.stream(); Stream&lt;Student&gt; parallelStream = list.parallelStream(); } } 通过上面的方式就可以创建出一个Stream。至于取得这个Stream之后的操作如何，这里不说。（没用使用官方文档的套路说，是因为官方文档中对Stream的说明都太高大上了，我都不知道Stream是啥，你给我整那么多代码干啥） 上面创建了两个流。第一个是顺序流，也是最常用的。第二个是并行流。 这里我们可以使用forEach方法来对流中的元素进行一次遍历。 studentStream.forEach(System.out::println); System.out.println(&quot;======================&quot;); parallelStream.forEach(s -&gt; System.out.println(s)); forEach函数需要的参数是一个Consumer。上面的第一种方式是使用方法引用，第二种方式是使用lambda表达式。这个算是对之前学习的内容的一个简单的复习。这里来看一下他们的输出。 Student{mName=&#39;sher1&#39;, mAge=18, mScore=88.3, phone=110} Student{mName=&#39;sher2&#39;, mAge=28, mScore=188.3, phone=2110} Student{mName=&#39;sher3&#39;, mAge=38, mScore=288.3, phone=3110} Student{mName=&#39;sher4&#39;, mAge=48, mScore=388.3, phone=4110} Student{mName=&#39;sher5&#39;, mAge=58, mScore=488.3, phone=5110} Student{mName=&#39;sher6&#39;, mAge=68, mScore=588.3, phone=6110} Student{mName=&#39;sher7&#39;, mAge=78, mScore=688.3, phone=7110} Student{mName=&#39;sher8&#39;, mAge=88, mScore=788.3, phone=8110} ========================================================= Student{mName=&#39;sher6&#39;, mAge=68, mScore=588.3, phone=6110} Student{mName=&#39;sher5&#39;, mAge=58, mScore=488.3, phone=5110} Student{mName=&#39;sher8&#39;, mAge=88, mScore=788.3, phone=8110} Student{mName=&#39;sher7&#39;, mAge=78, mScore=688.3, phone=7110} Student{mName=&#39;sher3&#39;, mAge=38, mScore=288.3, phone=3110} Student{mName=&#39;sher4&#39;, mAge=48, mScore=388.3, phone=4110} Student{mName=&#39;sher2&#39;, mAge=28, mScore=188.3, phone=2110} Student{mName=&#39;sher1&#39;, mAge=18, mScore=88.3, phone=110} 顺序流中的数据和原来集合中的元素的顺序是一致的，但是并行流我们运行了几次之后发现顺序都是会发生变化的。可见并行流中对于数据的处理是没有顺序的。更严谨的说，他对数据的处理是并行的。这里多线程还没有说，如果讲了多线程之后就是特别的容易理解的了。 从数组中创建一个流数组中似乎没有stream这个方法。不过Java8种更新了一个和数组的使用密切相关的类——Arrays。我们可以使用如下的方式从数组中获取一个流。 static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) //返回一个流 代码测试如下 @Test public void test2() { int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9}; String[] strArr = {&quot;sher&quot;, &quot;hony&quot;, &quot;sherhony&quot;}; IntStream stream = Arrays.stream(arr); Stream&lt;String&gt; stringStream = Arrays.stream(strArr); stream.forEach(System.out::println); stringStream.forEach(System.out::println); } 其实上面的代码很容易发现一个奇怪的地方。为啥int数组返回的是IntStream而不是Stream&lt;Integer&gt;。我们上面的自定义的类型和String类型都是Stream&lt;T&gt;的形式。当我使用Stream&lt;Integer&gt;来代替IntStream的时候，发现报错了。我们发现，这个函数处理int的时候并没有涉及装箱拆箱的操作，而是这个方法对int[] short[] double[]这三个基本数据类型参数做了重载。如果是short[] float[] char[]这种数组的话，是没有办法直接使用Arrays.stream方法的。可以转为Short[]等才能够使用这个方法。 public static IntStream stream(int[] array) public static LongStream stream(long[] array) public static DoubleStream stream(double[] array) 通过Stream的of()方法上面是两种创建流的方式最常用的方式。下面再次来介绍一下通过Stream的of()方法来创建一个流。方法如下： public static&lt;T&gt; Stream&lt;T&gt; of(T... values) // 返回一个流 @Test public void test3() { Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7); integerStream.forEach(System.out::println); } 创建一个无限流上面的三个方法都是创建了一个有限流。我们也可以通过一下的两种方式创建一个无限流。 //迭代 public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) // 生成 public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) 先来说第一个方式迭代。所谓迭代就是通过一个递推的方式来产生一个无限流。比如说产生所有的奇数流就可以这样写。 @Test public void test4() { Stream&lt;Integer&gt; iterate = Stream.iterate(1, x -&gt; x + 2); iterate.limit(10).forEach(System.out::println); } 上面使用的limit(10)就是把流限制在10个，不然无限流就会无限运行下去。 也可以使用generate方法，比如说产生无限个随机数的流。 @Test public void test5() { Stream&lt;Double&gt; generate = Stream.generate(Math::random); generate.limit(10).forEach(System.out::println); } Stream的中间操作上面我们已经基本掌握了创建一个Stream的方式，现在要学的是Stream中最重要的一块——中间操作。 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止 操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全 部处理，称为“惰性求值” 那么上面我们只是使用了创建流的方式为什么我们可以看到流中的数据呢？那是因为我们确实使用了终止操作，forEach就是一个终止操作，安装流中的顺序来遍历流中的元素。其实上面无限流中说到的限制流中元素的个数的操作就是一种中间操作。中间操作也分为多种，下面来一种一种介绍。 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ，从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一 个空流。与 limit(n) 互补 下面来对上面的代码就以上面的那个List&lt;Student&gt;做代码演示 输出所有年龄大于40岁的 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.filter(x -&gt; x.getAge() &gt; 40).forEach(System.out::println); } 去掉重复的学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.distinct().forEach(System.out::println); } 注意：一个流在经过终止操作了就不能够再使用。 输出前五个学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.limit(5).forEach(System.out::println); } 跳过前五个学生 @Test public void test6() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.skip.forEach(System.out::println); } 上面的方法都比较简单，下面来看看下一个操作。 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元 素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元 素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流 所谓的map就是映射的意思。高中是都学过映射的概念，就是将一个值以某种法则变成另一个值。 @Test public void test7() { Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7); integerStream.map(x -&gt; { if (x % 2 == 0) { return 0; } else { return x; } }).forEach(System.out::println); } 上面的方法可以将流中的所有的偶数变成0。对于这个例子来说也可以写成mapToInt，mapToDouble，mapToLong这三种形式，只不过是返回值的类型不同罢了。 对于flatMap的使用就是比较复杂了的。他是将每个值都换成另一个流，然后将所有的流连接成为一个流。 比如如下的代码 @Test public void test8() { List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(1); list1.add(1); list1.add(2); List&lt;Integer&gt; list2= new ArrayList&lt;&gt;(); list2.add(2); list2.add(3); List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(); list3.add(6); list.add(list1); list.add(list2); list.add(list3); Stream&lt;List&lt;Integer&gt;&gt; stream = list.stream(); stream.forEach(x -&gt;{ x.forEach(System.out::println); }); } 这个流中的元素都是List，如果我们想要取得所有的数据的话就需要对流中的元素再次使用forEach。这两个forEach是不一样的。一个forEach是流对象的，而另一个是集合对象的方法。 如果我们使用的是flatMap方法就可以将流中的数据转成一个流，然后将这些流合并成一个流，这样我们就可以只使用一个forEach就可以对这个流进行遍历了。 list.stream().flatMap(List::stream).forEach(System.out::println); 只需要使用这一行的代码，其中使用两个方法引用。List::stream是将一个List转为Stream用的。这也是对方法引用的一个复习了。 上面的映射的操作应该是StreamAPI的核心操作，特别是map方法就是最重要的一个操作。前面的filter方法也是一个非常重要的方法。 排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序排 如果要使用第一种方式，流中的数据的类型必要要实现Comparable接口（里面有个compareTo方法），不然是不可以使用第一种方式的。(这都应该是Java中的基础中的基础了吧) 如果是使用第二种方式的话，只要实现这个函数式接口就行了。 @Test public void test9() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); stream.sorted(Comparator.comparing(Student::getAge)).forEach(System.out::println); } 如果需要得是降序的话，就只能写成这种形式了 stream.sorted((x, y) -&gt; -Integer.compare(x.getAge(), y.getAge())) .forEach(System.out::println); 上面基本上就是最常用的中间操作了，下面要来介绍的是终止操作。 终止操作上面的操作中我们使用的所有的终止操作都是forEach方法来遍历，其实Stream的终止操作也有很多，而且也分为不同的类型。下面就来一一介绍吧。 匹配和查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。相反，Stream API 使用内部迭 代——它帮你把迭代做了) 上面的值也都是很容易理解，不需要其他过多的说明。 归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一 个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一 个值。返回 Optional 这个操作一般情况下是和map操作结合起来用的，比如要求所有的学生的年龄之和。 @Test public void test11() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Optional&lt;Integer&gt; reduce = stream.map(Student::getAge).reduce(Integer::sum); reduce.ifPresent(System.out::println); } 至于第一个函数的第一个参数就是初始值。用法如下。 @Test public void test11() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); // Optional&lt;Integer&gt; reduce = stream.map(Student::getAge).reduce(Integer::sum); Integer reduce = stream.map(Student::getAge).reduce(a, (x, y) -&gt; x * y); System.out.println(reduce); } 这里返回的类型是T，不是Optional&lt;T&gt;。 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总 的方法 函数名 返回值 toList List&lt;T&gt; 把流中元素收集到List List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList()); toSet Set&lt;T&gt; 把流中元素收集到Set Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet()); toCollection Collection&lt;T&gt; 把流中元素收集到创建的集合 Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::new)); counting Long 计算流中元素的个数 long count = list.stream().collect(Collectors.counting()); summingInt Integer 对流中元素的整数属性求和 int total=list.stream().collect(Collectors.summingInt(Employee::getSalary)); averagingInt Double 计算流中元素Integer属性的平均值 double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary)); summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值。如：平 均值 int SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary)); joining String 连接流中每个字符串 String str= list.stream().map(Employee::getName).collect(Collectors.joining()); maxBy Optional&lt;T&gt; 根据比较器选择最大值 Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary))); minBy Optional&lt;T&gt; 根据比较器选择最小值 Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary))); reducing 归约产生的类型从一个作为累加器的初始值开始， 利用BinaryOperator与流中元素逐 个结合，从而归约成单个值 int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum)); collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转 换函数 int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); groupingBy Map&lt;K, List&lt;T&gt;&gt; 根据某属性值对流分组，属性为K， 结果为V Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus)); partitioningBy Map&lt;Boolean, List&lt;T&gt;&gt; 根据true或false进行分区 Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage)); 上面是常用的一些方法。下面都有代码演示。 @Test public void test12() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); ArrayList&lt;Student&gt; collect = stream.filter(x -&gt; x.getAge() &gt; 40) .collect(Collectors.toCollection(ArrayList::new)); for (Student student : collect) { System.out.println(student); } } @Test public void test13() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Integer collect = stream.collect(Collectors.reducing(0, Student::getAge, Integer::sum)); System.out.println(collect); } @Test public void test14() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Integer collect = stream.collect(Collectors.collectingAndThen(Collectors.toList(), List::size)); System.out.println(collect); } @Test public void test15() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Map&lt;Integer, List&lt;Student&gt;&gt; collect = stream.collect(Collectors.groupingBy(Student::getAge)); for (Integer i : collect.keySet()) { System.out.println(&quot;i = &quot; + i); System.out.println(collect.get(i).get(0)); } } @Test public void test16() { List&lt;Student&gt; list = getList(); Stream&lt;Student&gt; stream = list.stream(); Map&lt;Boolean, List&lt;Student&gt;&gt; collect = stream.collect(Collectors.partitioningBy(x -&gt; x.getAge() &gt; 40)); for (Boolean b : collect.keySet()) { System.out.println(b); for (Student s : collect.get(b)) { System.out.println(s); } } } 总结StreamAPI是Java8种新增的非常顶的API，对于这种API式的东西就是多用多学习，其他也是没有什么好的捷径了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式接口与方法引用]]></title>
    <url>%2F2019%2F10%2F06%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[函数式接口与方法引用前言之前我们说到了Java8中的一个新的特性，就是lambda表达式的使用，不过当时只是简单的了解了一下，没有与Java8中其他的新的特性做一个全面的了解。这里我们要到的Java中的函数式接口和方法引用就是Java8种新增加的东西，而且这两个新东西和lambda表达的式的联系还非常的密切。 什么是函数式接口之前说了和其他的编程语言不同的是，Java是一门非常面向对象的语言，对象在Java的世界中就是最重要的玩意。其他语言中的lambda表达式都是一种函数，而Java中的lambda表达式不是函数，之前我们说过了是一种依赖于接口的一个玩意。作用和匿名内部类非常的相似。（其实lambda这个玩意就是Java抄袭其他的语言的，其他的语言基本上很早就有了，而且大家都非常喜欢用，那Java可不要趁一波“热度“嘛。不过热度也不能瞎趁，其他的语言之中，函数的地位其实才是老大，比如说python就是一门函数式的原因，Java是一门对象为中心的语言，那么lambda表达式代表的就是一个对象。）上面扯多了，不瞎扯这个玩意了。先回到正题。 不过lambda表达式依赖的接口是有一定的条件的。他必须是只一个函数需要我们来实现。比如说新建一个线程的Runnable接口中只有一个函数run()需要我们实现。这样的接口就可以使用lambda。使用的方法如下。 Runnable a = () -&gt; System.out.println(&quot;Hello World&quot;); 其实这样的接口就是所谓的函数式接口，也就是所有的只有一个抽象函数需要实现的接口就是函数式接口。Java8种函数式接口的上面有一个注解(就像重写父类的方法的注解@override一样)叫做@FucntionalInterface。比如我们要写一个函数式接口 @FunctionalInterface interface A{ void func(); } 当然这个@FunctionalInterface不加也是可以的，就像你函数重写不加@override也是对的，毕竟这个玩意只是一个注解。不过还是要明白加上去的含义是什么的。 那么我们现在就可以说清楚Java当中的lambda表达式是一个什么东西了。lambda表达式就是函数式接口是实例。lambda表达式的存在必须要依赖于函数式接口，不过虽然lambda表达式是一个对象，但是他的作用相当于是一个函数。就像c++当中的仿函数一样，虽然是一个对象，但是是可以调用的，作用也是相当于一个对象。其实C++中的lambda表达式虽然说是一个函数，不过实际上也是一个对象——std::function，所有的可调用的变量都可以是这个std::function，其本质上也是一个类，也就是仿函数Function Class。 函数式接口的作用那么说了那么多没用的废话，这个函数式接口的作用到底是什么呢？仅仅是给了一个定义？？ 我们都知道OOP是面向对象编程的意思。其实今年来又兴起了一种的新的编程的方式——OOF面向函数编程。函数式接口的存在使得Java也可以进行OOF的编程方式。我们可以将函数式接口作为参数，然后使用lambda表达式进行参数的传递。 @FunctionalInterface interface A{ void func(String str); } public void test1(String str, A a) { a.func(str); } 看上面的代码，我们定义了一个函数式接口，然后将这个接口作为函数test1()的参数传入。然后再我们使用test1()函数的时候就可以指定不同的函数来做不同的事情。比如说 @Test public void test2() { String str = &quot;Hello World&quot;; test1(str, new A() { @Override public void func(String str) { System.out.println(str.toUpperCase()); } }); } 使用这种方式，我们使用了一个匿名内部类传递了我们需要是使用的函数，使得给定的字符串变成全是大写的。不过之前我们说的是可以使用lambda表达式的方式进行参数式的传递，下面就使用lambda表达式来试一下。 test1(str, s -&gt; System.out.println(s.toLowerCase())); 使用lambda表达式的话只需要一行的代码而且非常的简洁，这里lambda表达式的优点就充分的体现出来了。 不过说实话，这个写法还是非常的扯的，因为我们还定义了一个接口，要是每一个函数都要去定义一个相应的接口，那岂不是要烦死了。不过我们发现了一个问题，这些接口似乎都是通用的。比如说上面的这个接口中需要实现的方法是接受一个参数String，没有返回值的。那么其余的需要这种接口的函数都可以使用这个接口。那么我们需要的接口就是有限的，按理来说标准库是会提供这些接口给我们使用而不是让我们自己去定义的。 四大核心函数式接口果然，Java替我们提供了丰富的函数式接口，都在java.util.function这个包下。不过有四个接口是非常重要的，被称为四大核心函数借口，下面就来一一介绍一下。 函数式接口 参数类型 返回值类型 Consumer T void Supplier none void Function&lt;T, R&gt; T R Predicate T boolean 下面来一一介绍一下上面的四个接口。 Consumer&lt;T&gt; 消费型接口 名副其实，所谓的消费型接口就是接口里面的函数是需要提供一个参数，但是没有任何的返回值。就像我们消费了这个东西一样。 接口里面的抽象方法的格式为void accept(T t) 上面我们使用的那个接口其实就是一个Consumer&lt;String&gt;的一个接口。 Supplier&lt;T&gt;接口型接口 和上面的消费型接口相反，这个接口里面的函数不需要任何的参数，但是会返回一个东西。这个就是典型的雷锋行为啊。 接口里面的抽象方法的格式为T get() Function&lt;T&gt;函数型接口 这个接口应该是最常用的一个接口。他有一个参数，还有一个返回值，参数和返回值的类型不需要是相同的。 接口里面的格式为R apply(T t) Predicate&lt;T&gt;断定型接口 这个接口是给定一个参数，然后返回真假。也是比较常用的一个接口。 接口里面的函数的格式为boolean test(T t) 需要注意的是，上面我给出的每个接口里面的函数的格式并不是瞎给的。至少调用的话不是瞎给的，我们使用这个接口，都需要调用接口中的函数，函数名就是上面的那样，是固定的。 比如我们上面举的例子就可以使用第一个Consumer&lt;String&gt;这样的一个接口。 public void test11(String str, Consumer&lt;String&gt; consumer) { consumer.accept(str); } @Test public void test3() { String str = &quot;Hello Wrold&quot;; test11(str, s -&gt; System.out.println(s.toLowerCase())); } 遮掩我们就可以是用Java已经给我们定义好的接口了，可谓是非常的方便了。 其他的接口也是可以来简单的写个小例子来示范一下的。 public void testSpplier(String str, Supplier&lt;Integer&gt; supplier) { System.out.println(str + supplier.get()); } @Test public void test3() { testSpplier(&quot;Hello&quot;, () -&gt; new Random().nextInt(100)); } public void testFunction(String str, Function&lt;String, String&gt; function) { System.out.println(str + function.apply(str)); } @Test public void test4() { String str = &quot;Hello&quot;; testFunction(str, s -&gt; s.toUpperCase()); } public void testPredicate(int a, Predicate&lt;Integer&gt; predicate) { if (predicate.test(a)) { System.out.println(&quot;&quot; + a + &quot; is a great num!&quot;); } else { System.out.println(&quot;&quot; + a + &quot;is a bad num!&quot;); } } @Test public void test5() { int a = 10; testPredicate(a, s -&gt; (s &amp; 1) == 0); } 上面就是这些接口的使用的方法的一些示例。不过，说实话这个例子都是这种蛮沙雕的例子，完全是没有什么必要的。不过之二十为了演示函数式接口的使用的形式而已。 方法引用上面的函数式接口基本上就讲完了，其实也没有什么需要注意的地方。用起来也非常的容易理解。下面要说的Java8种的一个想你的特性——方法引用。这个东西也是和lambda表达式相关的，也是为了简化我们的代码。 方法引用的意思就是我们可以在需要lambda的地方，使用我们已经定义过的相同的形式的方法。这么说可能是非常难以理解，下面直接上代码进行演示好了。 public class MethodReference { @Test public void test1() { Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); consumer.accept(&quot;Hello World&quot;); } } 我写了如上的代码，但是非常智能的idea给我的System.out.println()标记了打了一个提示，说lambda can be replaced with method reference。那我就听他的话，是用万能的alt + enter快捷键，idea将我的代码修改了 public class MethodReference { @Test public void test1() { Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(&quot;Hello World&quot;); } } 这就是所谓方法引用。System.out.println()这个方法是System.out的一个方法。这个方法已经定义过了。当我们在lambda中使用的时候（值使用这个函数，其他不用），就可以使用方法引用的方式来替代lambda表达式。 @Test public void test2() { Comparator&lt;Integer&gt; comparator = (a, b) -&gt; Integer.compare(a, b); System.out.println(comparator.compare(3, 4)); } 上面的Comparator也是Java中的一个函数式接口，他的实现函数的格式为int compare(T a, T b) 上面的Integer.compare方法也是我们定义过了的方法。所以说上面的lambda表达式也可以修改成为方法引用。 @Test public void test2() { Comparator&lt;Integer&gt; comparator = Integer::compare; System.out.println(comparator.compare(3, 4)); } 上面就是使用方法引用的形式。 不过应该发现了一个问题，上面的System.out::println的::左面是一个PrintWriter对象，但是Integer::compare的左面是一个类。学过C++的应该都知道::的左面应该是类的。虽然Java可能不是的，不过我们也要搞清楚，左面到底应该是什么，是对象还是类？ 不过还是比较容易分析的。println是一个实例方法。而compare是一个对象的方法。众所周知类是不可以调用实例方法的，那么就是说实例方法的左面需要是类，而静态方法的左面类和对象都是可以的吗？就像函数调用那样子一样吗？ 那我们来做一些测试。我们将System.out::println换成了PrintStream::println之后发现报错了。不过也容易理解，没有System.out，我们都不知道往哪儿去输出。 我们再来测试一下使用左面是对象，右面是静态方法的情况。 @Test public void test2() { Integer i = new Integer(3); Comparator&lt;Integer&gt; comparator = i::compare; System.out.println(comparator.compare(3, 4)); } 又失败了。不过这是报错是出乎我们的意料的。对象是可以调用静态方法的啊，那为什么这种失败了呢？这是不是就是意味着方法引用只有如下的两种形式？ 对象::实例方法和类::静态方法。 因为其余的两种形式我们都测试过了。不过经过查阅资料，其上还有一种方式是可行的。类::实例方法也是可行的。 哈？这个也是可行的？不是上面我们已经测试过了吗？不是不可行的嘛？ 其实实例方法的引用是有点儿特殊的。上面的对象::实例方法和类::静态方法都是比较简单。只要满足参数相同，返回值相同就是可以调用的。但是使用类::实例方法不一样。他的参数必须要是调用对象的参数，方法的其他参数。举个例子来说吧。 @Test public void test3() { BiPredicate&lt;String, String&gt; biPredicate = (x, y) -&gt; x.equals(y); System.out.println(biPredicate.test(&quot;hello&quot;, &quot;Hello&quot;)); biPredicate = String::equals; System.out.println(biPredicate.test(&quot;Hello&quot;, &quot;Hello&quot;)); } 比如上上面的代码都是正确的。上面的那个BiPredicate也是java.util.function下面的一个接口。他的实现函数的形式为boolean test(T t, U u) 上面的那个lambda比较容易理解。不过下面的方法引用是不是有点奇怪了？是用的是类::实例方法的形式。关键是equals()方法在类中的声明如下 public boolean equals(String s); 参数是不匹配的。这就是我们需要注意的地方。当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时，可以使用类::实例方法的形式。 也就是PrintStream::println这个函数可以实现的函数式接口为Biconsumer&lt;PrintStream, String&gt;,第一个参数是println函数的调用对象(比如说System.out)。第二个参数是String，就是输出的内容。(也可以是其他可以输出的类型)。 构造器引用和数组引用除了方法引用之外还有构造器引用和数组引用，其实都是一样的不需要再说那么多了也可以轻松的理解。 下面来举一个简单的小例子就行了。 @Test public void test4() { Supplier&lt;A&gt; supplier = () -&gt; new A(); supplier = A::new; Function&lt;Integer, A&gt; function = i -&gt; new A(i); function = A::new; } class A { A() { } A(int a) { } } 其实构造器也是一个方法，如果使用方法引用的话，按道理来说应该写成A::A，不过人家构造器是特殊的方法，当然要有特殊的形式，使用的是xx::new的形式。 还有一种引用是数组引用。这中引用就是比较特殊的了，不过和构造器引用却是比较类似的。比如下面的代码 @Test public void test5() { Function&lt;Integer, String[]&gt; function = s -&gt; new String[s]; function = String[]::new; System.out.println(function.apply(6)); } 这就是数组引用，和构造器引用是有点儿类似的，简单的了解一下就好了。 总结上面介绍的主要是函数式接口和方法引用。这两个东西都是跟随lambda在Java8中被引用的。虽然他们不是Java8种比较重要的特性，不过还是需要做一些了解的。Java8种最重要的特性是lambda和StreamAPI。其中lambda我们已经简单的认识过了，下面还需要了解一下StreamAPI的使用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说枚举]]></title>
    <url>%2F2019%2F10%2F05%2F%E8%AF%B4%E8%AF%B4%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[说说枚举关于前几天好几天都没写博客了，这不是因为这几天国庆放假都在宿舍里面睡觉，而是前几次的研究竟然是研究到了爬虫的领域。导致我又燃起了学习python的欲望，结果学了不少有关python爬虫的内容。本来只是 打算简单的学习一下的，但是我要爬取的网站比如说半次元这个网站，使用的是异步加载的机制(当时我还不知道啥叫ajax和json的异步加载的机制，也不知道这个网站竟然将json文件藏在了js文件中)，所以我就进一步的进行了有关python爬虫的学习，以至于学到了后面的selenuim自动化测试的软件，这还不是最骚的。然后我还是进行了学习，直接学习到了python的爬虫的大型的框架scrapy。学到了这个地方我就感觉应该是比较困难花时间的了，于是简单的学习了一下就放弃了。至于为什么之前学习的python爬虫的内容没有写博家，那当然是因为我对这方面的知识也是一知半解的，根本就搞不透，现在也不想花时间在这个上面，所以说等之后可以花时间研究这个方面上。现阶段还是一学习java为重。 前言枚举这个玩意其实在我而已是蛮没用的东西。从c/c++开始，我们就接触到了枚举这个玩意，不过事实上，我从来都没有使用过枚举这个玩意。我们或许是使用#define xxx xxx或许是使用const xxx xxx = xxx。很少有人去使用枚举这个玩意的。毕竟在c/c++中，枚举也就是int值，我们既然可以使用枚举，也就是可以使用int值来进行替代。而且，不同的枚举之间都是可以比较的，看起来确实是有点儿荒唐。不过Java中的枚举似乎是和我们之前学过的有点儿不一样。因为Java中枚举是一个类，这就避免了不同的枚举类之间荒唐的相互赋值，以及int值对枚举的替代的问题了。 Java中的枚举是什么样子的类？上面我们已经说过了，Java为了避免C/C++那样的问题，将枚举做成了一个类。不过这个枚举到底是一个什么样子的类呢？ 我们可以先来定义一个简单的枚举来测试测试。 enum Season{ SPRING, SUMMER, AUTUMN, WINTER } 使用上面的这种方式，我们就定义了一个季节的枚举。如果这是c++的话，他们四个也就是对应了0 1 2 3。那么在Java中我们可不可以指定给他们对应的int值呢？明显是非法的。 enum Season{ SPRING = 1, SUMMER, AUTUMN, WINTER } 后面全都报错了，这说明在Java中我们是没有办法给枚举赋值的。 那么这个枚举类是如何使用的呢？这个枚举类中的四个枚举似乎是没有修饰符的，是不是想接口那样，给定了默认的修饰符呢？比如说这些属性默认就是public static final的？？？ 我们先来看一下枚举类的使用 public class Demo1 { public static void main(String[] args) { Season s1 = Season.SPRING; Season s2 = Season.AUTUMN; System.out.println(s1 == s2); // false } } 可见我们使用枚举，就像使用枚举类的静态成员变量一样。那么通过上面的代码我们就可以知道了，枚举中的枚举变量的类型应该是public static final Season。至于为什么是final呢？我想这个很容易明白，如果不是final的话。一处被修改了，那么所有的使用这个枚举的类的地方不就都遭殃了吗？而且，似乎我们并没有要修改这个枚举类的必要。 既然我们已经知道了他的限定符了，那么我们是不是就可以想接口那样给他直接加上这些限定符呢？？ 答案是显然不能的，这些枚举似乎不是想接口哪样的值一个定义。这些SPRING已经是有值的了。不过这写玩意是如何实现的呢？当然不是这个枚举类实现的。枚举是一个类，那么他是否有父类呢？ 对了，前面我们使用了==，我们可以使用equals方法看一看。 System.out.println(s1.equals(s2)); 使用idea的方法源码查看，发现这个方法是来自java.lang.Enum这个类的，这就说明了，所有的枚举类都是继承于这个类的，不然怎么可以使用这个类的方法？ java.lang.Enum中的方法还是从官方的文档中看一看这个类。 public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; extends Object implements Comparable&lt;E&gt;, Serializable 这个类的声明似乎是有点儿奇怪，不过看一下他的构战函数。 protected Enum(String name, int ordinal) // 唯一的构造函数。 唯一的构造函数都是私有的说明这个类没有办法被继承的（通过extends方式）。enum声明的类的基础肯定是通过底层实现的。 protected Object clone() // 抛出CloneNotSupportedException。 int compareTo(E o) // 将此枚举与指定的对象进行比较以进行订购。 boolean equals(Object other) // 如果指定的对象等于此枚举常量，则返回true。 protected void finalize() // 枚举类不能有finalize方法。 class&lt;E&gt; getDeclaringClass() // 返回与此枚举常量的枚举类型相对应的Class对象。 int hashCode() // 返回此枚举常量的哈希码。 String name() // 返回此枚举常量的名称，与其枚举声明中声明的完全相同。 int ordinal() // 返回此枚举常数的序数（其枚举声明中的位置，其中初始常数的序数为零）。 String toString() // 返回声明中包含的此枚举常量的名称。 static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(class&lt;T&gt; enumType, String name) // 返回具有指定名称的指定枚举类型的枚举常量。 上面是这个类中的所有的方法。官方文档中对这个类的并没有什么描述，只是说这个类是所有的枚举的公开基类。下面我们就通过上面的这些方法来研究一下Java中枚举。 可以看到上面的方法都是子类中可以使用的。 第二个方法令我比较好奇，既然枚举不和int值挂钩，又是如何实现比较的呢？ System.out.println(s1.compareTo(s2)); // -2 输出-2。嗯，这个倒是和c/c++中一摸一样。不会枚举的内部也是对四个属性进行0 1 2 3这样的排序的吧。瞎的我感觉看了一下这个方法的源码。 public final int compareTo(E o) { Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } 上面的那么多是用来判断是否是一个枚举类的。不同的枚举类之间是不能够进行比较的。不过关键是最后一行代码。 return self.ordinal - other.ordinal; ordinal是序数的意思，看来我们猜想的是对的，在枚举的内部也还是将枚举和一个int值挂钩的。我们可以看到方法的列表中也是有int ordinal()方法的。 System.out.println(s1.ordinal()); // 0 System.out.println(s2.ordinal()); // 2 完全符合我们的猜想。也就是这个序数其实就是枚举中声明的序数。不过我们是否是可以改变这个序数呢？就像c/c++中我们做的那样一样。（虽然这个是完全没有一意义的）这个问题我们可以在下面再讨论。 我们继续来看枚举类的方法。 首先一眼看到的方法就是toString()方法。这个方法是Object中就有的，声明如下 public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); } 枚举类中将这个方法从重载了，我们可以实验一下会输出什么东西。 System.out.println(s1); // SPRING 输入的就是我们给定的枚举类的名字。这又是如何实现的呢？再来看一下这个方法的源码的实现。 public String toString() { return name; } 上面也有一个方法叫name()看来和ordinal一样这个属性也被枚举类给保存下来了。 还有一个方法是我们需要了解的。valueOf System.out.println(Season.valueOf(&quot;SPRING&quot;) == Season.SPRING); // true 作用是返回和这个名字相同的枚举变量。上面我们已经知道了，这个名字其实就是name属性。这里的比较使用的==，其实使用equals()也是一样的。毕竟这个枚举的都是唯一实例，无论是比较内容还是地址都是一样的。何况这个类中的equals()方法都相当于没有重载。==与equals是一样的。 public final boolean equals(Object other) { return this==other; } 其实还有一个很重要的方法，是父类没有的。就是values()方法。这个方法的作用是返回枚举类中的所有的枚举变量。 Season[] seasons = Season.values(); for (Season season : seasons) { System.out.println(season); } // SPRING // SUMMER // AUTUMN // WINTER 根据推测方法的声明可能是这样子的。 public Season[] values(); 数组中枚举的顺序就是他们ordinal的顺序。 这让我想到一个问题，既然valueOf方法可以通过name属性获取到枚举值，我们是否可以通过ordinal属性来获取属性的值呢？很遗憾，Java中并没有提供这样的函数，不过我们可以通过values方法来写一个这样的方法。 枚举中的方法其实上面我们一直在谈的都是枚举中的方法。不过我们似乎谈论的大多是枚举类中自带的方法。那我们是否可以在其中写一些方法呢？当然是可以的。比如上面我们说到的通过ordinal属性来获取枚举值。 enum Season{ SPRING, SUMMER, AUTUMN, WINTER; // there is ; public static Season valueOf(int ordinal) { Season[] seasons = values(); if (ordinal &lt; 0 || ordinal &gt;= seasons.length) { throw new IndexOutOfBoundsException(&quot;Ordinal is out of range!&quot;); } return seasons[ordinal]; } } 第一个点需要注意的是枚举变量之间使用的逗号相隔。如果我们要在枚举中写方法的时候，我们需要使用一个分号想方法和定义的枚举型变量隔开。 上面就像使用类一样定义了一个方法。而且经过测验之后也是满足我们的需求的。既然我们可以在枚举类中定义自己的方法。那么自己的属性也必然是可以的。只要在分号的后面就可以了。不仅如此，我们还可以重载枚举中的方法。比如toString()方法。 @Override public String toString() { return &quot;my toString: &quot; + super.toString(); } 这样我们便override了toString方法。 现在我们再回到上面的问题来，valueOf(int ordinal)方法对不对呢？看起来是对的。因为ordinal就是从0开始的。在java.lang.Enum中，ordinal的定义如下 private final int ordinal; 也就是ordinal一经初始化之后便不可以被修改了。不过我们是否可以操作一下ordinal的初始化呢？ 枚举变量的构造函数前面我们一直都忽略了一个细节，那就是java.lang.Enum的构造函数。我们继续来观察一下。 protected Enum(String name, int ordinal) // 唯一的构造函数。 这个构造函数有两个参数name和ordinal。嗯？是不是有点儿熟悉~~那么我们是否可以通过构造函数指定枚举变量的name和ordinal呢？ 看起来是不可以的，我们似乎都接触不到这个构造函数。而且ordinal在java.lang.Enum中的声明是私有的，我们更不可能修改到这个ordinal属性了。不过我们是否是可以修改name属性呢？相同的，我们也是不可以的。因为没有构造函数，属性还是私有的。可见这个方法是正确的。 不过枚举类是否可以拥有自己的构造函数呢？ private String name; private int ordinal; Season(String name, int ordinal) { this.name = name; this.ordinal = ordinal; } 我们发现是真的可以的，构造函数并没有报错，但是上面的那些枚举变量却报错了。经过查阅资料，我们需要使用如下的形式来调用构造函数。 SPRING(&quot;春天&quot;,1), SUMMER(&quot;夏天&quot;,2), AUTUMN(&quot;秋天&quot;,3), WINTER(&quot;冬天&quot;, 4); 原来如此，如果我们在后面没有使用括号，也就是一开始的写法的话就是调用无参的构造函数，如果有参数的话就会寻找相应的参数的构造函数。也就是说其实枚举就是这样的一个普通的类。 class Season extends java.lang.Enum{ public static final Season SPRING = new Season(&quot;春天&quot;,1); public static final Season SUMMER = new Season(&quot;夏天&quot;,2); public static final Season AUTUMN = new Season(&quot;秋天&quot;,3); public static final Season WINTER = new Season(&quot;冬天&quot;,4); private String name; private int ordinal; Season(String name, int ordinal){ this.name = name; this.ordinal = ordinal; } } 上面只是实现的一个例子，我们自然是不可以写出这样的类的。首先继承java.lang.Enum就是一个不可能的事情。不过上面的代码清晰的表现了枚举类的简单的原理。这里我没有使用反编译。毕竟我也不会反编译的手段。不过不使用反编译，我们也可以大概猜出枚举类的结构了。 不过，还有一个非常大的问题。上面的枚举类中我没有使用限定符access modifier。没有使用限定符那么就是default，也就是包可访问的。那么我们可以在类外使用枚举类的构造函数？ Season s = new Season(&quot;xxx&quot;,5); 报错了，报错信息显示这个构造函数是access private的，这里不可以访问。 可见，枚举类的构造函数必然是private的。就比如接口中的函数，即使是什么限定符都不加，他也是public abstract的，这里的构造函数如是。 枚举的继承以及枚举中的抽象函数枚举是继承java.lang.Enum的。这就决定了枚举是不可以继承其他类的，同样的其他类也是不可以继承枚举的。(至于为什么，这不用说也应该可以明白吧)。 不过，虽然枚举类不可以被继承，但是枚举类中，还是允许存在抽象的方法的。这就很令人不解了？既然不可以被继承，那么抽象方法的意义何在呢？ 当我们写下了这个抽象方法的时候，编译器给了一个提示。 class ”Season“ must either be decleared abstrace or implememt abstract method “func” in Season 不过当我使用abstract enum Season的时候他说abstract is not allowed here那这个的意思是自己要实现自己定义的抽象的方法。这也太没道理了吧。 不过更没想到的是，原来是需要这样去实现抽象方法的。 SPRING(&quot;春天&quot;,1){ @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, SUMMER(&quot;夏天&quot;,2){ @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, AUTUMN(&quot;秋天&quot;,3) { @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, WINTER(&quot;冬天&quot;, 4) { @Override public void func() { System.out.println(&quot;Season.func&quot;); } }; 也就是说需要枚举类的属性来实现这个抽象的方法。这个形式，是不是有一点眼熟，没错就是匿名内部类的格式。这些函数在外面都是可以调用的。比如说Season.SPRING.func()。 这个东西之前我们说过的其实匿名函数实现接口，内部是产生了一个类。那么上面的实现抽象函数的过程中是否产生了新的类呢？ 我们可以在func()使用getClass()方法。 class com.sher.enumDemo.Season$1 看来果然是产生一个新的类。哇~，这个枚举中的奥秘也太多了吧。 System.out.println(Season.SPRING.getClass()); // class com.sher.enumDemo.Season$1 System.out.println(Season.AUTUMN.getClass()); // class com.sher.enumDemo.Season$3 在我们之前没有使用抽象函数，以及实现的时候。使用上面的函数输出是 System.out.println(Season.SPRING.getClass()); // class com.sher.enumDemo.Season System.out.println(Season.AUTUMN.getClass()); // class com.sher.enumDemo.Season 正是由于实现了抽象函数所以才产生新的类的。不过这里又来了一个问题。Season.SPRING和Season.AUTUMN的类型不一样了，一个是Season$1,一个是Season$3。按照我们之前的说法，不同的类之间是不可以比较的，因为他们都不是同一个枚举类了。之前似乎说过了一个函数compareTo()，还看过了这个的源码，现在我们在来看一看。 public final int compareTo(E o) { Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; } 上面判断的时候，使用了getDeclaringClass()这个函数。而Season$!和Season$3的DeclaringClass都是Season，原来是用这种方式保证枚举的相同类型的。所以说，如果我们要看枚举类型是否相同，其实看getDeclaringClass()就行了，毕竟如果getClass()想同，getDeclaringClass()也是相同的。 枚举与接口虽然我们说由于Java中单继承的机制，枚举是无法继承其他的类的，但是Java中对与接口的实现是没有限制的，所以说枚举类还可以实现接口。不过这里需要注意的是，并不是枚举这个类要实现接口中的函数，而是枚举中每一个枚举变量要实现接口中的函数。比如说有一个接口A interface A{ void aFunc(); } enum Season implements A{ SPRING(&quot;春天&quot;,1){ @Override public void aFunc() { System.out.println(&quot;Season.aFunc&quot;); } @Override public void func() { System.out.println(&quot;Season.func&quot;); System.out.println(this.getClass()); } }, SUMMER(&quot;夏天&quot;,2){ @Override public void aFunc() { System.out.println(&quot;Season.aFunc&quot;); } @Override public void func() { System.out.println(&quot;Season.func&quot;); } }, // ... 可见枚举中接口的实现是和普通的类不一样的。 除此之外，枚举和接口还有另外的一个搭配。那就是在接口中组织枚举。 这个挺起来似乎是有点儿荒唐，接口中怎么能有枚举呢？不过确实如此，可以有这样的语法。 如果我们需要将枚举类进行分组的话就可以使用这种方式。比如食物是一个枚举中的大类别，其中又可以分为甜的，酸的，辣的等等等。又比如说班级中中国学生，也有外国学生，我们想要保留他们都是学生的这个共同属性而又想要分别枚举就可以使用接口来组织枚举。 interface Student { enum ChineseStudent implements Student { ZHANG3(1), LI3(2), WANG5(3); @Override public boolean same(Student s) { if (s instanceof ChineseStudent) { return true; }else { return false; } } ChineseStudent(int a){ } @Override public void printName() { System.out.println(this.name()); } }; enum ExchangeStudent implements Student { JACK, MIKE, TOM; @Override public boolean same(Student s) { if (s instanceof ExchangeStudent) { return true; }else { return false; } } @Override public void printName(){ System.out.println(this.name()); } } boolean same(Student s); void printName(); } 其中接口中的方法，每一个枚举类中都要实现。这里的接口实现和枚举类实现接口那样，不再是每一个属性都要实现了。通过这种方式，中国学生和交换什都保有了Student这样的一个共同的属性，而且还是分别的枚举了。 和普通的接口一样，这个接口也可以被实现。不过只需要实现接口中的那两个函数就行了。 class B implements Student { @Override public boolean same(Student s) { return false; } @Override public void printName() { } } 不过需要注意的是，这时的枚举可以通过上面的类B访问到。比如 Student s = B.ChineseStudent.ZHANG3; 上面就是使用接口来组织枚举的简单的用法，至于更复杂的用法，这里暂时就不做更多的了解了。 枚举与单例模式前面我们介绍了单例模式，在我们学习内部类的时候，我也提到了使用静态内部类的方式来实现单例模式的懒加载。不过在我们详细的谈论单例模式的时候，我们还谈到了一种使用枚举来实现的单例模式。 public class SingletonTest04 { public static void main(String[] args) { Singleton04 singleton1 = Singleton04.INSTANCE; Singleton04 singleton2 = Singleton04.INSTANCE; System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } enum Singleton04 { INSTANCE; } 这种方式是真的简单又粗暴。不仅可以解决多线程的同步问题，也可以防止反序列化创建新的对象。这种方式也是《Effect Java》中推荐的方式。不过这个代码也是有一定的问题的，比如说无法进行懒加载。如果一点问题都没有，这个单例模式可不是十全十美了嘛~~ 总结上面算是对Java中的枚举类的一个比较全面的一个学习了。不过都基本上是简单的介绍，并没有深入底层追究一些细节上面的东西，毕竟那玩意放到现在来说确实是有点儿复杂了。 主要参考文章:重新认识java（十） —- Enum（枚举类）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用lxml和bs4进行爬虫]]></title>
    <url>%2F2019%2F10%2F02%2F%E4%BD%BF%E7%94%A8lxml%E5%92%8Cbs4%E8%BF%9B%E8%A1%8C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[使用lxml和bs4进行爬虫前言前面其实是学Java的过程中学到正则表达式的，然后结合之前学的IO流来练习一下使用Java进行爬虫。而且我们使用的爬虫的工具还是python爬虫三大工具中最难的——正则表达式。这就让我有点好奇还有两个爬虫的工具是怎么用的了。这里就使用上次的爬虫的例子来简单的介绍一下吧。 使用lxml其实这个东西应该是叫XPath吧，其实我也不是很清楚，不过用起来还是蛮简单的，尤其是学过了一点点前端之后。使用lxml和bs4真的是如鱼得水，好用得不得了。 之前我们使用python进行爬虫的时候使用的是urllib.request这个库，不过现在requests应该是最适合的，因为requests库的api非常的人性化而且也非常的好用。不过问题就是这个库是需要我们去下载的，原生的python是没有这个库的。我们可以使用pip install requests或者python -m pip install requests来安装这个库。lxml也是如此，我们可以使用上面相同的方式来获取到这个库。因为只是简单的介绍，所以我也不会有过多的说明，所以说直接上代码吧。 首先看一下requests的使用。 HEADERS = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } def getUrlText(url): response = requests.get(url, headers=HEADERS) text = response.content.decode(&quot;utf-8&quot;) return text 我们再重新来看一下urllib.request的使用 def getUrlContent(url): headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } req = request.Request(url, headers = headers) resp = request.urlopen(req) urlContent = resp.read().decode(&#39;utf-8&#39;) return urlContent 可以看到requests库的确是方便多了。 requests.get值得就是向目标url发出get请求，相同的requests.post就是发出post请求，这一点上比urllib中的容易理解。对于相应后的返回值，有两个方法是需要注意一下的。response.content返回的是字节码，我们可以通过观察网站的charset手动调用decode()方法进行解码。还有一个方法是response.text返回是字符串，是python通过猜测给我们解的码，所以说这个方法很有可能会出现乱码(真的是一个弟弟方法)，所以说我个人还是习惯于使用response.content。 既然目标网站的源代码我们已经搞过来了，下面一步就是来提取有用的信息了，之前使用的是正则表达式，这里使用lxml。 def getImgSrc(text): html = etree.HTML(text) div = html.xpath(&quot;//div[@class=&#39;content_nr&#39;]&quot;)[0] srcs = div.xpath(&quot;.//img/@src&quot;) return srcs 就简单的几行代码。第二行代码使用etree来加载这个源代码。(其实是lxml.etree，只不过我们使用了from lxml import etree而已)，然后返回了一个对象。我们可以对这个对象使用xpath语法。 下面就简单的说说xpath语法。 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()&lt;3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=’eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 通过在路径表达式中使用“|”运算符，可以选取若干个路径。 上面就是XPath的一些简单的语法。下面就看着这些语法来看看下面的两行代码。 div = html.xpath(&quot;//div[@class=&#39;content_nr&#39;]&quot;)[0] //div[@class=&#39;content_nr&#39;]是选取class属性为content_nr的div节点，虽然这个节点在网站上只有一个，不过依旧还是返回一个列表。我们也可以在XPath选取的时候就选择第一个，不过要注意的是，这个位置竟然是从1开始的。不过这里我们是不可以写到里面去的，因为里面我们已经加上了一个class 的限定条件了，不可以在后面继续使用[]表示第几个了。 srcs = div.xpath(&quot;.//img/@src&quot;) 我们已经得到了存放许多图片链接的div，其中图片的链接都是在div里面的img标签的src属性下。 这是我们使用的是.//img而不是//img，这是因为此时指定XPath的已经不是html了而是我们选取的div，如果还是使用//img，那么还是会选取到网页中的所有img标签。后面的/@src指的就是选取img标签的src属性，返回值也是一个列表，是一个src里面地址字符串的列表，这就很舒服了~~ 下面下载图片的事情就简单了。 def urlRetrieve(url, destFilename): with open(destFilename, &#39;wb&#39;) as f: f.write(requests.get(url, headers=HEADERS).content) def downloadImgs(srcs, destDir): if not os.path.exists(destDir): os.makedirs(destDir) if not os.path.isdir(destDir): print(&#39;Error!! You must provide a Dir&#39;) exit() for i, src in enumerate(srcs): filename = os.path.join(destDir, str(i)+&#39;.&#39;+src.split(&#39;.&#39;)[-1]) urlRetrieve(src, filename) 模仿urllib库，我写了一个urlRetrieve函数(原函数是urllib.urlretrieve)。所谓下载图片就是将content字节流通过二进制的形式写入到文件当中就行了。 最后再把这些函数串起来就完事了。 def spider(url, destDir): text = getUrlText(url) srcs = getImgSrc(text) downloadImgs(srcs, destDir) 这样爬取单页的操作就完成了。其他的操作都是类似的，这里就不再研究了，只是简单介绍一下而已啦。 使用bs4bs4也是一个扩展库，需要我们使用pip install bs4或者python -m pip install bs4来安装，不过如果你安装了anaconda的话，上面的这些库你都不需要安装。直接自带的！~ bs4的使用和上面的lxml其实是差不多了。至于代码除了getImgSrc之外其余的代码都是相同的。所以说我们看一下getImgSrc()函数就完事了。 def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) div = soup.find_all(&#39;div&#39;, class_ =&#39;content_nr&#39;)[0] imgs = div.find_all(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs 在代码的开始我们使用from bs4 import BeautifulSoup导入这个库。 上面的第二行就是使用lxml解析器将网页的源代码解析成一个。。emm美味的汤？？算了，不管了，上面就是将源代码中的html代码整合成为一种树结构，便于后面的使用。 div = soup.find_all(&#39;div&#39;, class_=&#39;content_nr&#39;)[0] 就是寻找所有class属性为content_nr的标签，返回一个列表。至于为什么是class_是因为class在python中是保留字(类名)，不可以使用。不过我们也可以使用div = soup.find_all(&#39;div&#39;, attrs = {&#39;class&#39;:&#39;content_nr&#39;})这种方式。这时候我们就可以使用class了，因为这里的class是一个字符串。 imgs = div.find_all(&#39;img&#39;) 找到div所有的img标签 srcs = [img[&#39;src&#39;] for img in imgs] img[&#39;src&#39;]是获取img标签的src里面的值，使用上面的那种方式，可以将img标签列表转为一个src列表。其实获取属性还可以使用img.attrs[&#39;src&#39;]的方式，不过这个也是有点儿没事找事了。既然可以少写一点，为什么不少写一点呢？ 其实除了find_all()函数之外，BeautifulSoup还提供了CSS选择器的方式。上面的函数的代码还可以这样写。 def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) div = soup.select(&#39;div.content_nr&#39;)[0] imgs = soup.select(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs 使用CSS选择器也是一个蛮不错的方式。 还有一点需要注意的是，如果网页的代码非常不规范，使用lxml解析器会报错的话，我们可以使用容错性更高的解析器。不过效率肯定是更低了。 soup = BeautifulSoup(text, &#39;html5lib&#39;)。使用这也是需要安装html5lib这个库的，正如使用lxml解析器也需要安装lxml库。 下面给出完整的代码。 import requests import os from bs4 import BeautifulSoup HEADERS = { &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } def urlRetrieve(url, destFilename): with open(destFilename, &#39;wb&#39;) as f: f.write(requests.get(url, headers=HEADERS).content) def getUrlText(url): response = requests.get(url, headers=HEADERS) text = response.content.decode(&quot;utf-8&quot;) return text def getImgSrc(text): soup = BeautifulSoup(text, &#39;lxml&#39;) # div = soup.find_all(&#39;div&#39;, class_ =&#39;content_nr&#39;)[0] # div = soup.select(&#39;div.content_nr&#39;)[0] div = soup._find_all(&#39;div&#39;, attrs = {&#39;class&#39;:&#39;content_nr&#39;})[0] # imgs = div.find_all(&#39;img&#39;) imgs = div.select(&#39;img&#39;) srcs = [img[&#39;src&#39;] for img in imgs] return srcs def downloadImgs(srcs, destDir): if not os.path.exists(destDir): os.makedirs(destDir) if not os.path.isdir(destDir): print(&#39;Error!! You must provide a Dir&#39;) exit() for i, src in enumerate(srcs): filename = os.path.join(destDir, str(i)+&#39;.&#39;+src.split(&#39;.&#39;)[-1]) urlRetrieve(src, filename) def spider(url, destDir): text = getUrlText(url) srcs = getImgSrc(text) downloadImgs(srcs, destDir) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/78680.html&#39; destDir = &#39;testBs4&#39; spider(url, destDir) 总结对于介绍的三种的数据提取的库，基本上可以这么说。 方式 速度 难度 Regex 最快 最难 lxml/XPath 一般 一般 BeautifulSoup 最慢 最易 不过也不出乎我的意料，哪有什么简单又快的呢？就像python一样，你觉得使用起来难度最小，速度肯定也是较慢的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用正则表达式来爬虫]]></title>
    <url>%2F2019%2F10%2F01%2F%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9D%A5%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[使用正则表达式来爬虫前言在上面我们简单的了解了一下正则表达式的使用。其中最后的一个例子中我们讲的是使用正则表达式来匹配html中标签。我们或许可以使用这个功能来干一件大事——使用Java来爬一个简单的虫。这个是不需要任何库的那种，就是用Java中的IO流和强大的正则表达式。不过，我们需要爬取什么样子的网站呢？一开始就想到了我最爱的网站bilibili。那么说干就干吧。来爬一下bilibili。 爬取哔哩哔哩的失败URL url = new URL(&quot;http://www.bilibili.com&quot;); url.openStream(); 虽然上面的代码是没有写全的。不过现在代码已经是出错的了。要么是b站返给我一个极短的没有用的html代码，要么就是直接给我一个403 Error，403错误代表的是访问权限不足，拒绝访问。 有着python爬虫经验的我，一下子就想到了这特喵的肯定是User-Agent的问题，不过如果配置Java中的User-Agent却是一个问题，而且我爬b站好像没啥用啊。我突然想到我玻璃的封面的图片的来源地——萌娘资源站。每次我去里面搞图片的时候都是一张一张的右键另存为，这很是头疼！！经过我的访问，我发现这个网站竟然没有任何的反爬措施，果然小网站就是小网站啊，就决定是你了！！ P.S.: 后来我查阅了资料，找到了Java中设置User-Agent的方式，果然好烦啊！爬虫还是python好。。。 try { URL url = new URL(&quot;https://www.bilibili.com&quot;); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &quot; + &quot;(KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&quot;); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line = null; while ((line = reader.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } 爬取单页所有图片虽然我先把这个网址连的所有的图片全都爬取下来，但是咋还是得一步一步的来。首先下载一张图片这种操作应该就不用写了，所以就从爬取单页的所有的图片开始入手吧。 于是我从这个网页开始入手http://moe.005.tv/78680.html分析网页的结构。 首先，我们需要爬取的是图片。HTML应该都是学过的，图片的地址就是在&lt;img&gt;标签的src属性下。通过查看源代码和使用开发者检查工具，我发现了我想要爬取的内容源代码是这样子的。 &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150225T5.jpg&quot; style=&quot;width: 600px; height: 705px;&quot; /&gt;&lt;br /&gt; ID=76539261&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ215025Wc.jpg&quot; style=&quot;width: 600px; height: 920px;&quot; /&gt;&lt;br /&gt; ID=76539275&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150310O3.jpg&quot; style=&quot;width: 600px; height: 849px;&quot; /&gt;&lt;br /&gt; ID=76539289&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150322Z9.png&quot; style=&quot;width: 600px; height: 839px;&quot; /&gt;&lt;br /&gt; ID=76539340&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ21503334W.jpg&quot; style=&quot;width: 600px; height: 848px;&quot; /&gt;&lt;br /&gt; ID=76539357&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150419601.jpg&quot; style=&quot;width: 600px; height: 424px;&quot; /&gt;&lt;br /&gt; ID=76539479&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150434115.jpg&quot; style=&quot;width: 600px; height: 414px;&quot; /&gt;&lt;br /&gt; ID=76539479&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150449D4.jpg&quot; style=&quot;width: 600px; height: 424px;&quot; /&gt;&lt;br /&gt; ID=76540552&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150501231.jpg&quot; style=&quot;width: 600px; height: 896px;&quot; /&gt;&lt;br /&gt; ID=76546567&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150513612.jpg&quot; style=&quot;width: 600px; height: 600px;&quot; /&gt;&lt;br /&gt; ID=76549801&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150523104.jpg&quot; style=&quot;width: 600px; height: 847px;&quot; /&gt;&lt;br /&gt; ID=76557430&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ2150533627.png&quot; style=&quot;width: 600px; height: 891px;&quot; /&gt;&lt;br /&gt; ID=76563726&lt;br /&gt; &lt;br /&gt; &lt;img alt=&quot;初音未来&quot; src=&quot;http://www.005.tv/uploads/allimg/190902/66-1ZZ21505431R.jpg&quot; style=&quot;width: 600px; height: 718px;&quot; /&gt;&lt;br /&gt; ID=76573133&lt;br /&gt; 可以看到是一个单标签。其中我们真正需要的内容就是里面的src的网址，有了这些网址就相当于有了图片。 爬取网页的源代码不过首先我们需要的是来下载这个网站的源代码。之前也说过了这个网页是没有反爬虫措施的，所以我们可以直接进行访问下载。 private String getUrlContent() { BufferedReader br = null; StringBuilder sb = new StringBuilder(); try { br = new BufferedReader(new InputStreamReader(url.openStream())); String line = null; while ((line = br.readLine()) != null) { sb.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } return sb.toString(); } 上面就是一个简单的IO流的操作，其实应该是写成一个工具类的，毕竟后面的代码中还要用到这个方法。不过已经写完了那就无所谓了。 使用正则表达式匹配链接上面的网页的源代码已经获得了，那么就需要使用到之前所学的正则表达式的知识匹配我们要的字符串了。 这里我写的表达式为&lt;img[^&gt;]*src=\&quot;(.+?)\&quot;.*?/&gt; 我将我要获取的连接放在了一个捕获组中(.+?)那么匹配玩之后我们就可以直接获取这个链接了。 关于上面的表达式其实还有一个问题，为什么我写的表达式这么简洁，不会匹配到其他的没有用的图片吗？还真的不会，我发现其他的无关的图片虽然前面多事满足的，但是结尾都是没有/的就是&lt;img ...&gt;。所有的我需要的图片都是&lt;img ... /&gt;类型的，所以说这就很舒服的嘛！ private List&lt;String&gt; getImgUrl() { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); String urlContent = getUrlContent(); Pattern pattern = Pattern.compile(&quot;&lt;img[^&gt;]*src=\&quot;(.+?)\&quot;.*?/&gt;&quot;); Matcher matcher = pattern.matcher(urlContent); while (matcher.find()) { String urlImg = matcher.group(1); if (urlImg.contains(&quot;dilidili&quot;)) { break; } if (urlImg.matches(&quot;http://.+?.(jpg|png)&quot;)) { list.add(urlImg); } } return list; } 上面我使用了一个List来存放这些图片的链接。不过需要注意的是，链接中有dilidili的链接都是无法访问的，所以说直接剔除就好了。(莫非dilidili凉了？？) 下载图片上面已经获取到了所有的图片的连接了，下面只要运用之前学的IO流的知识来下载图片就行了。 public void downloadImg() throws Exception { List&lt;String&gt; list = getImgUrl(); int i = 1; BufferedOutputStream bos = null; BufferedInputStream bis = null; for (String img : list) { String suffix = img.substring(img.length() - 4); File file = new File(dest, &quot;&quot; + i + suffix); bos = new BufferedOutputStream(new FileOutputStream(file)); bis = new BufferedInputStream(new URL(img).openStream()); byte[] buffer = new byte[1024]; int cot; while ((cot = bis.read(buffer))!=-1) { bos.write(buffer,0, cot); } bos.flush(); System.out.println(&quot;Download Complete: The &quot;+i+&quot; Img&quot;); i++; } bis.close(); bos.close(); } 首先是文件名字的问题，既然网站上也没有名字，那我就直接使用数字命名大法吧，问题应该不大。 还有一个问题就是文件的后缀名的问题，经过上面的观察，这些图片不是jpg格式就是png格式，那么我只需要取最后的四位就可以得到图片的类型了。 后面就是IO流的操作了，这里就不说了。 爬取一整页的图片经过我的观察这个网站中的源代码的格式基本上都是一模一样的。（那肯定的啊，没有框架写个锤子的网站）经过上面的努力，现在给我们任何一页的的链接，我们就可以下载这一页中的所有的图片。 于是现在我们的任务就是获取一整页中所有页的链接。还是之前获取图片的链接那样一样的操作。观察一下网页中我们需要的部分的源代码。 &lt;a href=&quot;http://moe.005.tv/78680.html&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;zt_pic&quot; style=&quot;background-image:url(http://www.005.tv/uploads/190902/66-1ZZ2151605B7.jpg);&quot;&gt;&lt;img src=&quot;http://www.005.tv/uploads/190902/66-1ZZ2151605B7.jpg&quot;&gt;&lt;em&gt;初音未来插画图片&lt;/em&gt;&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;zt_dep&quot;&gt; &lt;strong&gt;&lt;a href=&quot;http://moe.005.tv/78680.html&quot;&gt;初音未来插画图片&lt;/a&gt;&lt;/strong&gt; &lt;dl&gt; &lt;dt&gt;2019-09-02&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont&quot;&gt;&lt;/i&gt;68&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;初音未来插画图片...&lt;/p&gt; &lt;/span&gt; &lt;/li&gt;&lt;li&gt; &lt;a href=&quot;http://moe.005.tv/78638.html&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;zt_pic&quot; style=&quot;background-image:url(http://www.005.tv/uploads/190822/66-1ZR2143A1X1.jpg);&quot;&gt;&lt;img src=&quot;http://www.005.tv/uploads/190822/66-1ZR2143A1X1.jpg&quot;&gt;&lt;em&gt;【今日P站】热门插画0822&lt;/em&gt;&lt;/span&gt;&lt;/a&gt; &lt;span class=&quot;zt_dep&quot;&gt; &lt;strong&gt;&lt;a href=&quot;http://moe.005.tv/78638.html&quot;&gt;【今日P站】热门插画0822&lt;/a&gt;&lt;/strong&gt; &lt;dl&gt; &lt;dt&gt;2019-08-22&lt;/dt&gt; &lt;dd&gt;&lt;i class=&quot;iconfont&quot;&gt;&lt;/i&gt;3704&lt;/dd&gt; &lt;/dl&gt; &lt;p&gt;【今日插画】P站热门插画0822...&lt;/p&gt; &lt;/span&gt; &lt;/li&gt;&lt;li&gt; 上面是网页的源代码的一部分。观察一下，我们需要的链接在两个地方都出现了，上面的&lt;a href=&quot;&quot;&gt;中有我们需要的链接，下面的&lt;strong&gt;中的&lt;a href=&quot;&quot;&gt;也有我们需要的内容。不过下面的a中还有我们更想要的东——图片的名字。这么说或许有点儿不妥，应该说是文件夹的名字，这里图片是没有名字的。 爬取网页的源代码的操作和上面就是一模一样的，所以这里不再赘述。 使用正则表达式匹配链接这里我使用的正则表达式是&lt;strong&gt;&lt;a href=\&quot;(http://moe.005.tv/\\d{5}\\.html)\&quot;&gt;(.*?)&lt;/a&gt;&lt;/strong&gt; 这里因为我需要的有网页的链接还有名字这两个属性，所以我使用了两个捕获组，而且为了防止误匹配，其实链接的变化只是后面的五个数字，所以我直接精确的进行匹配，不搞那些.*了。 private void getLink() { List&lt;String&gt; list = new ArrayList&lt;&gt;(); String urlContent = getUrlContent(); Pattern pattern = Pattern.compile(&quot;&lt;strong&gt;&lt;a href=\&quot;(http://moe.005.tv/\\d{5}\\.html)\&quot;&gt;(.*?)&lt;/a&gt;&lt;/strong&gt;&quot;); Matcher matcher = pattern.matcher(urlContent); while (matcher.find()){ linkList.add(matcher.group(1)); nameList.add(matcher.group(2)); } } 这里用了两个List，不过没法返回两个List。我就将这两个LIst作为私有属性而不是函数的返回值。 下载整页图片上面我们已经获取了每一页的链接以及名字，我们就可以利用上面写好了的下面单页用的类进行下载了。这真的棒棒哒！ public void downloadImg() { getLink(); for (int i = 0; i &lt; linkList.size(); i++) { SpiderImg splitImg = new SpiderImg(linkList.get(i), dest+&quot;/&quot;+nameList.get(i)); try { System.out.println(&quot;=====Download Start: &quot;+nameList.get(i)+&quot;=====&quot;); System.out.println(); splitImg.downloadImg(); System.out.println(&quot;=====Download Complete: &quot;+nameList.get(i)+&quot;=====&quot;); System.out.println(); } catch (Exception e) { e.printStackTrace(); } } } 下载全站？？上面我们已经完成了一页的下载，那么下面我们的目标是？？？下载全站的资源？？额，，，这个确实是有点儿过分了。不过我们可以想想如果硬盘和时间允许的情况下是否是可以的。 观察一下每一整页的链接。 第一页http://moe.005.tv/moeimg/tb/list_3_1.html 第二页http://moe.005.tv/moeimg/tb/list_3_2.html …… 第五十页http://moe.005.tv/moeimg/tb/list_3_50.html 观察一下第五十页的源代码，基本没有任何的变化。emm，，我感觉我真的可以下载全站。总共有126页。。。emm，算了算了。 public class SplitMorePage { public static void main(String[] args) { int n = 10; for (int i = 1; i &lt;= n; i++) { System.out.println(&quot;!!!!!Now Downloading The &quot; + i + &quot; Page, Sum of &quot; + n + &quot;Page!!!!!&quot;); String url = &quot;http://moe.005.tv/moeimg/tb/list_3_&quot; + i + &quot;.html&quot;; SpiderPage spider = new SpiderPage(url, &quot;D:/JavaSpider/Page3_&quot; + i); spider.downloadImg(); System.out.println(&quot;!!!!!The &quot; + i + &quot; Page Download Complete,Sum of &quot; + n + &quot;Page!!!!!&quot;); } } } 我下载了几页试了一下，发现已经下载了一千多张图片了，也占用了很大的空间。emm，，一百多页，，算了算了不爬了！ 使用Python上面使用Java爬虫确实是有点儿繁琐的用了将近二百行的代码。说起爬虫这种玩意，可以说是Python的天下啊。那么我就简单的使用python来还原一下上面的Java一样的操作。 这里使用的是urllib.request库，没有使用requests库。 爬取单页所有的图片from urllib import request import re import os def getUrlContent(url): headers = { &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#39; } req = request.Request(url, headers = headers) resp = request.urlopen(req) urlContent = resp.read().decode(&#39;utf-8&#39;) return urlContent def getImgUrlList(urlContent): pattern = re.compile(r&#39;&lt;img[^&gt;]*src=&quot;(.+?)&quot;.*?/&gt;&#39;) imgUrlList = pattern.findall(urlContent) return imgUrlList def downloadImg(imgUrl, cot, dest): suffix = imgUrl[-3:] request.urlretrieve(imgUrl, dest+str(cot)+&#39;.&#39;+suffix) def downloadImgs(imgUrlList, dest): if not os.path.exists(dest): os.makedirs(dest) for cot,imgUrl in enumerate(imgUrlList): if &#39;dilidili&#39; in imgUrl: continue else: downloadImg(imgUrl, cot+1, dest) cot += 1 def download(url, dest): urlContent = getUrlContent(url) imgUrlList = getImgUrlList(urlContent) downloadImgs(imgUrlList, dest) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/78680.html&#39; dest = &#39;img/&#39; download(url, dest) 可以看到python的代码明显简单多了，而且还可以简单的指定User-Agent。关键是图片的下载只需要一行代码request.urlretrieve(url, file),不像Java还要使用复杂的IO流操作。（其实Java也可以，只是我没有使用Commons IO罢了，python的函数如此简洁好用，只是因为已经包装好了而已） 爬取一整页的图片import spiderImg from urllib import request import re import os def getPageUrlList(urlContent): pattern = re.compile(r&#39;&lt;strong&gt;&lt;a href=&quot;(http://moe.005.tv/\d{5}\.html)&quot;&gt;(?:&lt;b&gt;)*(.*?)(?:&lt;/b&gt;)*&lt;/a&gt;&lt;/strong&gt;&#39;) pageUrlList = pattern.findall(urlContent) return pageUrlList def downloadPages(pageUrlList, dest): if not os.path.exists(dest): os.makedirs(dest) for pageUrl in pageUrlList: url = pageUrl[0] name = pageUrl[1] path = dest + name + &#39;/&#39; if not os.path.exists(path): os.makedirs(path) spiderImg.download(url, path) def download(url, dest): urlContent = spiderImg.getUrlContent(url) pageUrlList = getPageUrlList(urlContent) downloadPages(pageUrlList, dest) if __name__ == &#39;__main__&#39;: url = &#39;http://moe.005.tv/moeimg/list_2_11.html&#39; dest = &#39;img/&#39; download(url, dest) 上面的正则表达式中似乎是多了一个两个&lt;b&gt;,这是因为我发现有的标题使用了&lt;b&gt;倒是创建文件夹的时候失败了。于是我才加上了两个非捕获组防止&lt;和&gt;被放到文件名中，倒是创建文件夹失败。 爬取多页图片import spiderPage import os if __name__ == &#39;__main__&#39;: for i in range(29,32): url = &#39;http://moe.005.tv/moeimg/tb/list_3_&#39;+str(i)+&#39;.html&#39; dest = &#39;img/page_3_&#39;+str(i)+&#39;/&#39; if not (os.path.exists(dest)): os.makedirs(dest) try: spiderPage.download(url, dest) except Exception as e: print(&#39;Exception: &#39;+e) 总结上面可以说只是学完了正则表达式之后的一个简单的应用，写出来的也是一个极简极low的一个爬虫程序，不过这个极简极low的爬虫程序还真的解决了我的一个小问题。我再也不用，手动的右键另存为，另存为，花了半天才存了五十张图片了！！棒棒哒！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Python</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F30%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式前言第一次看到正则表达式这个名次可能会有点儿懵，什么叫正则？其实这个是翻译的问题，正则表达式的英文是Regular Expression，常常被简写为Regex，直译过来就是有规律的表达式。所以说，正则表达式就是指描述某种规则的表达式之意。 其实说白了，正则表达式就是用于字符串匹配的工具。我们可以使用正则表达式描述出来我们想要寻找的字符串符合某种规则。其实正则表达式也没有什么十分复杂的地方，主要就在于匹配符的记忆，以及匹配的经验。下面就直击要点，开始介绍正则表达式的匹配符。 正则表达式语法普通字符字母、数字、汉字、下划线、以及没有特殊定义的标点符 号，都是“普通字符”。表达式中的普通字符，在匹配一 个字符串的时候，匹配与之相同的一个字符。 这个玩意是最简单的。比如说hello就是匹配hello。world就是匹配world。没什么要说的地方。 常用的转义字符 匹配符 含义 \n 换行符 \t 制表符 \\ \本身 ^ ，\(, \)等一系列 用来匹配\后面的字符 学过任何一门的编程语言的应该都可以轻松理解上面的意思。因为^ $ ( ) { } [ ] .等这些符号在正则表达式语法具有某些特殊的含义，所以我们需要使用\转义之后才可以匹配这些字符本身。 标准字符集合 匹配符 含义 \d 任意一个数字, 0-9中的任意一个 \w 任意一个字母、数字、下划线中任意一个 \s 空格、制表符、换行符等空白字符中的任意一个 . 任意一个字符除了换行符（\n） 所谓的标准字符集合的意思就是可以和多个字符匹配的表达式。 上面的这些匹配符都是区分大小写的，而且大写是相反的意思。比如\D表示的意思是匹配除了数字以外的任意一个字符。\W表示匹配除了字母、数字和下划线以外的任意一个字符，\S表达匹配除了空格、制表符、换行符这些空白字符以外的任意一个字符。需要注意的是上面的.不要匹配换行符，如果需要匹配任意一个字符的话，推荐使用[\s\S]。细心的其实一下子就可以才出来[]是取并集的意思。 自定义字符集合也就是上面说的那样，[]表示匹配其中的任意一个字符。 匹配符 含义 [abc@f] 匹配a、b、c、@、f中的任意一个字符 [^abc] 匹配除了a、b、c之外的任意一个字符 [c-g2-9] 匹配c到g之间的任意一个字母或2-9之间的任一个数字（包含两端） [^A-Z] 匹配除了A-Z之间字母以外的任意一个字符 从上面可以看到^和-这两个字符在[]中是有特殊含义的。 ^需要放在[]的最前面表示取反的（除以下的字符以外）的意思。 -需要放在字母之间，数字之间，表示其中间的所有字符。注意不能混用，不可以出现a-Z这种写法。 除了^和-之外其他的所有的特殊字符到了[]中便失去了其原本的含义。比如.不再代表万能匹配符，而就是匹配.。 如果想要在[]匹配字符^或者-，需要使用转义字符的方式。如[\^\-]可以匹配^或者-之间的任意一个字符。 标准字符集合除了.在[]中依旧保持其原有的含义。比如[\d\s]匹配任意一个数字或者任意一个空白字符。上面说到的[\s\S]就是匹配任意一个字符。 量词量词，是用来修饰匹配次数的特殊符号 量词 含义 {n} 表达重复n次 {n, m} 表示最少n次，最多m次 {n, } 表示最少n次 ? 表示出现0次或者1次 + 表示出现至少一次，相当于{1,} * 表示不出现或者出现任意次，相当于{0,} 比如有如下的字符串 shr sher sheer sheeer shrr 使用表达式sh\w{3}r可以匹配到sheeer 使用表达式sh[a-z]{1,3}r可以匹配到sher,sheer 使用表达式sh\w{2,}r可以匹配到sheer,sheeer 使用表达式sh.?r可以匹配到shr,sher,shrr 使用表达式sh.+r可以匹配到shr sher sheer sheeer shrr 使用表达式sh.*r可以匹配到shr sher sheer sheeer shrr 上面就是这些量词的用法，看起来时蛮简单的，不过你可能主要到了一个问题，就是最后的两个的匹配。可能我们原来的意思是给我匹配shr,sher。。。这样的多个字符，而他却只给我匹配了一个大字符，这是为什么呢？ 这是因为匹配模式默认开启贪婪模式（匹配的字符串越多越好），所以说只要还下一个字符还是可以匹配的就会继续加上去，使得匹配的字符串越唱越好。 我们可以在量词的后面加上？开启非贪婪模式（匹配的字符串越少越好） 使用表达式sh.+?r可以匹配到shr sher,sheer,sheeer,shrr 使用表达式sh.*?r可以匹配到shr,sher,sheer,sheeer,shr 上面就是正则表达式中的量词的基本的使用方式。 字符边界字符边界并不是用来匹配某一类字符用的，而是用来描述某种调节的位置。 匹配符 含义 ^ 与字符串开始的地方相匹配 $ 与字符串结束的地方相匹配 \b 匹配一个单词边界 所谓的\b所描述的单词边界的意思就是这样的一个位置——位置的两边不都是\w。 有如下的字符串待匹配 sher shera asher asherb sherb sher sher使用表达式^sher可以匹配到位于字符串最开始的第一个sher 使用表达式sher$可以匹配到第二行中的最后的一个sher 使用表达式sher\b可以匹配到四个sher，除了上面的上个sher外，asher的尾部sher被匹配了。 上面就是字符边界的一般使用方法。 不过如果我们需要匹配每一行的开始的sher，或者最后的sher，需要怎么写表达式呢？ window中的换行符是\r\n，我们可以是用sher\r\n匹配到除了最后一行的末尾，所以使用sher\r\n|sher$的表达式来匹配每一行末尾。使用\r\nsher|^sher来匹配每一行的开始。不过有没有简单的方式呢？ 那么我们就需要调节正则表达式的模式了。正则表达式有以下的三种模式可以选择。 IGNORECASE 忽略大小写模式 匹配时忽略大小写。 默认情况下，正则表达式是要区分大小写的。 SINGLELINE 单行模式 整个文本看作一个字符串，只有一个开头，一个结尾。 使小数点 “.” 可以匹配包含换行符（\n）在内的任意字符。 MULTILINE 多行模式 每行都是一个字符串，都有开头和结尾。 在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使 用 \A 和 \Z 如果要实现上面我说的匹配每一行开头和结尾。可以开启多行模式。这时^就是指每一行的开始。$就是指每一行的结束。此时如果我们还是想要匹配字符串的开始和结束位置可以使用\A和\Z。 选择符和分组 表达式 作用 Expression1|Expression2 分支结构。表示或，匹配左面或者右面 (Expression) 捕获组。作用下面叙述 (?:Expression) 非捕获组。作用下面叙述 上面的第一个分支结构，上面我也说过了。在非多行模式下表达式：^sher|\r\nsher其中左面是第一行的开始，右面是其他行的开始。取或就是所以行的开始位置。 那么那个所谓的捕获组又是什么意思呢？其实这个名字听起来玄乎玄乎的，其实理解起来也是很容易的。 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 每一对括号会分配一个编号，使用 () 的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式 匹配的文本 第一点其实上面忘了说了，表达式she{3}r中的{3}只可以描述前面的一个字符e,只可以匹配sheeer。如果要描述前面的多个字符需要使用()，比如说(she){3}r就可以匹配sheshesher。 第二点应该和第三点合起来，讲的大概意思就是正则表达式会将()进行分组，其中0表示的就是匹配到的整个字符串。比如表达式((sher)|hony)|(sherhony)。就被分为了四个组。0就是这个表达式本身，剩下来的从(开始从1开始分组。第一组是(sher)|hony。第二组是sher，第三组是sherhony。那么获取了这写分组有什么作用呢？这就要谈到下面的新语法了。 反向引用通过反向引用可以对分组中已经捕获的字符串进行引用。 语法: \nnn。nnn表示的分组的组号。 举例：假如我们要在字符串中匹配这样的一个单词，他的前面两个字符和后面的两个字符是相等的。 字符串为 goingo sher todotodo hony 正确表达式为：\b([a-z]{2})[a-z]*\1\b 上面的表达式中最后的\1就是一个反向引用。引用的是前面匹配到的[a-z]{2}。用这种方式就可以确认单词的首位的两个字符是相同的。而两个\b确保了这是一个单词。 非捕获组不过这个捕获组也有一定的问题。我们之所以可以引用，是因为他将之前括号中的匹配到的字符串放入了内存中供我们后面使用。加入我们不想要引用这部分的类容呢？我们仅仅只是使用括号用于作用一，而不想要浪费捕获组的这部分内容时。我们就可以使用非捕获组(?:Expression)。 比如上面的(she){3}r就可以改成(?:she){3}r。毕竟这个表达式中，使用捕获组是毫无意义的，使用非捕获组的时候，并不会影响字符串的匹配。（不使用反向引用）使用非捕获组还使用反向引用这就是非常没有意义的行为了！！ 零宽断言所谓的零宽就是指没有宽度的意思。很明显这些表达式都是不匹配字符的，只是匹配位置的。比如之前学过的^、$和\b都是零宽的表达式。下面又来介绍一下零宽的另一些表达式。 表达式 含义 (?=Exp) 断言自身位置的后面可以匹配Exp (?&lt;=Exp) 断言自身位置的前面可以匹配Exp (?!Exp) 断言自身位置的后面不可以匹配Exp (?&lt;!Exp) 断言自身位置的前面不可以匹配Exp 字符串:1sher 1shersher sher1 sher34 表达式:sher(?=\d)可以匹配到后面的两个sher不过不会匹配到他们后面的数字。所以这个表达式的意思是匹配后面的一个字符是数字的那个sher。如果使用的是sher(?=\d\d)就只能匹配到最后的那个sher。 表达式: (?&lt;=\d)sher可以匹配到前面的两个sher。(第二个的前面) 表达式: sher(?!\d)可以匹配到前面的两个sher。（第二个的后面） 表达式: (?&lt;!\d)sher可以匹配到后面的两个sher。 上面的所有的基本上就是正则表达式的语法了。不过想要掌握正则表达式还是需要不断的练习的。 正则表达式练习匹配电话号码电话号码分为座机和手机。其中座机可以表示为0\d{2,3}-\d{7,8}手机可以表示为1[34578]\d{9}。（手机号的第二位现在只有34578) 综合上面我们可以得到电话号码的匹配表达式\b0\d{2,3}-\d{7,8}\b|\b1[358]\d{9}\b。其中使用的\b是确保这个不是其他数字的一部分。（不过有时候也不要这个\b，玩意电话号码就是和字母连一起了呢？)。 匹配电子邮件电子邮件的格式是比较简单的。这里我使用的是。 \b\w+@[\da-z]+(\.[a-z]{2,3})+\b 我看了一下网上给出的匹配字符串的正则表达式是 \w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)* 这个我倒是感觉没啥必要，一般的用户名都是只可以\w的。至于后面的域名匹配我倒是感觉他的不够严肃了，而且看起来很沙雕。 匹配HTML标签这个应该是用处最大的东西。HTML标签分为两种标签，一种是成对存在的，另一种是单独存在的。这里我写的表达式是： &lt;\s*([a-z]+)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*?/&gt; 其中第一个\s是防止某些不规范的写法，比如&lt; a&gt;。后面是一个捕获组([a-z]+)用来捕获标签的名字。再后面的[^&gt;]*用来捕获标签中的其他的一些属性值。[\s\S]*?用来捕获标签中的内容。注意使用\s\S而不是.，是因为很多标签的前后都会有很多的内容，也就是说会换行，而.无法匹配换行。所以要使用\s\S。后面的&lt;/\1&gt;中的\1是一个反向引用，用来引用前面的标签中的内容，前后标签的内容是要相等的。后面的&lt;.*?/&gt;是用来匹配单标签的。 不过上面的正则表达式还是有问题的。比如下面的这个HTML中。 &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 会出现匹配失误。第一个&lt;div&gt;和另一个&lt;/div&gt;匹配了。不过关于这个问题，我也没有想到什么解决方式。看来使用正则表达式来匹配嵌套的标签还是有一定的难度的。 Java中的正则表达式public class Demo1 { public static void main(String[] args) { Pattern pattern = Pattern.compile(&quot;sh.*?r&quot;,Pattern.CANON_EQ); Matcher matcher = pattern.matcher(&quot;sher sheer sheeer shrr&quot;); while (matcher.find()) { System.out.println(matcher.group()); } } } 使用的形式主要如上。其实也没什么好说的东西。使用Pattern编译正则表达式，后面可以选择相应的模式。然后匹配一个字符串，返回一个Matcher，然后使用find和group方法就好了。 总结上面只是简单的介绍一个正则表达式的语法，其实正则表达式还有其他很多的高级语法，可以等遇到了再学习吧。下面我准备写一个使用正则表达式来爬虫（Java）的一个小代码。蛤蛤蛤~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说内部类]]></title>
    <url>%2F2019%2F09%2F29%2F%E8%AF%B4%E8%AF%B4%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[说说内部类前言说起Java当中的类和C++中的类有什么区别，我第一个要说的就是Java的类中，竟然还可以写一个类，而且这个类还可以是成员变量。简单的来说，Java当中的内部类分为一下的三种。 内部成员类。（通常将内部成员类简称为内部类） 本地内部类 匿名内部类 这里我们说的内部类指的是非静态的内部类。简单的说也就是内部类是作为外部类的一个成员变量而存在的，必须要存在外部类的对象才能够访问到内部类。如果没有外部类的存在，内部类作为一个成员变量自然也不会存在。由于这种依赖与矛盾关系，在内部类中我们不可以声明静态成员。（静态成员包括静态变量，静态方法，静态成员类和嵌套接口。） 不过有一点比较特殊的是，在内部类中我们可以声明static final的变量，原因是在于编译器对于final变量做了一个特殊的处理。final变量会被直接写入字节码中，而不会生成变量的符号引用。 内部类的使用public class InnerClassDemo1 { private int aaa = 3; private static final int bbb = 4; public static void main(String[] args) { InnerClassDemo1 in = new InnerClassDemo1(); InnerClassDemo1.Inner inner = in.new Inner(); inner.func(); // out: Hello World \n class com.sher.innerclass.InnerClassDemo1$Inner InnerClassDemo1.Inner.InnerInner innerInner = new InnerClassDemo1().new Inner().new InnerInner(); innerInner.func(); // out: Hello World Again \n class com.sher.innerclass.InnerClassDemo1$Inner$InnerInner } public class Inner { public static final String a = &quot;Hello World&quot;; // public static int a = 3; // No static properties but static final. void func(){ System.out.println(a); System.out.println(aaa); System.out.println(bbb); System.out.println(this.getClass()); } public class InnerInner { public static final String b = &quot;Hello World Again&quot;; void func(){ System.out.println(b); System.out.println(this.getClass()); } } } } 上面我演示的是一个内部类，但是内部类当中还有着一个内部类，这个内部类依旧是合法的。我们可以将内部类直接当作是这个类的一个成员变量。一个比较特殊的一点是我们如何创建一个内部类的i变量。首先是这个内部类的类型是外部类.内部类。我们新建一个内部类的方式是，外部类对象.new 内部类()。这个格式或许有一点儿奇怪，不过仔细想想确实非常的正常。内部类是依赖于外部类说存在的，那么内部类的类型上肯定是要有外部类。如果没有的话，不同的类拥有相同名字的内部类，难道说这这两个内部类是同一个类吗？二来就是内部类的创建方式。既然内部类是依赖成员变量，那么肯定是依赖于外部类的对象而存在的。不同的外部类拥有不同的成员变量，这也是理所应当的事。 上面已经说过了内部类中是不可以有静态成员的，除了static final变量。 还有要说的就是在内部类中是否可以访问到外部类的变量。由上面可见，无论是成员变量还是静态变量都是可以访问的。比较内部类本身也是外部类的一个成员变量。 现在我们在来观察一下，这个内部类的名字是不是就是我们给他的名字呢？看结果显然不是，看来和我们上次说的那个匿名内部类是一样的。系统也是默认的生成了一个类。也是使用了$这个符号。不过那么我们是否可以使用一下的方式来新建内部类的对象呢？ InnerClassDemo1$Inner$InnerInner a = new InnerClassDemo1$Inner$InnerInner(); 运行了一下试试，果然是不行的。不过我也没期待这种方式是可行的。这也不是python私有变量的那种自欺欺人的私有。怎么可能通过这种方式就可以访问呢。 静态内部类上面说的都是内部成员类，作为对比来说，可以来简单说说静态内部类。 public class InnerClassDemo2 { private int aaa = 3; private static int bbb = 4; private static final String ccc = &quot;Outer&quot;; public static void main(String[] args) { StaticInner static1 = new StaticInner(); static1.func(); A.Go(); } public static class StaticInner{ public static final String a = &quot;Hello World&quot;; static int b = 3; int c = 4; void func(){ System.out.println(a); // System.out.println(aaa); System.out.println(InnerClassDemo2.bbb); System.out.println(ccc); } } } class A { public static void Go() { InnerClassDemo2.StaticInner inner = new InnerClassDemo2.StaticInner(); inner.func(); } } 上面演示的是静态内部类。内部成员类是对象的一个成员，那么静态内部类就是类的一个静态成员。静态内部类不需要依赖类的对象而存在，所以创建静态内部类的时候也不需要使用对象.new xx()的方式，而是使用new 外部类.静态内部类()的方式。在外部类中的时候，我们可以省略外部类.，这个用法和静态变量是一样的。 对与外部类的访问权限，也是和静态成员是一样的。他可以访问带类的静态属性(包括private)，但是不可以访问到非静态的属性，正如静态方法不可以访问非静态属性一样。 比较一下这两个类的话，我们可以看到这个静态内部类更向是一个真正的类，这个类中的数据基本上什么都是可以有的。（因为静态成员类是不依赖对象的。） 还有一个比较重要的东西没说，之前我们谈论单例设计模式的时候，我们使用了一种方法就是使用静态内部类来实现的。我们在来看一下实现的代码。 public class SingletonTest03 { public static void main(String[] args) { Singleton03 singleton1 = Singleton03.getInstance(); Singleton03 singleton2 = Singleton03.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton03{ private Singleton03() {} // 使用静态内部类 private static class SingletonInstance { private static final Singleton03 INSTANCE = new Singleton03(); } public static Singleton03 getInstance() { return SingletonInstance.INSTANCE; } } 因为静态内部类还有一个特点就是静态内部类中的静态数据只有被类第一次被使用到的时候创建。而且这种创建是线程安全的，这都是由JVM来保证的。至于为什么是这样的，这要学到JVM类的加载机制之后才能更深层次的理解之内的原因了吧。 内部类与外部类的联系上面简答的扯了一扯内部类(通常不加任何说明的内部类就是指内部成员类)与静态内部类的关系，以及他们之间的区别。下面我们想要讨论一下的是，内部类的外部类之前的关系。 上面我们以及了解到了，其实在我们写了一个内部类的之后，Java替我们生成的类并不是我们所谓的内部类的名字。而是外部类$内部类这样的一个名字。其实内部类也是一个正常的类，不过这个类是如何和绑定他的外部类建立联系的呢？ 对于内部类来说，编译器会默认生成一个final成员变量，变量的类型是外部类的类型，用来指向外部类的对象。 public class Inner{ final Outer this$0; public Inner(Outer t){ this$0 = t; super(); } } 其中引用名称this$0是编译器自动生成的，在创建内部类的对象的时候，系统会自动将外部类的的对象(outer)作为参数自动传入内部类的构造器中。 Outer.Inner inner = outer.new Inner(outer); 其实，与此同时，也会将新创建的内部类的对象(this)作为第一个参数隐式传递。假如创建玩inner对象之后，返回的引用是x，那么代码可以解析如下。 Outer.Inner inner = outer.new Inner(x, outer); 从上面可以看出来，内部类和外部类的绑定是通过this$0这个引用的。不过这些代码并不是真实存在的。这些都是我们用来描述编译器私下完成的工作的。 本地内部类上面基本上已经说完了最重要的一个内部类——内部成员类。下面就来简单的介绍一个下一个内部类——本地内部类。 和内部成员类不一样的是，这种类并不是作为类的一个成员变量，从结构上类似一个局部变量，所以说也就没有了所谓的访问权限了。 在本地类中，可以访问其所声明的方法，构造器或初始化块所属类的所有的成员， 如果要是在静态方法或者静态初始化块中声明的，则需要一个对象的引用来访问类的实例成员。 对于局部变量或方法（构造器）中声明的形式参数，本地类只可以访问final修饰的局部变量或参数。 这个类是不用和外部类进行绑定的，所以和上面的内部成员类不一样，不存在一个final引用和外部类绑定。 其实这种我感觉用处并不大，稍微了解一下就行了。 匿名内部类其实之前在谈论接口的时候，我们已经提及了这个匿名内部类了。使用匿名内部类的情况其实也就那么一种。 new A(){ xxx; } 这里的A就是一个接口，生成了一个匿名的实现了这个接口类的对象。这种写法主要是使用与这个类或者对象只会使用一次。不过Java 8之后，出来乐意lambda表达式可以替代这个匿名内部类，唉~匿名内部类是真的惨！ 总结上面是对Java中内部类的一个简单的介绍。仔细想想看Java中为什么有这么多的内部类呢？其实只是因为这些类在类中的位置不一样。（除了匿名内部类）。他们有些是作为类的实例成员，有些是作为类的静态成员，有些还是作为类中的一种局部变量。其实说白了，作为什么成员，这个类就具有那样性质的功能。从这个方面去理解内部类就一点也不难理解了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[唠一唠接口]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%94%A0%E4%B8%80%E5%94%A0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[唠一唠接口接口可以new？众所周知，接口是一种完全抽象化的设计，不能够实例化，即我们不能创建接口类型的对象。也就是说我们是不可以new出一个接口对象的，但是仔细想想看，我们是不是经常使用new一个接口的操作呢？ new出一个接口其实之前刚刚讲过了lambda表达式，在那儿的时候我就想多说一句的，不过我还是忍住了，到这个地方再说。 public class Test { public static void main(String[] args) { Bird bird = new Bird() { @Override public void fly() { System.out.println(&quot;Bird can fly!&quot;); } }; // Bird bird = ()-&gt;{ // System.out.println(&quot;Bird can fly&quot;); // }; bird.fly(); } } interface Bird { void fly(); } 注释中我使用的是lambda表达式的写法，上面的是一个匿名内部类。停！上面的是一个匿名内部类？我们是不是搞错了，上面我们new了一个接口？这编译器竟然还不报错，是吃干饭的嘛？ 上面的代码一切都运行正常，不过这是不是就可以说明接口其实是可以进行实例化的呢？ 既然他是可以new出来的，那我们就在这个类中打印一下他的类型看一下。看看是不是Bird类型，如果是的话就可以证明其实接口也是可以被new的。 System.out.println(this.getClass()); 输出的结果是class com.sher.learnInterface.Test$1 Test$1这是个什么类，Test类是我们创建的，但是这个类我们根本不知道。这到底是怎么回事呢？ 其实接口可以new完全是一个假象。接口是完全抽象化的设计，是不可能实例化的。不过那如果理解上面的代码呢？其实程序中的创建方式就是匿名内部类来实现的。上面的那个类Test$1就是由系统创建的一个类，这个类实现了Bird接口，并且实现了fly()方法。不怪刚学Java的时候，Java不建议在自己起的变量名中使用$，因为这个符号广泛的被Java所使用。 上面的那个匿名内部类的实现如下 static final class Test$1 implement Bird{ public void fly(){ System.out.println(&quot;Bird can fly&quot;); } } Bird bird = new Test$1(); 由此可见，认为接口可以new真的是天大的笑话。 Java中没有多继承？Java来源于C++。可以多继承是C++的一个重大的特点之一，不过Java认为C++中的多继承把继承结构搞得一团糟，比如继承两个类都有相同的方法和属性的时候。所以索性Java直接禁止类的多继承，只允许单继承。但是Java中多了接口，类可以实现多个接口。 所以说，当别人问你，Java中有没有多继承的时候，我们应该回答没有？？ 上面只是说Java禁止类的多继承，也没说禁止其他的多继承啊。但是Java中除了类，还有什么玩意可以继承的吗？还真的有，那就是接口，接口也是可以继承的。是的，你没有听错，接口也是可以继承的。 下面我们来重新的了解一下接口到底是个什么玩意。 接口中所有的方法都必须是public , abstract类型 接口中的所有的属性都必须是public, static, final类型。 接口中的所有的内部类（包括枚举）都必须是public, static类型。 上面是Java当中接口的一些硬性的要求，第三点或许有点儿陌生，不过不看第三点其实问题也不大。 然后下面我要该了解的就是接口继承的规则了，其实这也就是方法重写的规则。如果接口中的mSub方法，重写了父接口的mSuper接口，那么需要满足一下的条件。 mSub的签名是mSuper的子签名 mSub的返回类型是mSuper返回类型的可替换类型 mSub不能抛出比mSuper更多的受检异常 上面的条件其实我们早就知道了。（方法的签名就是指函数的参数的类型） 对于类的基础中的方法重写还要有几个条件，不过这些条件接口都已经默认的满足了。 mSub和mSuper都是实例方法。（接口中的方法都是实例方法，不可能是static) mSub的访问权限不能低于mSuper。(接口中的方法全都是public的) mSub继承了父类的mSuper方法。(都是public的，当然是可以继承的) 经过了上面的探讨，我们可以知道，Java中的接口是完全可以继承的，而且是可以进行多继承的。 不过既然是可以多继承的，那么我们就要来处理一下C++中的那个问题，如果有相同的方法或者属性，怎么办？ 相同的属性名interface A{ int id = 1; } interface B{ int id = 2; } interface C extends A, B{ int id1 = A.id; int id2 = B.id; } public class Test2 implements A, B { public static void main(String[] args) { // System.out.println(id); 、、 Reference to &#39;id&#39; is ambiguous, both A.id and B.id match System.out.println(A.id); System.out.println(B.id); } } 从上面可以看到，如果是实现了多个接口的话，同时接口中有相同的属性，我们就不可以使用简单的方式来访问这个变量，我们必须在使用的时候在前面加上类名一防止产生没有必要的歧义。 相同的方法签名加入方法名相同，但是方法的签名相同，那么这个两个方法是完全可以分辨的。所以这种函数没有什么歧义。比如func(int)和func(String)是完全没有歧义的。有歧义的就是方法签名相同的函数。 interface A { void func(); } interface B { void func(); } interface C extends A, B { } public class Test2 implements C { public static void main(String[] args) { A a = new Test2(); a.func(); B b = new Test2(); b.func(); } @Override public void func() { } } 可以看到上面有相同的返回值是没有关系的，反正两个接口中都是没有实现的，所以类中实现一个就行了。使用其中的任何一个接口都可以访问到这个函数，但是两个函数是一样的。(相同名的函数，你还想实现两次，那怎么调用？) 不过如果方法的返回值不一样呢？ interface A { int func(); } interface B { String func(); } interface C extends A, B { // Error } public class Test2 implements C { // Error } 虽然这个上面没有什么报错提示，但是我的idea上报错都满天飞了，看来返回值不相同是没有办法多继承的了。 不过真的如此吗？ interface A { Collection&lt;String&gt; func(); } interface B { List&lt;String&gt; func(); } interface C extends A, B { } public class Test2 implements C { public static void main(String[] args) { A a = new Test2(); a.func(); B b = new Test2(); b.func(); } @Override public List&lt;String&gt; func() { return null; } } 可以看到，虽然方法的返回值是不一样的，但是由于List&lt;&gt;是Collection&lt;&gt;的子类，所以说多继承的时候会将范围扩大，返回值变成了List&lt;String&gt;，这样就可以多继承啦。（List&lt;String&gt;同时为List&lt;String&gt;和Collection&lt;String&gt;的子签名）。 由此可见，如果方法的签名相同，而且返回值还没有相同的子签名，那么这个两个接口将无法进行多继承。 接口中可以拥有非final的属性吗？经过上面的了解，我们也知道了接口当中的所有的属性都必须要是public static final 的。原因是在于Java当中的接口是一种完全抽象的结构。是用来给多个类实现的。如果存在非final的变量，其中的一个实现修改了变量，其他的所有的实现中的该变量都将被修改，这是非常不合理的。所以说Java的中接口是对修改封闭的。禁止你修改的。 但是真的是对修改封闭了吗？ final是对值的修改封闭的。但是Java中有非常多的引用的类型。我修改引用里面的内容但是却不修改引用这完全符合final。 interface AA{ CA ca = new CA(); } public class Test3 implements AA{ public static void main(String[] args) { System.out.println(ca.id); // 10 ca.id = 110; System.out.println(ca.id); // 110 } } class CA{ public static int id = 10; } 可见，通过这种方式，我们修改了接口中的值，（其实并没有修改，接口中保存的只是引用）就好像有了一个非final的属性。 我写这个例子并不是为了说，这样写就可以是接口拥有非final的属性，恰恰相反，我是为了防止这种情况的发生，在接口中我们尽量不要放置这种引用类型的变量。（idea才提醒我使用ca.id是个危险的行为） 总结Java中的接口可谓的是一个非常强大的结构。算了，我也没有什么可以总结的地方了，一句话，接口牛逼就是了！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识lambda]]></title>
    <url>%2F2019%2F09%2F29%2F%E8%AE%A4%E8%AF%86ambda%2F</url>
    <content type="text"><![CDATA[认识lambda前言lambda是匿名函数，虽然Java中的匿名函数没有学过，但是C++中的匿名函数我非常的熟悉啊，而且python中也曾经接触过匿名函数，不过python中的匿名长什么样子我都记不得了。现在就来学学Java中的lambda函数吧。 初识lambda说得跟恋爱似的，我和lambda的相识也是一个不经意间，并不是我要去故意的去了解lambda，他却是出现在了我的面前。话说第一个看到lambda是学习python的时候，不过现在python中lambda长什么锤子样我都已经忘记了。给我印象最深的C++中的lambda，毕竟C++是我最爱的语言。而认识Java的lambda确实因为Core Java Volume I这本书。这本书的前面使用了Java Swing编写了一个小程序，以此来彰显Java的魅力。（反正我是丝毫没感觉到）。 代码如下。 package com.sher.corejava.imageview; import javax.swing.*; import javax.swing.filechooser.FileNameExtensionFilter; import java.awt.*; import java.io.File; /** * @author SHeR * @time 8/21/2019 10:27 PM * @describe A simple java swing(GUI) ImageViewer project from &quot;Core Java, Volume I&quot; */ public class ImageViewer { public static void main(String[] args) { // What is &#39;() -&gt;&#39;?? This should be Anonymous Inner Class // It is Lambda Function related changes in Java8 EventQueue.invokeLater(() -&gt; { var frame = new ImageViewerFrame(); frame.setTitle(&quot;ImageViewer&quot;); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setVisible(true); }); /* So this Lambda Function can be wrote like this -- Anonymous Inner Class But the compiler says that Anonymous New Runnable can be replaced by lambda EventQueue.invokeLater(new Runnable() { @Override public void run() { ImageViewerFrame imageViewerFrame = new ImageViewerFrame(); imageViewerFrame.setTitle(&quot;ImageViewer&quot;); imageViewerFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); imageViewerFrame.setVisible(true); } }); */ } } @SuppressWarnings(&quot;all&quot;) class ImageViewerFrame extends JFrame { private static final int WIDTH = 800; private static final int HEIGHT = 600; public ImageViewerFrame() { setSize(WIDTH, HEIGHT); // Use a lable to display image JLabel jLabel = new JLabel(); this.add(jLabel); JFileChooser jFileChooser = new JFileChooser(); // Choose File Extension FileNameExtensionFilter fileNameExtensionFilter = new FileNameExtensionFilter(&quot;JPG &amp; GIF Images&quot;, &quot;jpg&quot;, &quot;gif&quot;); jFileChooser.setFileFilter(fileNameExtensionFilter); // Set initial open path jFileChooser.setCurrentDirectory(new File(&quot;C:\\Users\\SHeR\\blog&quot;)); // set up the menu bar JMenuBar jMenuBar = new JMenuBar(); setJMenuBar(jMenuBar); JMenu menu = new JMenu(&quot;File&quot;); jMenuBar.add(menu); JMenuItem open = new JMenuItem(&quot;Open&quot;); menu.add(open); // Lambda Function again! open.addActionListener(event -&gt; { int result = jFileChooser.showOpenDialog(null); // if file selected, set it as icon of the label if (result == JFileChooser.APPROVE_OPTION) { String name = jFileChooser.getSelectedFile().getPath(); jLabel.setIcon(new ImageIcon(name)); } }); JMenuItem exit = new JMenuItem(&quot;Exit&quot;); menu.add(exit); // Wow, Lambda Function! That&#39;s fucking simple and beautiful! exit.addActionListener(event -&gt; System.exit(0)); } } 可以看到代码的17行，71行，当时我看到了是一脸懵逼的，这是个什么玩意？后来我去查阅-&gt; in java竟然查到了这个是Java中的lambda function。这个用法是java 8中才引入的。 我观察了17行invokeLater()函数，参数是一个Runnable参数。（Runnable是一个多线程相关的接口，有一个run()方法需要实现。）所以我寻思写法应该是想我下面注释中那样哒。好歹我也是学过了一点安卓的，这里写一个匿名类还是明白的。不过他用了lambda的方式来写，好像写的东西更少了，不过也有点儿看不懂了。 lambdaJava中lambda的基本格式是(arg1, arg2...) -&gt; {body} 或者也可以加上参数的类型。type1 arg1, type2 arg2... -&gt; { body } 比如写一个最简单的lambda表达式就是(int a, int b) -&gt; {return a+b} 不过问题是这个破函数如何调用呢？？我尝试着像使用匿名函数那样去调用，没想到没有任何作用。 ((int a, int b) -&gt; {return a+b;})(1, 2)像这样调用，是我太天真了，误解了Java中的lambda。Java中lambda和我在C++中学到的一点都不一样，他不像是一种独立的函数，而是像一种依赖于接口的特殊函数。 比如上面的那个函数用法应该是这样 public class lambda { public static void main(String[] args) { Test t = (a, b) -&gt; {return a+b;}; int c = t.func(3, 4); System.out.println(c); } } interface Test{ int func(int a, int b); } 上面的lambda中，函数的参数类型是可以推导的，所以可以省略，而函数体中只有一行代码。所以大括号都可以省略，甚至return都是可以省略的。Test t = (a, b) -&gt; a+b;(不需要两个分号了) 更多的lambda使用例子Comparator&lt;String&gt; c; c = (String s1, String s2) -&gt; s1.compareToIgnoreCase(s2); public Runnable toDoLater() { return () -&gt; { System.out.println(&quot;later&quot;); } } final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); list.forEach((a)-&gt;{ System.out.println(&quot;hello: &quot;+ a); }); filterFiles(new FileFilter[] { f -&gt; f.exists(), f -&gt; f.canRead(), f -&gt; f.getName().startsWith(&quot;q&quot;) }); 不过如果接口中有多个函数需要实现呢？ 那就只能gg了，据我所知lambda不能解决这个问题，而且就算是可以解决，那也会很复杂而且代码的可读性会下降。 lambda的目标类型和C++中的lambda不一样，Java中的lambda没有一个固定的类型所以Java中的lambda不能够独立的存在，只可以依赖于其他的东西，比如接口。同样的(a, b) -&gt; a+b;，我可以给很多的接口使用，这要适合lambda的形式就可以了。 所谓的适合lambda的形式就是 参数在数量上和类型上意义对应。（类型上很多的时候都是自动推导） 返回值相兼容。 异常类型也相兼容。 lambda中的变量域以及变量捕捉当我们使用匿名内部类的时候，内部类外面的变量，除非被声明为final，是不可以被使用的。但是如果使用lambda表达式的话，那就不一样了。lambda可以使用外界有效可读的变量。lambda和匿名内部类还有一个重大的区别是，匿名内部类中的this指的是这个内部类，而lambda内部的this指的就是所在的类。 上面说lambda可以使用外界有效可读的变量。那么什么事有效可读的变量呢？ 所谓的有效可读的变量就是值，这个变量被初始化之后从来没有改变过，也就说给他加上final也不会报编译错误的变量。 那么lambda是否可以修改这些变量呢？ 答案是lambda表达式对值封闭，对变量开放; int sum = 0; list.forEach(e -&gt; { sum += e.size(); }); // Illegal, close over values List&lt;Integer&gt; aList = new List&lt;&gt;(); list.forEach(e -&gt; { aList.add(e); }); // Legal, open over variables 这其实也是很好理解的，上面的那个经过lambda之后sum值都修改过了，这还能是有效可读变量吗？不过下面的那个就没有修改了吗？当然没有对象中保存的一个引用，使用add方法之后这个对象的引用并没有发生变化，所以是合法的。 final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(2); list.add(3); list.add(4); list.add(5); list.add(6); 这样都是合法的，但是进行下面的操作的时候就不再合法了。 final List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list = null; // Error: cannot assign a value to final varible 小结Java当中lambda是十分的复杂的，是Java8当中的一个最重要的更新之一。之前我也没有学过Java8的新特性（现在已经Java13了），所以这里的lambda也就不扯那么多了。下面有一篇文章对lambda的介绍是非常的详细的，建议看看。 深入理解Java 8 lambda Java lambda表达式入门]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的包装类--装箱与拆箱]]></title>
    <url>%2F2019%2F09%2F28%2FJava%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[Java的包装类–装箱与拆箱前言众所周知，Java是一种纯面向对象的语言（并不是说Java程序员都要看着女朋友编程），不像C++中既可以面向对象也可以面向过程。但是这不意味着Java当中全被的类型都是对象。之前我们也学过Java中的类型包括，对象和8种基本数据类型。之所以不将这八种基本数据类型是因为相对于对象来说，基本数据类型在使用是更加的方便，而且使用的效率上也是远远的高于对象类型。但是，在Java的一些类库中，并不支持对基本数据类型的操作，比如说集合类型。刚开始学Java的新手肯定会发现这样的一个问题。 List&lt;int&gt; list = new List&lt;int&gt;(); 上面的这种代码，估计八成就是从C++刚转到Java的新手写出的代码。 第一点List是一个接口，是不能够new的，我们只可以new出他的子类，比如我们经常使用的ArrayList。 第二点Java当中的集合类型并不支持基本数据类型，我们应该将基本数据类型转变为相应的包装类。 所以说正确的代码应该是 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 后面的&lt;&gt;中的类型是可以省略不写的，毕竟前面都已经写过了。 为什么不能使用基本数据类型？同样是面向对象的语言，Java和C++中的对象是不一样的。Java中对象和python有一点类型，他们都有一个终极的父类Object，所以说所有的对象肯定都是Object的子类。但是C++是不一样的。 现在我们考虑List中为什么不能使用基本数据类型，我们可以先看一下List如果不指定类型会怎么样。 List list2 = new ArrayList(); 我们发现这样的代码也可以通过，而且和上面的代码不一样，这个List中可以放任何类型的数据(除了基本数据类型)。为什么呢？因为如果不指定对应的类型的话，List这些容器就会默认指定类型为Object，而Java中的任何的对象都是Object类型的子类，所以说是可以放入的。(但是这样也有一个坏处，我们取出的数据类型也是Object，这时我们可能并不知道将这个数据转成什么样的类型，所以说最好还是要指定好类型)。但是基本数据类型不是对象，他们和Ojbect没有任何的联系，所以说基本数据类型是放不进去的。要想放进去，我们就必须要是基本数据类型和对象之间建立一种一一对应的联系。于是包装类出现了。 就比如说上面的Intger就是int类型的包装类。这个类中封装了一个基本数据类型。这个时候，当集合想要操作基本数据类型的时候，就可以转向基本数据类型的包装类进行操作。 包装类介绍下面就以int的包装类Integer为例进行包装类的说明。 java.lang.Object java.lang.Number java.lang.Integer public final class Integer extends Number implements Comparable&lt;Integer&gt; Integer类包装一个对象中的原始类型int的值。类型为Integer的对象包含一个单一字段，其类型为int 。 此外，该类还提供了一些将int转换为String和String转换为int ，以及在处理int时有用的其他常量和方法。 这个类的方法是非常多的，而且大多为static方法，比如说我们之前经常使用的String转为int的方法就是他的静态方法.Integet.parseInt(String num, int radix)第二个参数是指定进制，默认是十进制。 先看一个这个类的构造函数 Integer(int value) // 构造一个新分配的 Integer对象，该对象表示指定的 int值。 Integer(String s) // 构造一个新分配 Integer对象，表示 int由指示值 String参数。 然后就是他的所有的方法其实是没有必要一一去看的。下面说的是所有的包装类都有的方法。 第一个就是xxxValue()成员方法，返回这个包装类中封装的基本数据类型。如 int intValue() // 将 Integer的值作为 int 。 如果要是double的话就是doubleValue，char就是charValue。 第二个就是valueOf(xxx)静态方法，参数是一个基本的数据类型。比如说 static Integer valueOf(int i) // 返回一个 Integer指定的 int值的 Integer实例。 不过也可以是String，指定进制的那个可不是所有的包装类都有的，只是整形才有的方法。 static Integer valueOf(String s) // 返回一个 Integer对象，保存指定的值为 String 。 static Integer valueOf(String s, int radix) // 返回一个 Integer对象，保存从指定的String中 String的值，当用第二个参数给出的基数进行解析时。 这个方法的用法如下所示。 Integer i = Integer.valueOf(3); 还有另一种写法是 Integer i = new Integer(3); 这两种方法其实等价的，但是官方建议使用第一种方法，也就是valueOf()方法，这个方法更加的快一点。这个可能是和包装类的常量池有关，就比如我们使用String的时候使用String a = “hello”;而不推荐使用String a = new String(&quot;Hello&quot;);因为前者，一是可以加入String的常量池，方便以后再用，而是如果常量池中有的话也可以不用产生新的对象。毕竟Java的中的String是一种不可变类型，基本数据类型的包装类也是如此。好像有点儿扯远了。下面继续回到正题中来。的 上面我们介绍的虽然只是int的包装类，但是其余的包装类的使用其实也是差不多的，方法也都是差不多的。 下面来展示一下基本数据类型和他们的包装类型。 基本数据类型 包装类型 基本数据类型 包装类型 int Integer short Short char Character double Double boolean Boolean byte Byte long Long float Float 可以除了int和char变成了Integer和Character的全称之外，其余的包装类都是将首字母大小.(这就是Java的命名规则) 装箱与拆箱上面说到了Java当中的集合类型只可以放入基本数据类型的包装类，但是这一点确实有点违背我们的常识。比如这样的代码 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); 可以看到，这个list中我们放入的是1,但是1是一个基本数据类型。我们要放入的本应该是包装类型，却放入了基本数据。那么是真的放入了基本的数据类型吗？其实不然。 在jdk1.5之前这样写代码是错误的。jdk1.5之前，我们需要手动装箱，手懂拆箱。 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(Integer.valueOf(1)); // list.add(new Integer(1)); 但是jdk1.5之后，Java引入自动装箱，自动拆箱的机制。也就是虽然我们是list.add(1)，编译器会将1自动装箱成Integer数据类型，然后放入list中。这一点虽然从原码上看不出来，但是反编译Java的文件，我们甚至可以看出编译器调用的是Integer.valueOf(1)这个方法。 那什么又是拆箱呢？比如如下的代码 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); int a = list.get(1); 从上面的知识我们应该知道了，list.get()返回的应该是Object的子类Integer，但是我们确实使用int类型来接受返回值的，这就有点奇怪了。其实这就是自动拆箱。通过反编译Java class文件，我们可以知道调用的intValue方法。也就是Java编译器自动调用intValue方法将Integer中封装的int数据赋值给了左面的int变量。 进一步研究装箱与拆箱通过上面的研究，我们已经知道了Java中的基本类型和包装类是可以直接相互赋值的。比如一下的代码都是正确的 int a = Integer.valueof(3); Integer b = 3; 那么除了赋值，加减乘除有如何呢？比如下面代码。 Integer a = 3; int b = a + 4; Integer c = a + b; 上面的代码都是正常运行的，可以说明Java的自动装箱拆箱机制还是非常聪明的，基本上和使用原来的基本数据类型一样。为啥是基本上？？？原因下面再说。 我们先看看第三行代码，a是int，b是Integer。他们两个是不同的类型的。那么Java是装箱呢？还是拆箱呢？这个问题其实不难回答。加入说是装箱的话，变成了两个Integer相加，不过Java中是没有运算符重载的，两个对象加个毛线啊，是加不了的。(我知道String对象是可以加的，不过那个也不算是运算符重载实际上。。。)。所以说我们只能拆箱，变成两个int相加，然后将结果装箱赋值给左面的Integer对象。 由此我们可以知道，当包装类在进行加减乘除的运算的时候，会拆箱成基本的数据类型进行运算。 上面说了使用包装类其实并不能和使用基础数据类型完全一模一样，下面来举了例子。 short a = 1; short b = 2; a += b; // if it is &#39;a = a + b&#39;, it will be error! Short a = 1; Short b = 2; a += b; // Error!! 上面的使用基本数据类型是对的，下面的是错误的。可能很多人都看不出来对与错，大概率是因为不懂+=这个符号的含义。其实上面的a += b就是相当于a = (short)(a + b);两个short值相加是一个int,这个知识点确实是很多人的盲区。int虽然不可以直接赋值给short，但是+=自带了一个强转，而int是可以强转为short的。再看看下面的代码，a += b是相当于a = (Short)(a + b);这里我们是要将一个int的值转为一个Short，这明显是不可能的。所以说这行代码将会报错了。综上所述，可以使用基本数据类型的时候，我们非要使用他的包装类，这不是闲得蛋疼嘛。别没事找事干就不会有什么问题。 不过还有一个特殊的云算符==,这个符号似乎是既可以应用于对象之间也可以应用于基本数据之间。对象还有一个equals()方法与==的作用相似。之前我写过东西谈过这个问题了。这里不再赘述这个问题了。举例说明。 Integer a = 3; Integer b = 3; int c = 3; System.out.println(a == b); // true System.out.println(a == c); // true System.out.println(a.equals(b)); // true System.out.println(a.equals(c)); // true 可以看到上面的三个结果都是true。看一下Integer中的equals()方法的源码。 public boolean equals(Object obj) { if (obj instanceof Integer) { return value == ((Integer)obj).intValue(); } return false; } 可以看到是做了重写的（重写了Object的equals()方法）。而且是比较包装类中的值。 那么现在来看一下第五行的代码，一个int值和Integer类对象进行==比较。究竟是将int装箱呢？还是将Integer拆箱呢？这两种方法好像是都可以的，毕竟无论是对象还是基本数据类型都是可以使用==操作符的。不过Java采用的是将Integer拆箱。为什么呢？知道==和equals()的区别的人应该都不会意外。对象的==比较的是地址（引用），如果把int装箱，这个地址都不是之前我们可以决定的，又有什么比较的意义呢？ 不过现在你可能有所发现，==比较的是地址，为何第四行输出的也是true?? 这个就是另外的一个问题了。且听下面慢慢道来。 包装类的缓存之前我们或许都遇到过关于String缓存的例子。(上面我也谈到了缓存这一块的知识了). String a = &quot;Hello World&quot;; String b = new String(&quot;Hello World&quot;); String c = &quot;Hello World&quot;; String d = new String(&quot;Hello World&quot;); System.out.println(a == b); // false System.out.println(a == c); // true System.out.println(b == d); // false 上面的第四行和第五行的输出结果相异，主要就是因为String常量池。我们使用String xx = “xxx;”的方式声明一个String变量的时候，系统会将这个“xxx”放入常量池。（毕竟String是一个不可变的对象），然后将地址赋给xx。下面如果还有String变量的值和这个常量池中相等的话，就不会新建String对象，会直接返回常量池中的String对象。所以说上面的a和c的地址相同的。使用new String(&quot;xxx&quot;);的方式声明的String对象虽然也是不可变的对象，不过他位于堆中而不是常量池中。所以说他们的地址是不相等的。 那么上面说提及的包装类是不是也是这么个情况呢？写个代码测试一下. public class Test { public static void main(String[] args) { Integer a = -200; Integer b = -200; Integer c = -100; Integer d = -100; Integer e = 100; Integer f = 100; Integer g = 200; Integer h = 200; System.out.println(a == b); // false System.out.println(c == d); // true System.out.println(e == f); // true System.out.println(g == h); // false } } 在我写这个代码的时候，idea就一直提示我，不要使用==用于包装类的比较，建议使用equals()。这个和String的比较倒是非常类似的，都是建议使用equals()方法。不过这个结果就和String类非常的不类似了，竟然不是都输入true,还有的输入的是false。 这到底是什么原因呢？我开始查阅资料，和观察Integer的源码。发现了这样的一个类。 /** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size&gt;} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * jdk.internal.misc.VM class. * * WARNING: The cache is archived with CDS and reloaded from the shared * archive at runtime. The archived cache (Integer[]) and Integer objects * reside in the closed archive heap regions. Care should be taken when * changing the implementation and the cache array should not be assigned * with new Integer object(s) after initialization. */ private static class IntegerCache { static final int low = -128; static final int high; static final Integer[] cache; static Integer[] archivedCache; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) { try { h = Math.max(parseInt(integerCacheHighPropValue), 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(h, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; // Load IntegerCache.archivedCache from archive, if possible VM.initializeFromArchive(IntegerCache.class); int size = (high - low) + 1; // Use the archived cache if it exists and is large enough if (archivedCache == null || size &gt; archivedCache.length) { Integer[] c = new Integer[size]; int j = low; for(int i = 0; i &lt; c.length; i++) { c[i] = new Integer(j++); } archivedCache = c; } cache = archivedCache; // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; } private IntegerCache() {} } 其实这个代码一点都看不懂，不过看看上面的文档就可以的。文档中说 缓存以支持JLS要求的自动装箱的对象标识语义，其值介于-128和127（含）之间。 首次使用时会初始化缓存。 缓存的大小可以由{@code -XX：AutoBoxCacheMax = &lt;size&gt;}选项控制。 在VM初始化期间，可以设置java.lang.Integer.IntegerCache.high属性并将其保存在jdk.internal.misc.VM类的私有系统属性中。 警告：缓存是使用CDS存档的，并在运行时从共享存档中重新加载。 归档的缓存（Integer []）和Integer对象位于封闭的归档堆区域中。 更改实现时应注意，初始化后不应为缓存数组分配新的Integer对象。 第一点就是告诉我们，如果我们不指定的话，系统将会默认缓存[-128, 127]之间的包装类。后面就是我们修改缓存大小的方式。 这样我们就明白了为什么上面的有一些是是输出的true，而有一些是输出的false。原因是在于-200和200已经不在Integer的缓存的范围中了，所以需要另外的构建对象，因而返回false。而-100和100在缓存的范围当中，所以直接获取了缓存的值。因而返回true。 我们也可以来看看Integer.valueOf()方法，这个方法中也有缓存的体现。 @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 上面的if当中的范围就是缓存的范围。如果不在缓存中的范围的时候才去new一个Integer对象。 那么除了Integer类，其余的包装类的缓存范围又是多少呢？ 包装类型 缓存范围 包装类型 缓存范围 Boolean true, false（全部） Byte [-128, 127]（全部） Short [-128, 127] Character [0, 127] Integer [-128, 127] Long [-128, 127] Float 无 Double 无 其实他们的缓存值还是非常有规律的。浮点值类型没有缓存值，布尔类型只有两个值当然都要缓存。至于其他的都是[-128, 127]。不过因为Character是没有负值的，所以去掉了负数的部分。 其实缓存值中只有Integer是最特殊的。我们是可以修改Integer缓存的上限的。(127是最低的上限)。Integer的下限-128是固定的不能修改的。至于如何修改上限，这里就不折腾了。可以干，但是没有必要。 总结Java当中的包装类可谓是一个非常重要而且非常常用的一个类。关键是用到的时候你或许还没意识到自己已经用到了这个类了，这就是所谓的自动装箱和自动拆箱。既然这个类这么常用，我们就势必应该缓存这个类的常用的部分，以便后面多次使用节省时间和内存，这就是所谓的包装类的缓存。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO应用——文件分割]]></title>
    <url>%2F2019%2F09%2F27%2FIO%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[IO应用——文件分割介绍很多下载软件下载的速度飞快是因为使用了多线程下载（至于多线程的知识，后面还是会学习的），将文件分割成不同的小块，然后不同的小块同时下载，最后再将这些小块的文件进行合并，这样下载就完成了，这样可以显著的提高下载的速度。这里我们显然不是做一个这样的下载器，而是做其中的一部分，将文件分割成许多小块，然后再将这些小文件合并。 思路其实之前没有看过任何人的思路或者写法，我就自己就我之前学过的IO流的知识来实现这个功能。其实说简单也不简单。能用就行其实确实是可以用，不过代码中的漏洞或者交互性应该是很差的。 我的代码public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; try { File file = new File(src); fis = new FileInputStream(file); byte[] buff = new byte[(int) file.length() / num + 1]; fis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest + a)); fos.write(buff); fos.flush(); a++; fis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest, int num) { FileInputStream fis = null; FileOutputStream fos = null; int a = 1; try { fos = new FileOutputStream(new File(dest)); while (a &lt;= num) { File file = new File(src + a); fis = new FileInputStream(file); fos.write(fis.readAllBytes()); a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (fis != null) { fis.close(); } if (fos != null) { fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/test.jpg&quot;, &quot;D:/dst&quot;, 10); merge(&quot;D:/dst&quot;,&quot;D:/merge.jpg&quot;,10); } } 这个思路故事是个人都会做。不过这个代码的问题也是非常的大的。在分割图片你的时候或许我们察觉不到分割后然后合并的文件和之前的文件有什么区别，但是分割文本文件额时候，不一样的地方就非常的明显了。我们可以轻易的发现，文本的最后会多出一点儿的内容，而且这一点儿的内容非常的奇怪，我也不清楚这一小块的内容是从哪儿来的。现在也非常的惆怅。我真的是喵了个咪了！ 为什么会出现最后多出了一部分你的内容呢？是因为我们没有考虑到最后一块的大小，一般来说最后一块的大小肯定是要比前面的几块都要小的，所以说在写入最后一块的时候不能再用前面的大小。 经过修改后的代码 如下所示 package com.sher.ioinjava; import java.io.*; /** * @author SHeR * @time 9/27/2019 8:36 PM * @describe */ public class FileSplit { public static void split(String src, String dest, int num) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; try { File file = new File(src); if (!file.isFile()) { throw new IllegalArgumentException(&quot;Src must be a file&quot;); } File dst = new File(dest); if (!dst.exists()){ if (!dst.mkdir()){ return; } } fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[(int) file.length() / num + 1]; int cot = bis.read(buff); int a = 1; while (a &lt;= num) { fos = new FileOutputStream(new File(dest +&quot;/&quot;+ a)); bos = new BufferedOutputStream(fos); bos.write(buff, 0, cot); bos.flush(); a++; cot = bis.read(buff); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); byte[] buff = new byte[1024]; int cot = -1; while ((cot = bis.read(buff))!=-1){ bos.write(buff, 0, cot); } a++; } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } public static void main(String[] args) { split(&quot;Exercise/src/SimpleInput.java&quot;, &quot;D:/dst&quot;, 3); merge(&quot;D:/dst&quot;,&quot;D:/hello.java&quot;); } } 经过我的测试，上面的代码基本上是没什么错误的地方了。那么这个题目我们就算是完成了。思路大概就是分割的时候一个输入流多个输出流，合并的时候一个输出流多个输入流。 不过这个代码并不能说是很完善的，我们看一下别人写的代码。 package com.sher.ioinjava; import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.Vector; /** * @author SHeR * @time 9/28/2019 11:30 AM * @describe */ public class SplitFile { //源头 private File src; //目的地(文件夹) private String destDir; //所有分割后的文件存储路径 private List&lt;String&gt; destPaths; //每块大小 private int blockSize; //块数: 多少块 private int size; public SplitFile(String srcPath,String destDir) { this(srcPath,destDir,1024); } public SplitFile(String srcPath,String destDir,int blockSize) { this.src =new File(srcPath); this.destDir =destDir; this.blockSize =blockSize; this.destPaths =new ArrayList&lt;String&gt;(); //初始化 init(); } //初始化 private void init() { //总长度 long len = this.src.length(); //块数: 多少块 this.size =(int) Math.ceil(len*1.0/blockSize); //路径 for(int i=0;i&lt;size;i++) { this.destPaths.add(this.destDir +&quot;/&quot;+i+&quot;-&quot;+this.src.getName()); } } /** * 分割 * 1、计算每一块的起始位置及大小 * 2、分割 * @throws IOException */ public void split() throws IOException { //总长度 long len = src.length(); //起始位置和实际大小 int beginPos = 0; int actualSize = (int)(blockSize&gt;len?len:blockSize); for(int i=0;i&lt;size;i++) { beginPos = i*blockSize; if(i==size-1) { //最后一块 actualSize = (int)len; }else { actualSize = blockSize; len -=actualSize; //剩余量 } splitDetail(i,beginPos,actualSize); } } /** * 指定第i块的起始位置 和实际长度 * @param i * @param beginPos * @param actualSize * @throws IOException */ private void splitDetail(int i,int beginPos,int actualSize ) throws IOException { RandomAccessFile raf =new RandomAccessFile(this.src,&quot;r&quot;); RandomAccessFile raf2 =new RandomAccessFile(this.destPaths.get(i),&quot;rw&quot;); //随机读取 raf.seek(beginPos); //读取 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=raf.read(flush))!=-1) { if(actualSize&gt;len) { //获取本次读取的所有内容 raf2.write(flush, 0, len); actualSize -=len; }else { raf2.write(flush, 0, actualSize); break; } } raf2.close(); raf.close(); } /** * 文件的合并 * @throws IOException */ public void merge(String destPath) throws IOException { //输出流 OutputStream os =new BufferedOutputStream( new FileOutputStream(destPath,true)); Vector&lt;InputStream&gt; vi=new Vector&lt;InputStream&gt;(); SequenceInputStream sis =null; //输入流 for(int i=0;i&lt;destPaths.size();i++) { vi.add(new BufferedInputStream(new FileInputStream(destPaths.get(i)))); } sis =new SequenceInputStream(vi.elements()); //拷贝 //3、操作 (分段读取) byte[] flush = new byte[1024]; //缓冲容器 int len = -1; //接收长度 while((len=sis.read(flush))!=-1) { os.write(flush,0,len); //分段写出 } os.flush(); sis.close(); os.close(); } public static void main(String[] args) throws IOException { SplitFile sf = new SplitFile(&quot;Exercise/src/SimpleInput.java&quot;,&quot;dest&quot;) ; sf.split(); sf.merge(&quot;aaa.java&quot;); } } 里面使用了两个新的流RandomAccessFile和SequenceInputStream。我们可以稍微学习一下这个流，然后对我们直接的代码进行一些改进。 不过我发现使用上面的第一个类好像更加的繁琐，而且我完全没有必须去随机读取，所有说使用上面的第一个流就是没事找事干的。而上面的第二个流是将多个输入流合成一个输入流，使用后面操作更加的简单，我感觉这个功能还是稍微可以的。所以说这个可以有！ 原来的分割文件的代码我没有进行修改，合并文件的方法我使用了SequenceInputStream进行了修改。修改后代码如下所示： public static void merge(String src, String dest) { FileInputStream fis = null; BufferedInputStream bis = null; FileOutputStream fos = null; BufferedOutputStream bos = null; File srcDir = new File(src); if (!srcDir.exists()) { throw new RuntimeException(&quot;Src does not exist!&quot;); } File [] files = srcDir.listFiles(); if (files == null) { throw new RuntimeException(&quot;Src is empty&quot;); } int num = files.length; SequenceInputStream sinput = null; Vector&lt;InputStream&gt; vector = new Vector&lt;&gt;(); int a = 1; try { fos = new FileOutputStream(new File(dest)); bos = new BufferedOutputStream(fos); while (a &lt;= num) { File file = new File(src + &quot;/&quot; + a); fis = new FileInputStream(file); bis = new BufferedInputStream(fis); vector.add(bis); a++; } sinput = new SequenceInputStream(vector.elements()); int cot = -1; byte[] buff = new byte[1024]; while ((cot = sinput.read(buff))!=-1){ bos.write(buff, 0, cot); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (bis != null) { bis.close(); } if (bos != null) { bos.close(); } if (sinput != null) { sinput.close(); } } catch (IOException e) { e.printStackTrace(); } } } 其实修改的地方并不多，只是将多个输入流整合成一个输入流了而已。 总结上面的虽然是一个简单的应用，不过也会出不少的细节上面的小问题。所以说，解决了这个问题，对我们对IO的理解还是有一定的帮助的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Commons IO简介]]></title>
    <url>%2F2019%2F09%2F26%2FApache%20Commons%20IO%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Apache Commons IO简介 之前一直学的都是Java中IO的知识，使用起来基本上都是那个一个样，说实话我确实是有点儿感到厌倦了。于是世界上著名的开源组织阿帕奇(Apache)将Java中的IO进行了封装写了Commons IO这个玩意。这个是需要从阿帕奇的光网上面去下载的，因为这个并不是jdk自带的库。下载完之后还自带了源码以及官方文档，不过都是英文的，，这就非常考验我的能力了。 先看一下这个Commons IO 由哪些东西组成。 org.apache.commons.io // This package defines utility classes for working with streams, readers, writers and files. org.apache.commons.io.comparator // This package provides various Comparator implementations for Files. org.apache.commons.io.filefilter // This package defines an interface (IOFileFilter) that combines both FileFilter and FilenameFilter. org.apache.commons.io.input // This package provides implementations of input classes, such as InputStream and Reader. org.apache.commons.io.monitor // This package provides a component for monitoring file system events (directory and file create, update and delete events). org.apache.commons.io.output // This package provides implementations of output classes, such as OutputStream and Writer. org.apache.commons.io.serialization // This package provides a framework for controlling the deserialization of classes. 上面的这所只言片语，说实话我是什么都看不懂的，如果不是对Commons IO的体系有足够的了解，是肯定看不懂的。就像给我们一开始看那个Java io的体系图，我们也肯定是看的一脸懵逼的吖~~ 而且上面的并不是一些类而已，只是一些包，每个包中还有非常多的类，每个类中又有非常多的方法。所以说不可能一个一个去学习的，只能寻找自己需要的去学，这里就看一下别人的博客,毕竟我对这个玩意是一点也不了解。 Apache Commons IO入门教程 这个博客写了一点，但是我感觉写的并不怎么样，看了也没什么收获。下面我就直接上一些这个类的常用方法的代码吧。 文件或者文件夹的大小public class TestCommonIo { public static void main(String[] args) { long len1 = FileUtils.sizeOf(new File(&quot;test&quot;)); long len2 = FileUtils.sizeOf(new File(&quot;./Exercise/src&quot;)); System.out.println(len1); System.out.println(len2); } } 上面的第一个就是文件的大小，第二个是文件夹的大小，使用的方法是一样的。对于计算一个文件的大小，这还是非常简单的，使用length()方法就可以了，不过计算文件夹的代码确实要进行递归的操作，可以说要考虑的东西很多，而且也很繁琐。 我们可以看一下这个方法的源码 public static long sizeOf(final File file) { if (!file.exists()) { final String message = file + &quot; does not exist&quot;; throw new IllegalArgumentException(message); } if (file.isDirectory()) { return sizeOfDirectory0(file); // private method; expects directory } else { return file.length(); } } 可以看到源码中专门写了一个函数来计算文件夹的大小 private static long sizeOfDirectory0(final File directory) { final File[] files = directory.listFiles(); if (files == null) { // null if security restricted return 0L; } long size = 0; for (final File file : files) { try { if (!isSymlink(file)) { size += sizeOf0(file); // internal method if (size &lt; 0) { break; } } } catch (final IOException ioe) { // Ignore exceptions caught when asking if a File is a symlink. } } return size; } private static long sizeOf0(final File file) { if (file.isDirectory()) { return sizeOfDirectory0(file); } else { return file.length(); // will be 0 if file does not exist } } 简单的看一下确实也是使用递归的方法来计算文件夹的大小的。 列出文件static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, null); for (File file : files) { System.out.println(file.getName()); } } listFiles函数的第一个参数是待列的文件夹，第二个参数是文件过滤器（这里使用的是非空过滤器），第三个参数是文件夹过滤器（使用null就是表示不列出文件夹） static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), EmptyFileFilter.NOT_EMPTY, DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 使用这个方法就可以列出所有的文件，包括文件夹以及文件夹里面的内容。还有一种常用的文件过滤器是后缀名过滤。比如说我只想要后缀为Java的非空的文件，可以这样写。 static void test2() { Collection&lt;File&gt; files = FileUtils.listFiles( new File(&quot;./Exercise/src&quot;), FileFilterUtils.and(new SuffixFileFilter(&quot;java&quot;), EmptyFileFilter.NOT_EMPTY), DirectoryFileFilter.INSTANCE); for (File file : files) { System.out.println(file.getName()); } } 可以使用FileFilterUtils.and,FileFilterUtils.or或者FileFilterUtils.or来组织过滤器之间的逻辑，比如上面的就是以java为后缀名的并且非空的文件。 读取内容static void test3() { try { String msg = FileUtils.readFileToString(new File(&quot;hony&quot;), StandardCharsets.UTF_8); System.out.println(msg); byte[] b = FileUtils.readFileToByteArray(new File(&quot;hony&quot;)); System.out.println(new String(b, StandardCharsets.UTF_8)); List&lt;String&gt; lines = FileUtils.readLines(new File(&quot;hony&quot;), StandardCharsets.UTF_8); for (String line : lines) { System.out.println(line); } LineIterator lineIterator = FileUtils.lineIterator(new File(&quot;hony&quot;), &quot;UTF-8&quot;); while (lineIterator.hasNext()) { System.out.println(lineIterator.nextLine()); } } catch (IOException e) { e.printStackTrace(); } } 读取文件中的内容主要有上面的四种方式，无论哪一种都是比我们使用原始的Java IO流方便多了。 第一种是直接将文件中的内容读取到一个String对象中。第二种则是读取到字节数组中。 第三种是将文件的每一行都放入到一个List中。第四种方式倒是有点儿特殊，是使用迭代器的方式进行遍历文件的。 写出内容static void test4() { try { FileUtils.write(new File(&quot;happy.txt&quot;), &quot;I am happy1!&quot;, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;happy.txt&quot;), &quot;I am happy2!&quot;, StandardCharsets.UTF_8, true); FileUtils.writeByteArrayToFile(new File(&quot;happy.txt&quot;), &quot;I am happy3!&quot;.getBytes(StandardCharsets.UTF_8), true); List&lt;String&gt; datas = new ArrayList&lt;&gt;(); datas.add(&quot;sher&quot;); datas.add(&quot;hony&quot;); datas.add(&quot;sherhony&quot;); FileUtils.writeLines(new File(&quot;happy.txt&quot;), datas, &quot;\r\n&quot;, true); } catch (IOException e) { e.printStackTrace(); } } 写出到文件中同样有以上的好几种方式。上面函数的第四个参数都是代表是否一追加的形式写入到文件当中，在Java原始流当中也是使用的这种方式。不过下面的FileUtils.writeLines方法的第三个参数不再是编码了，而是分隔符，也就是说写入的这些data之间用什么隔开，这里我是用的是windows下的换行符。 拷贝拷贝包括拷贝文件或者说的是拷贝文件夹，拷贝文件的操作我们已经做过了，但是拷贝文件夹的操作是有点儿复杂，需要递归的操作。不过这个commons io提供给我们一个十分方便地方法。 static void test5() { try { FileUtils.copyFile(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;Exercise/src/test-copy.jpg&quot;)); FileUtils.copyFileToDirectory(new File(&quot;Exercise/src/test.jpg&quot;), new File(&quot;D:/&quot;)); FileUtils.copyDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/out-copy&quot;)); FileUtils.copyDirectoryToDirectory(new File(&quot;Exercise/out&quot;), new File(&quot;Exercise/src&quot;)); String url = &quot;http://i1.hdslb.com/bfs/archive/9cc5e3fcc7d6c48e5a0d8d3dd8bbb6ed11937f89.jpg&quot;; FileUtils.copyURLToFile(new URL(url), new File(&quot;Exercise/src/miaonei.jpg&quot;)); String baidu = &quot;http://www.baidu.com&quot;; String wangyi = &quot;http://www.163.com&quot;; String bd = IOUtils.toString(new URL(baidu), StandardCharsets.UTF_8); String wy = IOUtils.toString(new URL(wangyi), &quot;GBK&quot;); FileUtils.writeStringToFile(new File(&quot;Exercise/src/baidu.txt&quot;), bd, StandardCharsets.UTF_8); FileUtils.writeStringToFile(new File(&quot;Exercise/src/wangyi.txt&quot;), wy, &quot;GBK&quot;); } catch (IOException e) { e.printStackTrace(); } } 上面是拷贝的常见的操作。可以看到这个方法是什么的方便的。不过需要注意的是，从网络流中拷贝东西（也就是下载东西）的时候，如果是文字的话（也就网页的代码），可以使用IOUtils.toString方法，这个方法可以指定字符的编码。 总结上面就是Commons IO中简单的常用的一些操作，不过Commons IO这么强大的库怎么可能就这么一点点功能，只不过其余的功能太过与强大，而且并不是经常用到，所以现在可以不用了解。现在就是简单的看看这个类，知道有这么个玩意就行了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-06]]></title>
    <url>%2F2019%2F09%2F26%2FJava%E4%B8%AD%E7%9A%84IO-06%2F</url>
    <content type="text"><![CDATA[Java 中的IO-06回顾其实之前我们已经学过了Java IO中的主要的一些流，剩下来的流基本上都是一个套路没有必要一个一个再去研讨。下面是Java IO中的一个体系图。 Java IO中主要分为了四大抽象类，然后各种流都是继承于这些抽象类，实现这些抽象类的方法。下面的图中有的是我每次学过的，有的是我们没看过的，有的还是Java中已经废弃了的，不过其实我们也完全没有必要按照这个图再去将其余的流再去学习一次，我们学习java IO其实是学习的Java IO 的思路。即使我们遇到一个陌生的流，我们也完全可以应付的来。 回到Hello World我们对IO流的学习其实是源于Hello world的输出，当时我们不知道，现在我们知道了System.out其实就是一个流对象，调用println()方法就是向控制台中输出信息。而当我们想要获取键盘的输入的时候我们使用的是System.in这个流，一般情况下，我们使用的方式是 Scanner in = new Scanner(System.in); String str = in.next(); int num = in.nextInt(); 这个Scanner就是Java为了方便我们处理键盘的输入而产生的类。不过我们也可以使用我们之前的方式读取键盘的输入。 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in)); String s = bufferedReader.readLine(); int a = Integer.parseInt(bufferedReader.readLine()); System.out.println(s + a); 不过可以清晰的看到这个方法是有一点儿烦的，所以说使用Scanner在读取控制台的输入还是非常的方便而且简单的。 不过这个Scanner并不是只可以读取控制的输入的，也可以读取文件。只要是流都是可以读取的。更好的是这个类有hasNext等一系列的方法，所以说上面的scanner代码可以修改一下。 Scanner in = new Scanner(System.in); if (in.hasNext()){ String str = in.next(); } if (in.hasNextInt){ int num = in.nextInt(); } 下面来演示一下使用Scanner来读取文件的操作，其实是一样的，文件流和控制台的标准流都是流。 private static void scannerReadFile() { // Use Scanner to read file! final String path = &quot;C:/Users/SHeR/IdeaProjects/Exercise/src/com/sher/corejava/hello/file.txt&quot;; Scanner scanner = null; try { scanner = new Scanner(Path.of(path), StandardCharsets.UTF_8); while (scanner.hasNextLine()) { System.out.println(scanner.nextLine()); } } catch (IOException e) { e.printStackTrace(); } finally { if (scanner != null) { scanner.close(); } } } System.in是一个OnputStream，但是System.out并不是OutputStream而是一个叫PrintWriter的玩意，这就是很好奇了。现在我们来看一看这个PrintWriter是一个什么玩意。 PrintWriter看到这个类是以Writer结尾的，我们立马就知道了，这是一个字符流。不过也对，我们想控制台输入的肯定是字符啊。输入字节我们也是看不懂的，这是没必要的。先观察一下这个类的官方文档再说。 java.lang.Object java.io.Writer java.io.PrintWriter public class PrintWriter extends Writer 将对象的格式表示打印到文本输出流。这个类实现了全部在发现print种方法PrintStream 。它不包含用于编写原始字节的方法，程序应使用未编码的字节流。 不像PrintStream类，如果启用自动刷新，它只会在调用的println，printf，或format方法来完成，而不是当一个换行符恰好是输出。 这些方法使用平台自己的行分隔符而不是换行符。 这个类中的方法不会抛出I / O异常，尽管它的一些构造函数可能。 客户可以通过调用checkError()查询是否发生错误。 PrintWriter(File file) // 使用指定的文件创建一个新的PrintWriter，而不需要自动的线路刷新。 PrintWriter(File file, String csn) // 使用指定的文件和字符集创建一个新的PrintWriter，而不需要自动进行线条刷新。 PrintWriter(OutputStream out) // 从现有的OutputStream创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(OutputStream out, boolean autoFlush) // 从现有的OutputStream创建一个新的PrintWriter。 PrintWriter(String fileName) // 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行行刷新。 PrintWriter(String fileName, String csn) // 使用指定的文件名和字符集创建一个新的PrintWriter，而不需要自动线路刷新。 PrintWriter(Writer out) // 创建一个新的PrintWriter，没有自动线冲洗。 PrintWriter(Writer out, boolean autoFlush) //创建一个新的PrintWriter。 PrintWriter append(char c) // 将指定的字符附加到此作者。 PrintWriter append(CharSequence csq) // 将指定的字符序列附加到此作者。 PrintWriter append(CharSequence csq, int start, int end) // 将指定字符序列的子序列附加到此作者。 boolean checkError() // 如果流未关闭，请刷新流并检查其错误状态。 protected void clearError() // 清除此流的错误状态。 void close() // 关闭流并释放与之相关联的任何系统资源。 void flush() // 刷新流。 PrintWriter format(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 PrintWriter format(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入此写入程序。 void print(boolean b) // 打印布尔值。 void print(char c) // 打印一个字符 void print(char[] s) // 打印字符数组。 void print(double d) // 打印双精度浮点数。 void print(float f) // 打印浮点数。 void print(int i) // 打印一个整数。 void print(long l) // 打印一个长整数。 void print(Object obj) // 打印一个对象。 void print(String s) // 打印字符串。 PrintWriter printf(Locale l, String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 PrintWriter printf(String format, Object... args) // 使用指定的格式字符串和参数将格式化的字符串写入该writer的方便方法。 void println() // 通过写入行分隔符字符串来终止当前行。 void println(boolean x) // 打印一个布尔值，然后终止该行。 void println(char x) // 打印一个字符，然后终止该行。 void println(char[] x) // 打印字符数组，然后终止行。 void println(double x) // 打印双精度浮点数，然后终止行。 void println(float x) // 打印一个浮点数，然后终止该行。 void println(int x) // 打印一个整数，然后终止该行。 void println(long x) // 打印一个长整型，然后终止行。 void println(Object x) // 打印一个对象，然后终止该行。 void println(String x) // 打印一个字符串，然后终止行。 protected void setError() // 表示发生错误。 void write(char[] buf) // 写入一个字符数组。 void write(char[] buf, int off, int len) // 写一个字符数组的一部分。 void write(int c) // 写一个字符 void write(String s) // 写一个字符串 void write(String s, int off, int len) // 写一个字符串的一部分。 可以看到这个类虽然方法很多，不过基本上都是重载的方法。也就是print,printf,println这三个方法。 下面来个代码来演示一下这个流的使用。 private static void printWriterFile() { PrintWriter printWriter = null; try { printWriter = new PrintWriter(&quot;Hello.txt&quot;, StandardCharsets.UTF_8); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world\nhello core java&quot;); } catch (IOException e) { e.printStackTrace(); } finally { if (printWriter != null) { printWriter.close(); } } } 从上面的构战函数可以得知，也可以从现有的OutputStream的基础上创建PrintWriter。所以上面的代码等价于 private static void printWriterFile() { FileOutputStream fileOutputStream = null; PrintWriter printWriter = null; try { fileOutputStream = new FileOutputStream(new File(&quot;hello.txt&quot;)); printWriter = new PrintWriter(fileOutputStream); printWriter.println(&quot;hello printWriter&quot;); printWriter.println(&quot;hello world&quot;); printWriter.println(&quot;hello hello&quot;); printWriter.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (fileOutputStream != null) { fileOutputStream.close(); } if (printWriter != null) { printWriter.close(); } } catch (IOException e) { e.printStackTrace(); } } } 注意：上面代码的第十行代码是必须的，不然文件中不会产生任何的数据。其实每次输出都可以刷新一下缓冲的。 上面说了PrintWriter那么是否有PrintReader呢？答案是没有的，，，至于为什么，好好想想去伐。。。 总结到此为此，对IO的学习基本上已经结束了。下面的一个将会讲一讲Commons IO这个玩意，那时候也就是IO真正的结束了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-05]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-05%2F</url>
    <content type="text"><![CDATA[Java中的IO-05引言上一篇文章中我们谈及了字节数组流以及字符数组流，这些流虽然不常见，但是在一定时候却能发挥巨大的作用。这里我们要学习的不是和数组有关的了，而是和Java中的数据类型有关的流。众所周知，Java中的数据分为基本数据类型还有对象，那么我就从基本数据类型开始说起吧。 DataInputStream, DateOutputStream这两个流的使用方式也是非常简答的。简单的看看官方文档就行了。 java.lang.Object java.io.InputStream java.io.FilterInputStream java.io.DataInputStream public class DataInputStream extends FilterInputStream implements DataInput 数据输入流允许应用程序以独立于机器的方式从底层输入流读取原始Java数据类型。应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据。 DataInputStream对于多线程访问来说不一定是安全的。 线程安全是可选的，是本课程中用户的责任。 DataInputStream(InputStream in) // 创建使用指定的底层InputStream的DataInputStream。 int read(byte[] b) // 从包含的输入流中读取一些字节数，并将它们存储到缓冲区数组 b 。 int read(byte[] b, int off, int len) // 从包含的输入流读取最多 len个字节的数据为字节数组。 boolean readBoolean() // 见的总承包 readBoolean的方法 DataInput 。 byte readByte() // 见的总承包 readByte的方法 DataInput 。 char readChar() // 见 readChar方法的总合同 DataInput 。 double readDouble() // 见 readDouble方法 DataInput的总体合同。 float readFloat() // 见 readFloat法 DataInput的一般合同。 void readFully(byte[] b) // 见的总承包 readFully的方法 DataInput 。 void readFully(byte[] b, int off, int len) // 见的总承包 readFully的方法 DataInput 。 int readInt() // 见 readInt方法 DataInput的一般合同。 String readLine() /*已弃用 此方法无法将字节正确转换为字符。 从JDK 1.1开始，读取文本行的BufferedReader.readLine()方法是通过BufferedReader.readLine()方法。 使用DataInputStream类读取行的程序可以转换为使用BufferedReader类替换以下形式的代码： DataInputStream d = new DataInputStream(in); 与： BufferedReader d = new BufferedReader(new InputStreamReader(in)); */ long readLong() // 见的总承包 readLong的方法 DataInput 。 short readShort() // 见 readShort方法 DataInput的一般合同。 int readUnsignedByte() // 见的总承包 readUnsignedByte的方法 DataInput 。 int readUnsignedShort() // 见 readUnsignedShort法 DataInput的一般合同。 String readUTF() // 见 readUTF法 DataInput的一般合同。 static String readUTF(DataInput in) // 从流in读取以modified UTF-8格式编码的Unicode字符串的表示; 这个字符串然后作为String返回。 int skipBytes(int n) // 见 skipBytes法 DataInput的一般合同。 这些方法倒也是非常容易理解的。下面直接给出代码举例吧。 代码举例public class DataStreamDemo { public static void main(String[] args) { DataOutputStream out = null; BufferedReader br = null; byte[] a= &quot;sheriby\nsheriby\nhonysher&quot;.getBytes(StandardCharsets.UTF_8); try { DataInputStream in = new DataInputStream(new ByteArrayInputStream(a)); out = new DataOutputStream(new FileOutputStream(&quot;./Exercise/src/sher2&quot;)); br = new BufferedReader(new InputStreamReader(in)); String line; while ((line = br.readLine()) != null) { String temp = line.toUpperCase(); out.writeChars(temp); out.writeChar(&#39;\n&#39;); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (out != null) { out.close(); } if (br != null) { br.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实上面的这个代码的示例并不是非常的典型，所谓的典型的用法其实是下面的这个用法。 public class DataStreamDemo2 { public static void main(String[] args) { DataOutputStream out = null; DataInputStream in = null; try { out = new DataOutputStream(new FileOutputStream(&quot;test&quot;)); out.writeInt(2); out.writeDouble(3.1415926); out.writeUTF(&quot;sher is the best boy!&quot;); out.writeBoolean(false); in = new DataInputStream(new FileInputStream(&quot;test&quot;)); System.out.println(in.readInt()); System.out.println(in.readDouble()); System.out.println(in.readInt()); System.out.println(in.readUTF()); System.out.println(in.readBoolean()); } catch (Exception e) { e.printStackTrace(); } finally { try { if (in != null) { in.close(); } if (out != null) { out.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 我们通过DataOutputStream将我们需要的数据按顺序写入到了文件当中，然后使用DataInputStream来读取文件中的基本类型的数据，不过需要注意的是我们读取时的顺序必须要和写入是的顺序是相同的，不然代码就会抛出一个异常。还要注意的是，此时那个文件test并不是一个可读的文件(是我们有点儿看不懂的文件)。比如 @ !�M�J sher is the best boy! 可以看到前面的数据都是不可读的，只有后面的是writeUTF()写入的是可读的，但是如果只是用writeUTF()方法的话也是会出现不可读的字符的，那是因为使用wrteUTF()方法会在前面的两个字节储存长度信息。 上面基本上就是这两个流的基本的用法了。 ObjectInputStream, ObjectOutputStream上面的流是进行基本数据类型的读写，下面要说的下Java当中最为重要的对象类型的读写流。用法与上面的基本数据类型流基本是类似的。不过也有一些需要注意的地方。下面就看一下ObjecOutputStream的官方文档吧。 java.lang.Object java.io.OutputStream java.io.ObjectOutputStream public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants 官方文档中对这个类的说明非常的长而且复杂，所以我们先看看构造器还有他的成员方法吧。 protected ObjectOutputStream() // 为完全重新实现ObjectOutputStream的子类提供一种方法，不必分配刚刚被ObjectOutputStream实现使用的私有数据。 ObjectOutputStream(OutputStream out) // 创建一个写入指定的OutputStream的ObjectOutputStream。 第一个构造方法是protected的，所以我们大可不必看这个玩意。 protected void annotateClass(类&lt;?&gt; cl) // 子类可以实现此方法，以允许类数据存储在流中。 protected void annotateProxyClass(类&lt;?&gt; cl) // 子类可以实现这种方法来存储流中的自定义数据以及动态代理类的描述符。 void close() // 关闭流。 void defaultWriteObject() // 将当前类的非静态和非瞬态字段写入此流。 protected void drain() // 排除ObjectOutputStream中的缓冲数据。 protected boolean enableReplaceObject(boolean enable) // 启用流来替换流中的对象。 void flush() // 刷新流。 ObjectOutputStream.PutField putFields() // 检索用于缓冲要写入流的持久性字段的对象。 protected Object replaceObject(Object obj) // 该方法将允许ObjectOutputStream的可信子类在序列化期间将一个对象替换为另一个对象。 void reset() // 复位将忽略已写入流的任何对象的状态。 void useProtocolVersion(int version) // 指定在编写流时使用的流协议版本。 void write(byte[] buf) // 写入一个字节数组。 void write(byte[] buf, int off, int len) // 写入一个子字节数组。 void write(int val) // 写一个字节。 void writeBoolean(boolean val) // 写一个布尔值。 void writeByte(int val) // 写入一个8位字节。 void writeBytes(String str) // 写一个字符串作为字节序列。 void writeChar(int val) // 写一个16位的字符。 void writeChars(String str) // 写一个字符串作为一系列的字符。 protected void writeClassDescriptor(ObjectStreamClass desc) // 将指定的类描述符写入ObjectOutputStream。 void writeDouble(double val) // 写一个64位的双倍。 void writeFields() // 将缓冲的字段写入流。 void writeFloat(float val) // 写一个32位浮点数。 void writeInt(int val) // 写一个32位int。 void writeLong(long val) // 写一个64位长 void writeObject(Object obj) // 将指定的对象写入ObjectOutputStream。 protected void writeObjectOverride(Object obj) // 子类使用的方法来覆盖默认的writeObject方法。 void writeShort(int val) // 写一个16位短。 protected void writeStreamHeader() // 提供了writeStreamHeader方法，因此子类可以在流中附加或预先添加自己的头。 void writeUnshared(Object obj) // 将“非共享”对象写入ObjectOutputStream。 void writeUTF(String str) // 此字符串的原始数据写入格式为 modified UTF-8 。 可以看到这个类的成员方法是非常多的，但是我们可以发现的是，这个类不仅仅是可以写入对象，也可以写入基本数据类型，甚至原始数组(原始数组其实也是一个对象)。DataStream的功能基本上都是被ObjectStream说涵盖了的。 下面就来看看官方文档对这个类的一些说明。 ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象。 只有支持java.io.Serializable接口的对象才能写入流中。 每个可序列化对象的类被编码，包括类的类名和签名，对象的字段和数组的值以及从初始对象引用的任何其他对象的关闭。 方法writeObject用于将一个对象写入流中。 任何对象，包括字符串和数组，都是用writeObject编写的。 多个对象或原语可以写入流。 必须从对应的ObjectInputstream读取对象，其类型和写入次序相同。 原始数据类型也可以使用DataOutput中的适当方法写入流中。 字符串也可以使用writeUTF方法写入。 对象的默认序列化机制写入对象的类，类签名以及所有非瞬态和非静态字段的值。 引用其他对象（除了在瞬态或静态字段中）也会导致这些对象被写入。 使用引用共享机制对单个对象的多个引用进行编码，以便可以将对象的图形恢复为与原始文件相同的形状。 例如，要写一个ObjectInputStream中的示例可以读取的对象： FileOutputStream fos = new FileOutputStream(&quot;t.tmp&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeInt(12345); oos.writeObject(&quot;Today&quot;); oos.writeObject(new Date()); oos.close(); 在序列化和反序列化过程中需要特殊处理的类必须采用具有这些精确签名的特殊方法： private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException; private void writeObject(java.io.ObjectOutputStream stream) throws IOException private void readObjectNoData() throws ObjectStreamException; writeObject方法负责为其特定的类编写对象的状态，以便相应的readObject方法可以恢复它。 该方法不需要关心属于对象的超类或子类的状态。 通过使用writeObject方法或通过使用DataOutput支持的原始数据类型的方法将各个字段写入ObjectOutputStream来保存状态。 序列化不会写出任何不实现java.io.Serializable接口的对象的字段。 不可序列化的对象的子类可以是可序列化的。 在这种情况下，非可序列化类必须有一个无参数构造函数，以允许其字段被初始化。 在这种情况下，子类有责任保存并恢复不可序列化类的状态。 通常情况下，该类的字段是可访问的（public，package或protected），或者可以使用get和set方法来恢复状态。 可以通过实现抛出NotSerializableException的writeObject和readObject方法来防止对象的序列化。 异常将被ObjectOutputStream捕获并中止序列化过程。 实现Externalizable接口允许对象完全控制对象的序列化表单的内容和格式。 调用Externalizable接口writeExternal和readExternal的方法来保存和恢复对象的状态。 当由类实现时，他们可以使用ObjectOutput和ObjectInput的所有方法来写入和读取自己的状态。 对象处理发生的任何版本控制都是有责任的。 枚举常数与普通可序列化或外部化对象不同的是序列化。 枚举常数的序列化形式仅由其名称组成; 不传输常数的字段值。 要序列化一个枚举常量，ObjectOutputStream会写入常数名称方法返回的字符串。 像其他可序列化或可外部化的对象一样，枚举常量可以作为随后在序列化流中出现的反向引用的目标。 枚举常数序列化的过程无法定制; 在序列化期间，将忽略由枚举类型定义的任何类特定的writeObject和writeReplace方法。 类似地，任何serialPersistentFields或serialVersionUID字段声明也被忽略 - 所有枚举类型都有一个固定的serialVersionUID为0L。 原始数据（不包括可序列化字段和外部化数据）在块数据记录中写入ObjectOutputStream。 块数据记录由报头和数据组成。 块数据头由标记和跟随标题的字节数组成。 连续的原始数据写入被合并成一个块数据记录。 用于块数据记录的阻塞因子将是1024字节。 每个块数据记录将被填充到1024个字节，或者每当块数据模式终止时都被写入。 调用ObjectOutputStream方法writeObject，defaultWriteObject和writeFields最初终止任何现有的块数据记录。 第二点是非常重要的，只有支持java.io.Serializable接口的对象才能写入流中，如果没用实现这个接口，写入的时候会报错。至于什么叫Serializable呢。这个被称为是可序列化的。就是可以被写入到文件当中。要使类实现这个接口，这需要implement Serializable不需要实现任何的函数。也就是说这个接口这是起了一个标记的作用，其母的是告诉编译器这个类可以被序列化写入到文件当中去。不过如果有一些数据我们不想其被写入到文件当中去，我们就要加上transient关键词，表示这个属性不会被写入到文件中去。关于序列化还有一点要说的是，序列化不只是对象的一个简单的复制，和此对象有关的所有的有关的对象都会被写入到文件当中去，如果其中有不可序列化的对象也会报错。假如序列化只是写入链接，当我们反序列化的时候码举例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java Io</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-04]]></title>
    <url>%2F2019%2F09%2F25%2FJava%E4%B8%AD%E7%9A%84IO-04%2F</url>
    <content type="text"><![CDATA[Java中的IO-04回顾之前已经介绍过很多的IO流了。比如四大抽象流InputStream，OutputStream，Reader,Writer。前面的两个是字节流，后面的两个是字符流。所谓的字节流与字符流之间的最大的区别就是，字节流是写给计算机看的，而字符流写写给我们人看的。Java当中所有的IO流基本上都继承于这个四大抽象流，而且基本上都以他们结尾。之前还说过一个特殊的流OutputStreamWriter，InputStreamReader。这两个流却是有点儿特殊，他们的前面是字节流，后面却是字符流。之前我们说他是处理字符相关的流，不过实际上他是将字节流转换成字符流的特殊流。因而我们可以指定编码(字节流转换成为字符流的一种方式)来进行字节到字符的转换。如果我们要处理一些字符文件的话，之前学的FileReader，FileWriter无疑是一个最合适的选择。如果要是处理一些字节文件比如图片或者视频什么的，我们需要使用字节流FileInputStream，FileOutputStream。不过单独使用这些流的话，效率可能是一个问题。所以缓冲区是必须的，Java IO 中给我们提供了缓冲的包装流。BufferedInputStream,BufferedOutputStream,BufferedReader,BufferedWriter。这四个流是对前面的四个基本的抽象流的包装，如果不是什么特殊情况的话，我们可以每次都加上这个缓冲层。 ByteArrayInputStream, ByteArrayOutputStream字节流我们只是介绍了一种，也就是从文件中读取字节。不过并不是所有的情况下我们都要从文件中读取字节的。比如说我们获取一个字节数组，我们想使用流来处理一下这个字节数组，好像我们现在学过的流中没有这样的功能。 于是现在我们引入了处理数组的新的流，ByteArrayInputStream和 ByteArrayOutputStream。 下面就是我们正常的官方文档的学习环节。 java.lang.Object java.io.InputStream java.io.ByteArrayInputStream public class ByteArrayInputStream extends InputStream A ByteArrayInputStream包含一个内部缓冲区，其中包含可以从流中读取的字节。内部计数器跟踪read方法要提供的下一个字节。 关闭ByteArrayInputStream没有任何效果。 在关闭流之后，可以调用此类中的方法，而不生成IOException 。 ByteArrayInputStream(byte[] buf) // 创建一个 ByteArrayInputStream ，使其使用 buf作为其缓冲区数组。 ByteArrayInputStream(byte[] buf, int offset, int length) // 创建 ByteArrayInputStream使用 buf作为其缓冲器阵列。 int available() // 返回可从此输入流读取（或跳过）的剩余字节数。 void close() // 关闭 ByteArrayInputStream没有任何效果。 void mark(int readAheadLimit) // 设置流中当前标记的位置。 boolean markSupported() // 测试 InputStream是否支持标记/复位。 int read() // 从该输入流读取下一个数据字节。 int read(byte[] b, int off, int len) // 将 len字节的数据读入此输入流中的字节数组。 void reset() // 将缓冲区重置为标记位置。 long skip(long n) // 从此输入流跳过 n个字节的输入。 其实上面的这些方法，和这些属性都是可以一眼就看懂的，和其他的流是没什么区别的。 看一下官方文档的第一点，我们可以知道使用ByteArrayInputStream内部有一个缓冲区，那是否可以使用BufferedInputStream来包装呢？这个肯定是可以用的，毕竟这个也是InputStream的子类吖。 第二点是关于这个流的关闭的，官方文档告诉我们，这个流的关闭是不会做任何事情的，也就是说我们可以选择不关闭。但是为了IO流中操作的有机的统一和规范。虽然关闭没有用，我们还是推荐来关闭一下子的。 代码举例public class ByteArrayInputStreamDemo { public static void main(String[] args) { byte[] b = &quot;sher is a wonderful boy!&quot;.getBytes(); ByteArrayInputStream bais = new ByteArrayInputStream(b); StringBuilder sb = new StringBuilder(); int temp = 0; while ((temp = bais.read()) != -1){ sb.append((char) temp); } System.out.println(sb.toString()); } } 其实上面的我的用法不没有是把这个作为一个IO流来使用，所以也没有使用IO流的try catch finally的标准操作。而且这个流也是不会抛出IOException的。 下面随便写一个有关ByteArrayOutputStream的代码举例 public class ByteArrayOutputStreamDemo { public static void main(String[] args) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); while (baos.size() &lt;= 10){ try { baos.write(System.in.read()); } catch (IOException e) { e.printStackTrace(); } } byte[] b = baos.toByteArray(); System.out.println(new String(b)); } } 这里也没有使用标准的IO流操作方式，毕竟这个流是有点儿特殊了。 CharArrayWriter, CharArrayReader和上面的字节数组类似的，字符流中也有相应的流是和字符数组相关的。其实他们之间的道理是一样的，这里就不再赘述了。 public class CharArrayWriterDemo { public static void main(String[] args) { char[] ch = &quot;sher is the best boy!&quot;.toCharArray(); CharArrayWriter c = new CharArrayWriter(); try { c.write(ch); c.flush(); } catch (IOException e) { e.printStackTrace(); } System.out.println(c.toString()); } } public class CharArrayReaderDemo { public static void main(String[] args) { char [] ch = &quot;abcdefg&quot;.toCharArray(); CharArrayReader char1 = new CharArrayReader(ch); StringBuilder sb = new StringBuilder(); int temp = 0; while (true){ try { if (((temp = char1.read()) == -1)) break; } catch (IOException e) { e.printStackTrace(); } sb.append((char)temp); } System.out.println(sb.toString()); } } 总结其实这些流都不是常见的流，基本上我们是用不到的。不过稍微做一下了解也是好的呢、]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-03]]></title>
    <url>%2F2019%2F09%2F24%2FJava%E4%B8%AD%E7%9A%84IO-03%2F</url>
    <content type="text"><![CDATA[Java中的IO-03缓冲流BufferedReader和BufferedWriter在之前我们讲OutputStreamWriter中，官网文档给了我们三个建议。其中第二条是我们有点儿看不懂的。现在我们再来看一遍试试看。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。 例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 为了提高更高的效率，我们要用一个包装类BufferedWriter，减少频繁调用转换器。这个到底是什么意思呢？众所周知，buffer是缓冲区的意思，那么这个BufferedWriter的作用大概率就是给OutputStreamWriter添加了一个缓冲的地方。 我们来看一下原来的OutputStreamWriter的代码。 public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, &quot;GBK&quot;); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个是如何写入的呢？里面好像只有那一行的代码。。。osw.write(content)，这个我们怎么看写入的方式呢？我们可以再来看一看OutputStreamReader的代码。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 这个读取的过程就看的非常的清晰了，每次我们都读取了一个字符，然后判断是否为空，然后输入那一个字符。也就是说读取和输出之间没有缓冲区。其实我们可以每次读取1024（比如）个字符，然后一次性写入。然后再去读取1024个字符。这个buffer数组其实就是所谓的缓冲区。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int cot; byte[] buffer = new byte[1024]; // 缓冲区 while ((cot = is.read(buffer)) != -1){ System.out.println(new String(buffer, 0, cot)); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面只是我们简单的实现了一个缓冲的原理。Java IO中专门给我提供了这样的包装类（所谓的包装类就是设计模式中的装饰模式，简单的说就是给原有的类添加一些新的功能）。就是BufferedXXX，后面的XXX就是指的就是我们之前学过的Reader, Writer和InputStream和OutputStream这些流。 下面来看一下官方的文档是怎么说的。 public class BufferedReader extends Reader 从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取。 可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途。 通常，由读取器做出的每个读取请求将引起对底层字符或字节流的相应读取请求。 因此，建议将BufferedReader包装在其read（）操作可能昂贵的读取器上，例如FileReaders和InputStreamReaders。 例如， BufferedReader in = new BufferedReader(new FileReader(&quot;foo.in&quot;)); 将缓冲指定文件的输入。没有缓冲，每次调用read（）或readLine（）可能会导致从文件中读取字节，转换成字符，然后返回，这可能非常低效。 使用DataInputStreams进行文本输入的程序可以通过用适当的BufferedReader替换每个DataInputStream进行本地化。 看一下他的构造函数。 BufferedReader(Reader in) // 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) // 创建使用指定大小的输入缓冲区的缓冲字符输入流。 非常的简单，他是一个包装流，就是为了来包装Reader这个类的子类的，其中我们可以使用第二个参数来指定缓冲区的大小，不过也看了上面的说明其实一般情况是我们是不用指定的。 下面该看的就是这个类的方法了。其实这个流对象的各种方法我们基本都已经熟悉了。不过这个BufferedReader有一个我最喜欢的方法，那就是readLine()方法。 public String readLine() throws IOException 读一行文字。 一行被视为由换行符（&#39;\ n&#39;），回车符（&#39;\ r&#39;）中的任何一个或随后的换行符终止。 结果 包含行的内容的字符串，不包括任何行终止字符，如果已达到流的末尾，则为null 异常 IOException - 如果发生I / O错误 另请参见： Files.readAllLines(java.nio.file.Path, java.nio.charset.Charset) 一次就可以读一行了，这个方法不要太方便哦~~ 下面随便写一个代码来展示一下这个类。 public class BufferedReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new FileReader(file)); String line; while ((line = bufferedReader.readLine()) != null){ System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { if (bufferedReader != null){ try { bufferedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 可见看到，这里我没有将FileReader这个类放在外面，也没有在finally中将其关闭，那是因为在我们关闭BufferedReader的时候其实也就是关闭了FileReader，之前说了BufferedReader是他的包装流，其实包装的就是FileWriter，底层也是FileWriter，所谓的BufferedReader其实也不是流，只是一个壳子而已。这就是为啥叫他包装流或者说装饰流。 下面就是BufferedWriter了，其实具体的用法都是相似的。 public class BufferedWriterDemo { public static void main(String[] args) { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(&quot;./Exercise/src/buf.txt&quot;)); String content = &quot;hello World&quot;; writer.write(content); writer.newLine(); writer.write(content); writer.flush(); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 可以看到BufferedWriter多了一个方法。newLine()。在linux和windows当中换行的符号是不一样的。windows中的换行是\r\n，而在linux中的换行的符号是\n。其中\r的意思是回到行首。所以说使用newLine()这个方法来换行个不错的选择。 BufferedInputStream和BufferedOutputStream上面讲过了BufferedReader, BufferedWriter了，下面的这两个也是包装流，其实就可以一带而过了。 public class BufferedInputStreamDemo { public static void main(String[] args) { BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try { bufferedInputStream = new BufferedInputStream( new FileInputStream(&quot;./Exercise/src/test.jpg&quot;)); byte[] b = bufferedInputStream.readAllBytes(); bufferedOutputStream = new BufferedOutputStream( new FileOutputStream(&quot;./Exercise/src/testCopy.jpg&quot;)); bufferedOutputStream.write(b); bufferedOutputStream.flush(); } catch (Exception e) { e.printStackTrace(); } finally { try { if (bufferedInputStream != null){ bufferedInputStream.close(); } if (bufferedOutputStream != null){ bufferedOutputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 其实从上面可以看出，用法和之前是完全相同的，使用Buffered之后，只是增加了一个所谓的缓冲区，是流的输入和输出变得更加快呢，而且BufferedReader还提供了readLine()这种神级的方法，所以说，Buffered这种东西，不是啥特殊情况的话，最后在使用流的时候都加上吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>JAVA IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的IO-02]]></title>
    <url>%2F2019%2F09%2F23%2FJava%E4%B8%AD%E7%9A%84IO-02%2F</url>
    <content type="text"><![CDATA[Java中的IO-02FileInputStream与FileOutputStream对字节文件的操作根据官方文档的说法，FileInputStream和FileOutputStream这两个流主要是对图像，视频等原始字节流进行操作的，但是我们举的例子却是一个字符串操作，不能体现这两个流的专门用途。下面可以用这两个流写一个图片的拷贝操作。 图片文件的拷贝public class ImgCopy { public static void main(String[] args) { File file = new File(&quot;D:/unziptest.jpg&quot;); FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(file); byte[] b = fis.readAllBytes(); // 读取原始字节 fos = new FileOutputStream(&quot;./Exercise/src/test.jpg&quot;); fos.write(b); // 写入到文件中 } catch (Exception e) { e.printStackTrace(); } finally { // 关闭流 try { if (fis != null){ fis.close(); } if (fos != null){ fos.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 上面是一个简单的图片的拷贝的操作。其中第八行的字节来源是从本地读取，其实也可以从网络上读取，然后写入到本地，这样就是一个文件下载的操作。其实这个写入字节和写入字符串的操作比起来，是一模一样的，因为这个流就是写入原始字节，就算是字符串我们不也是使用content.getBytes()的方式得到字节的。（注意这里的编码问题，默认就是工程的编码，我这里就是utf-8 的编码） 字符IO流我们之前看FileOutputStream的官方文档的时候，发现了这样的一句话。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 那么这个FileWriter又是个什么玩意呢？ 从官方文档中看他的继承结构。 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter 我们发现这个流和OutputStream竟然没有任何关系，他竟然是继承于一个叫java.io.writer的类。 public abstract class Writer extends Object implements Appendable, Closeable, Flushable 用于写入字符流的抽象类。 子类必须实现的唯一方法是write（char []，int，int），flush（）和close（）。 然而，大多数子类将覆盖这里定义的一些方法，以便提供更高的效率，附加的功能或两者。 看来这个流是专门为了更加方便的写入字符而准备了。可以看到他的write方法中的参数是char[]，而不是byte[]，这样我们就可以不把字符转为字节进行写入，这样可以更加方便地写入也可以更加方便地读取。（有些字符可能会占用两个字节，如果我们是一个字节一个字节进行读取的话，就可能会出现乱码的情况，但是一个字符一个字符读取就不会出现这种问题。所以说进行字符流的操作的时候尽量使用这个流的子类） 写入写出基本上都是有对应的类的，这里既然有Writer，那当然就会Reader，不过他们的用法基本都是相同的。 OutputStreamWriter与InputStreamReaderpublic class OutputStreamWriter extends Writer OutputStreamWriter是字符的桥梁流以字节流：向其写入的字符编码成使用指定的字节charset 。 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集。 每次调用write（）方法都会使编码转换器在给定字符上被调用。所得到的字节在写入底层输出流之前累积在缓冲区中。可以指定此缓冲区的大小，但是默认情况下它大部分用于大多数目的。请注意，传递给write（）方法的字符不会缓冲。 为了最大的效率，请考虑在BufferedWriter中包装一个OutputStreamWriter，以避免频繁的转换器调用。例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); 上面是官方文档对这个类的一些说明。第一点倒是之前讲过了一点，对于字符流，一般我们要指定一个字符集，如果不指定的话就会是我们项目默认的字符集，不过如果我们的代码文件转移到别的环境之后，可能会出现一些字符集不一样的bug。至于第三点，我们发现了一个新的流，这个是之后要介绍的了。 OutputStreamWriter(OutputStream out) // 创建一个使用默认字符编码的OutputStreamWriter。 OutputStreamWriter(OutputStream out, Charset cs) // 创建一个使用给定字符集的OutputStreamWriter。 OutputStreamWriter(OutputStream out, CharsetEncoder enc) // 创建一个使用给定字符集编码器的OutputStreamWriter。 OutputStreamWriter(OutputStream out, String charsetName) //创建一个使用命名字符集的OutputStreamWriter。 观察这个类的三个狗渣函数，第一个构造函数没有指定字符集使用的就是默认的字符集。而后面的是哪个构造函数使用了三种不同的方式指定了这个字符流使用的字符集。一般情况下，我们使用第四种就行了，使用字符串来指定字符集，比如“UTF-8”和“GBK”这两种常见的字符集。不过我们使用如下的方式程序将会运行的更快StandardCharsets.UTF-8 然后我们再看看这个函数的第一个参数，是一个OutputStream，我们知道OutputStream是一个抽象类，是不能被实例化的，所以我们可以使用他的子类，比如FileOutputStream。 现在再看看这个类的主要的方法。 void close() // 关闭流，先刷新。 void flush() // 刷新流。 String getEncoding() // 返回此流使用的字符编码的名称。 void write(char[] cbuf, int off, int len) // 写入字符数组的一部分。 void write(int c) // 写一个字符 void write(String str, int off, int len) // 写一个字符串的一部分。 可见这个类不仅可以写入字符数组byte[]，还可以写入String，这是真的方便啊。 代码测试public class OutputStreamWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); OutputStreamWriter osw = null; FileOutputStream fis = null; try { fis = new FileOutputStream(file); osw = new OutputStreamWriter(fis, StandardCharsets.UTF_8); String content = &quot;sher is a wonderful boy!&quot;; osw.write(content); } catch (Exception e) { e.printStackTrace(); } finally { try { if (osw != null) { osw.close(); } if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 代码的几点说明： 在new出OutputStream的时候，一般我们要指定一个字符集，可以使用StandardCharsets.UTF_8的这种写法。也可以直接写“UTF-8&quot;。 写入流的时候可以直接使用String，也可以直接使用char[]，不必将其转换成为字节。 关闭流的时候，我们需要先关闭外部的OutputStream然后再关闭内部的FileOutputStream，不然会抛出异常。 至于InputStreamReader的使用，和OutPutstreamWriter的使用是如出一辙的。 public class InputStreamReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); InputStreamReader isr = null; InputStream is = null; try { is = new FileInputStream(file); isr = new InputStreamReader(is, StandardCharsets.UTF_8); int res; while ((res = is.read()) != -1){ System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (isr != null){ isr.close(); } if (is != null){ is.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 不过需要注意的是，使用read()方法可以读取一个字符，当读取到文件的末尾的时候将返回-1。 OutputStreamWriter已经基本可以满足我们写入字符串的需要了，不过这和官方文档告诉我们的FileWrtter还是不一样，FileWriter‘是其的子类。 FileWriter与FileReader的使用public class FileWriter extends OutputStreamWriter java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter FileWriter既然是上面说的那个OutputStreamWriter的子类，那么它到底有什么有别于他的父类的特殊功能呢？ 方便课写字符文件。该类的构造函数假定默认字符编码和默认字节缓冲区大小是可以接受的。要自己指定这些值，请在FileOutputStream上构造一个OutputStreamWriter。 文件是否可用或可能被创建取决于底层平台。 特别是某些平台允许一次只能打开一个文件来写入一个FileWriter （或其他文件写入对象）。 在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileWriter是用于写入字符流。 要编写原始字节流，请考虑使用FileOutputStream 。 可以看一下第一点，我们可以知道使用这个类的时候我们是无法向OutputStreamWriter那样指定一个字符集的，这个类默认使用系统或者是项目的默认的字符集。第二点倒是不难理解，不过也没有什么重点可言。我们可以看到第三点，这个和我们在FileOutputStream中看到的是一样的。 不过问题在于，使用FileWriter和OutputstreamWriter之间到底有什么区别呢？ FileWriter(File file) // 给一个File对象构造一个FileWriter对象。 FileWriter(File file, boolean append) // 给一个File对象构造一个FileWriter对象。 FileWriter(FileDescriptor fd) // 构造与文件描述符关联的FileWriter对象。 FileWriter(String fileName) // 构造一个给定文件名的FileWriter对象。 FileWriter(String fileName, boolean append) // 构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。 这里的构造函数没有我们之间看到的OutputStream了，也就是说我们使用FileWriter的时候不必像使用OutputstreamWriter那样先创建一个FIleOutputStream，这个倒是蛮方便的。我们可以给定File类或者文件名进行字符文件的读取。这个类的话是没有额外的方法的，也就是说这个类的使用方法和OutputStreamWriter基本是一样的。 public class FileWriterDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/writer.txt&quot;); FileWriter writer = null; try { writer = new FileWriter(file); String content = &quot;why are u so beautiful my girl?&quot;; writer.write(content); } catch (IOException e) { e.printStackTrace(); } finally { try { if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } } } } FileReader的使用方式也是类似的。 public class FileReaderDemo { public static void main(String[] args) { File file = new File(&quot;./Exercise/src/sher&quot;); FileReader reader = null; try { reader = new FileReader(file); int res; while ((res = reader.read()) != -1) { System.out.print((char)res); } } catch (Exception e) { e.printStackTrace(); } finally { try { if (reader != null){ reader.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 总结上面主要介绍的就是Writer和Reader，其实IO中的四大抽象类就是InputStream，OutputStream，Writer，Reader这四种。前两种主要负责的就是原始字节流的操作，而后两种主要就是字符流的操作。不过我们也是可以通过前面的两种类来操作字符流的，不过这就是有点儿麻烦而且无法处理多字符的问题。后面要学习的是更加复杂一点的IO流的知识。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的IO-01]]></title>
    <url>%2F2019%2F09%2F22%2FJava%E4%B8%AD%E7%9A%84IO-01%2F</url>
    <content type="text"><![CDATA[java中的IO-01基本介绍所谓的IO就是Input and Output的意思。在C++中我们学到的IO主要就是两种, Istream and Ostream，cin和cout就是这两个流的对象。C++是这样子的，那么Java又如何呢？我们学习一门语言总是要从hello world开始学起，也就是向控制台中输出hello world这个字符串。在C++中我们使用的是std::cout&lt;&lt;“Hello World”&lt;&lt;std::endl;，在Java中我们使用的是System.out.println(&quot;Hello world&quot;);。既然是输出，那么肯定是和IO流相关的。cout是std::ostream的一个对象，功能是向控制台输出。那么Java中的这个函数又如何理解呢？System是Java中的一个类。 public final class System extends Object 官方文档中这样说道 System类包含几个有用的类字段和方法。它不能被实例化。 System类提供的System包括标准输入，标准输出和错误输出流; 访问外部定义的属性和环境变量; 一种加载文件和库的方法; 以及用于快速复制阵列的一部分的实用方法。 我们继续查阅官方文档，发现System类中有几个静态的成员！ static printStream err; // 标准错误输出流 static printStream in; // 标准输入流 static printStream out; // 标准输出流 这样一来Java中的这个输出函数就很好理解了。 System.out是一个对象，相当于C++中的cout。println是System.out的一个static method用于向控制台输出信息，并在最后输出换行。如果不需要换行的话我们可以使用print方法。 OutputStream与InputStream不过这个System.out为什么能输出字符串呢？那肯定是因为他是一个类似于std::ostream的玩意，他的类型是printStream。我们观察一下它的继承结构。 java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.PrintStream 最顶层的Object这个是毫无疑问的，Java当中的所有的类都是继承于java.lang.Object的。所以说最重要的是第二个 java.io.OutputStream, 正所谓，遇事不决先参看官方文档。 public abstract class OutputStream extends Object implements Closeable, Flushable 这个抽象类是表示字节输出流的所有类的超类。输出流接收输出字节并将其发送到某个接收器。 需要定义OutputStream子类的应用OutputStream必须至少提供一个写入一个字节输出的方法。 void close(); // 关闭此输出流并释放与此流相关联的任何系统资源。 void flush(); // 刷新此输出流并强制任何缓冲的输出字节被写出。 void write(byte[] b); // 将 b.length字节从指定的字节数组写入此输出流。 void wirte(byte[] b, int off, int len); // 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 abstract void write(int b); // 将指定的字节写入此输出流。 这个类是一个抽象的类是不能够被实例化的，也就是说他是所有的输出流的一个模子。我们要针对特殊的情形使用这个类的子类。 InputStream和这个也是同样的道理。 FileOutputStream 与 FIleInputStream前面说了那么多的废话，现在假如我们要输出一些东西到文件中储存能不能做到呢？答案是明显的，我们需要OutputStream的一个合适的子类，这里我们找到了FileOutputStream。我们继续查阅官方文档。 public class FileOutputStream extends OutputStream 文件输出流是用于将数据写入到输出流File或一个FileDescriptor 。文件是否可用或可能被创建取决于底层平台。特别是某些平台允许一次只能打开一个文件来写入一个FileOutputStream （或其他文件写入对象）。在这种情况下，如果所涉及的文件已经打开，则此类中的构造函数将失败。 FileOutputStream用于写入诸如图像数据的原始字节流。 对于写入字符流，请考虑使用FileWriter 。 从文档中我们可以读出，这个类主要是将原始字节流写入到文件当中去的。不过既然这个类可以被实例化，我们就要看看这个类的构造函数是怎么样的。 FileOutputStream(File file) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(File file, boolean append) // 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(FileDescriptor fdObj) // 创建文件输出流以写入指定的文件描述符，表示与文件系统中实际文件的现有连接。 FileOutputStream(String name) // 创建文件输出流以指定的名称写入文件。 FileOutputStream(String name, boolean append) // 创建文件输出流以指定的名称写入文件。 这里我们看到了一个File类，可以肯定，这个类代表的就是我们要写入的文件，不过下面的两个构造函数使用的却是String name。这两个是不一样的。 既然是写入，我们还要知道这个类的写入方法是如何的。 void write(byte[] b) // 将 b.length个字节从指定的字节数组写入此文件输出流。 void write(byte[] b, int off, int len) // 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。 void write(int b) // 将指定的字节写入此文件输出流。 代码测试public class FileOutputStreamDemo { public static void main(String[] args) { try { FileOutputStream fileOutputStream = new FileOutputStream(&quot;sher&quot;); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这里我们没有使用FIle类来代表文件，使用的是一个String–“sher”，然后使用write方法将字节写入到文件中。最后使用close方法关闭这个流。这里问题来了，我们只是提供了文件的名字，那么文件放在哪儿呢？？莫非是和这个类的文件同级？答案让我很懵逼，这个文件出现在我的项目文件夹的同级。其实这个位置是很沙雕的，因为我有多个项目，谁都不知道这个文件到底是属于哪一个项目的，如果是和src文件夹同级我倒是可以理解。那么我们需要修改文件的位置该如何呢？我们可以修改给定的这个文件的绝对路径，比如说我们是使用如下的代码 FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:/sher&quot;); 那么这个文件就会创建在D盘下。其实我们没有给他一个绝对路径的时候，他使用的就是相对路径，这里的相对路径不是我们想象中的那个相对与代码文件的，而是相对于整个项目的。比如我们也可以这样写。 FileOutputStream fileOutputStream = new FileOutputStream(&quot;./Exercise/src/sher&quot;); 点的意思的本目录，点点指的是上一级目录，这里在我看来点是多余的，但是去除点之后就会报错。可能是没有点他就认为这个是一个绝对路径吧。通过上面的方法我们就将文件创建到了src目录下。不过之前我们提到了一个File类，那个类又如何使用呢？ 我们可以尝试着使用File类。不过在使用File类之前我们还需要去了解一下File类。 public class File extends Object implements Serializable, Comparable&lt;File&gt; 文件和目录路径名的抽象表示，这是官方文档对File类的说明。 File类主要有如下的构战函数 File(File parent, String child) // 从父抽象路径名和子路径名字符串创建新的 File实例。 File(String pathname) // 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File(String parent, String child) // 从父路径名字符串和子路径名字符串创建新的 File实例。 我们修改了一下代码 public class FileOutputStreamDemo { public static void main(String[] args) { try { File file = new File(&quot;./Exercise/src/sher&quot;); System.out.println(file.getPath()); FileOutputStream fileOutputStream = new FileOutputStream(file); String content = &quot;sher is a pretty boy!&quot;; fileOutputStream.write(content.getBytes()); fileOutputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这个修改倒是不痛不痒的，只是修改了一点点而已。其实File类还有其他非常多的方法，这里我们学习的是IO，只要简单的会使用就好啦。 注意点： 你可能注意到了FileOutputStream构造函数还有第二个参数(boolean append)，默认是false（其实这句话是错误的，Java中的函数没有默认值，只是如果我们没有第二个参数的话，调用的单个参数函数就是相当于第二个参数是false），如果我们将其设置为true的话，写入的文件的时候就不会将原有文件清空，而且接着后面继续写入。（如果文件不存在就会创建该文件） write(byte[] b, int off, int len)的使用。 fileOutputStream.write(content.getBytes(), 3, 4);写入文件的就是“r is”从第三个字符开始，写入四个字符。注意一个中文是两个字符。 write(int b)的使用 这个就更简单了，这个就是写入一个字节。比如wirte(97)就是写入一个字符a. flush()方法的使用 有时候写入的时候可能并不会直接写入，我们需要使用flush()方法刷新缓冲区之后才能写入。所有说可以在写入操作完成之后加上这个flush()方法。 上面还只是文件的简单的写入，下面还要学习一下简单的文件的读取操作。 public class FileInputStreamDemo { public static void main(String[] args) { try { FileInputStream fileInputStream = new FileInputStream(&quot;./Exercise/src/sher&quot;); byte[] b = new byte[1024]; int res = fileInputStream.read(b); System.out.println(res); System.out.println(new String(b)); } catch (Exception e) { e.printStackTrace(); } } } read函数有一个返回值，这个值的意思的读取的字符数。 其实这个FileInputStream和FileOutputStream是非常类似的。只有个别的方法存在差别。 比如说FileInputStream对象没有flush方法，不过他有一个skip方法。 long skip(long n) // 跳过并从输入流中丢弃 n字节的数据。 如果我们使用skip(1)的话，第一个字节将会被我们跳过，他的返回值是实际跳过的字节数。 总结到这里我们就基本学完了Java io的几个最基本的类，这些类也是以后学习更加复杂的IO类的基石。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈最长回文子串——马拉车算法]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%86%8D%E8%B0%88%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[再谈最长回文子串——马拉车算法 之前说过一个算法，也是和字符串有关的——字符串的匹配算法。我们介绍了暴力匹配的BF算法，还有比较难以理解的KMP算法，最后还介绍了一种简单搞笑的Sunday算法。这里我们谈论的也是字符串问题，也就是前面所讲的最长回文子串问题，本来说是不再介绍这种适用性不强的算法的，但是这个马拉车算法和KMP算法是类似的，也是一种奇葩的算法，这里就稍微了解一下吧。 基本介绍之前解决这个问题我们使用的是动态规划算法，时间复杂度是O(n2), 空间复杂度也是O(n2)。毫无疑问这个算法还是有一点儿低效的。之前字符串的暴力匹配的算法时间复杂度是O(nm)，使用KMP算法可以优化到O(n+m)，直接是优化了一整个等级。KMP算法思路是利用已经匹配失败之后的信息来帮助下一次匹配。马拉车算法也是如此，利用回文串匹配失败的信息来加速回文串的判断。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈动态规划]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%86%8D%E8%B0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[再谈动态规划 动态规划算法是很常见的，但是上次讲的那啥动态规划讲的几个例子都不是非常的经典，不过他们依旧都是动态规划。可以很清楚的看到他们都是利用了一个类似递归的表达式（状态转换式），从一个子问题的解到另一个子问题的解。如何能一眼看出这个使用的是动态规划算法，如何一眼看出状态转换式，这个可以说是非常困难的，需要对动态规划算法非常的熟悉才行。现在就来举几个之前写好了的例子来看看动态规划算法吧。 动态规划题目最大路径和这道题口头叙述起来比较困难，直接图形化描述吧。 1 3 2 2 4 7 上面有一个三角形形状的数阵。我们从第一层开始走到最后一层，每次到下一层只能选择向左或者向右，请问如何走才能使得最终走的路径上的数字之后是最大的。思路分析这个也是动态规划算法吗？这个当然是。先想想这个问题的子问题到底是什么？我们要知道走到第三层路径的最大的和，假如我们已经知道第二层的最大路径的和呢？ 这有啥用，我们也不知道其他的位置怎么样，比如上面的那个第二层的最大路径和是4，但是要找到三层的最大路径要走旁边的那个2，所以说我们知道最大路径和是没用的。 但是我们可以考虑到每一层的每一个点的最大路径的值，最终的结果也就是最后一层的值的最大值。 4 3 2 3 7这是我们已经知道了第二层的每个点的最大路径值，那么第三层和第二层之间有什么联系呢？ 比如第一个2，他只能和4加，那就是6,。 3可以选择和4或3加，去最大值就是7。 7只可以和3加，那就是10 6 7 10最后我们找到最后一层的最大值，也就是10。这就是最大路径和。 那么状态转移式该如何写呢？ f(i, j) = max(f(i-1, j-1), f(i-1, j)) + f(i, j)； 当然这里的i,j都是有条件的。i的含义是第几层，j的含义的第几个。这样我们就可以使用二维数组来表示这个了 1 3 2 2 4 7但是这样是否最优呢？我们可以轻易的发现，每次我们只是使用了一层的数据。比如找第三层的我们只需要第二层，找第四层我们只需要第三层，那么我们可不可以只使用一个一维数组来表示呢？ 我们现在有个思路就是从最后一层开始算，为什么呢？因为到点是固定的。第一层只有一个值，最终得到的最大路径肯定是一维数组的第一个数，而且也不用考虑左右的问题了。 2 3 7 4 3 1 这是一个二维数组 找一个一维数组将最后一排赋给它 2 3 7 和第二排比较 —————— 2 3 7 3 2 -&gt; 6 9 7 只是变了第一个数和第二个数 和第一层比较 ---- 6 9 7 1 -&gt; 10 9 7 这是变了第一个数，而这个第一个数就是最大路径这个想法确实是蛮巧妙的。我感觉牛逼！！ 这是状态转移方程就改变了 maxNum(j) = max( maxNum(j), maxNum(j+1) ) + f(i)(j) 这里的maxNum就是之前的那个一维数组。到最后这个数组的第一个数肯定就是最大路径和。 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; #define MAX 10 int n = 0; int maxSum[MAX] = {0}; int num[MAX][MAX] = {0}; int main(){ cout&lt;&lt;&quot;Please input n:&quot;; cin &gt;&gt; n; for (int i=0; i&lt;n ;i++){ for (int j=0; j&lt;=i; j++){ cin &gt;&gt; num[i][j]; } } // 把最后一排赋给那个一维数组 for (int i=0; i&lt;n; i++){ maxSum[i] = num[n-1][i]; } for (int i = n-2; i&gt;=0; --i){ for (int j=0; j &lt;=i; ++j){ maxSum[j] = max(maxSum[j], maxSum[j+1]) + num[i][j]; } } cout&lt;&lt;maxSum[0]; return 0; } 代码说明： 其实思路分析那一块，我做的说明已经足够多了，这里就稍微说一点吧。其实也就只有for循环那一块了吧。 第一个for循环指的是从倒数第二行开始，一直比到第一行(上面我们也是这么说的，倒着来比较) 第二个for循环是计算一位数组里的值，下面也用到了我们说的状态转移方程。 线性模型 过桥 /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ 思路分析这个题目其实蛮难的，说实话不容易想到。不过要说这个是动态规划的话，我们就要找子问题。第n个人过河，和第n-1个人过河到底有没有联系？好像并没有什么联系,每个人过桥的 时间都是乱的。但是假如我们把每个人过桥的时间给从大到小排个序呢？ 这时候加了一个时间最大的人，该如何选择过河方案？ 首先我们得让那n-1个人过河，然后派时间最少的人去河对面接那个后来的人。但是这样子的时间是不是最短的呢？肯定是的，就算你让后来的那个人代替倒数第二个人也是时间最短，因为他们始终只是过河过了一次，他们时间慢的人是不可以回头去接对面的人过来的。所以我们就得到了状态转移方程 f(i) = f(i-1) + 2*time[0] + time[i] 但是还有一个问题，这也就是这个问题难的地方。我难道不可以让n-2个人先过河，然后再让2个人过河。 这样的时间又如何呢？易得他们的状态转移方程 f(i) = f(i-2) + time[0] + time[i] + 2*time[1] 这个状态转移方程也是要说明一点的。首先我们要让最快的那个人把灯送回去，然后让最后两个人过河，再让第二快的去接最快的那个人。 我们得到了两个状态转移方程，只是我们只要取得他们之间的最小值就行了。所以说最终的状态转移方程是 f(i) = min( f(i-1) + 2*time[0] + time[i], f(i-2) + time[0] + time[i] + 2*time[1]) 代码实现#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std; /* 动态规划算法的线性模型 * 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄， * 每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来， * i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 */ int size_time[10]{0}; int solution(vector&lt;int&gt;, int); int solution(vector&lt;int&gt; person_time){ return solution(person_time, person_time.size()-1); } // 备忘录类型的自上而下的动态规划，使用递归来实现 int solution(vector&lt;int&gt; person_time, int size){ // 动态规划 if (size_time[size] != 0){ return size_time[size]; } if (size == 0){ size_time[0] = person_time[0]; return size_time[0]; }else if (size == 1){ size_time[1] = max(person_time[0],person_time[1]); return size_time[1]; }else{ // 递归的一个子问题，前几个怎么过，再加一个人怎么过？ 双数是怎么过？单数是怎么过？ size_time[size] = min(solution(person_time, size-1)+person_time[0]+person_time[size], solution(person_time, size-2) + person_time[0] + person_time[size] + 2*person_time[1]); return size_time[size]; } } 前面的那个动态规划的文章也说过了，我们完全可以将这里的递归转为递推。 int solution2(vector&lt;int&gt; person_time){ int size = person_time.size()-1; size_time[0] = person_time[0]; if (size == 0){ return size_time[0]; } size_time[1] = max(person_time[0], person_time[1]); if (size == 1){ return size_time[1]; } // 其实完全可以不使用数组，只使用三个变量就可以完事了，不过这个已经不是非常的重要了，问题不大 // 自下而上的动态规划，使用递归的方式实现，比上面的算法更加的高效 for (int i=2; i&lt;=size; ++i){ size_time[i] = min(size_time[i-1]+person_time[0]+person_time[i], size_time[i-2]+person_time[0]+person_time[i]+2*person_time[1]); } return size_time[size]; } int main(int argc, char const *argv[]) { vector&lt;int&gt; person_time = {5,1,2 ,10}; sort(person_time.begin(), person_time.end()); // 一定要排序！ cout&lt;&lt;solution2(person_time)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 区间模型 回文串/** * 动态规划算法的区间模型 * 区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解， * 然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 */ 思路分析 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 分析： 典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时， 在X两边各添加一个字符’a’后，aXa仍然是一个回文串， 我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数， 那么对于A[i] == A[j]的情况，很明显有 d[i][j]= d[i+1][j-1] （这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串， 所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策： 在A[j]后面添加一个字符A[i]； 在A[i]前面添加一个字符A[j]； 根据两种决策列出状态转移方程为：d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1)空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。 代码实现#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using std::string; using std::cout; using std::endl; using std::min; int memo[10][10]{0}; int func(string, int, int); int func(string str){ return func(str, 0, str.length()-1); } // 开始区间类型的动态规划 下面使用的时候备忘录类型的 int func(string str, int start, int end){ if (memo[start][end] != 0){ return memo[start][end]; } if (start &gt;= end){ return 0; } if (str[start] == str[end]){ return func(str, start+1, end-1); }else { memo[start][end] = min(func(str, start+1, end), func(str, start, end-1))+1; return memo[start][end]; } } int main(int argc, char const *argv[]) { string str = &quot;srsher&quot;; cout&lt;&lt;func(str)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 0/1背包问题0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品， 使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。思路分析这是我第三次看到这个问题。我们还是先开始来找子问题。比如有四个物品，我们将其按价格排个序。现在加入我们只是发第一个物品。得到金额。然后我们放两个物品，得到金额。问题就在放n个物品得到的金额和n-1个物品到底有没有关联呢？ 可以第n个物品太重了，空间根本放不下，放n个物品的金额就是等于n-1个物品。 还有可能第n个物品可以放下去，还有剩余的空间，再用剩余的空间放那n-1个物品。 这两种方案并不能确定谁大谁小，所以说状态转移方程中，要比较他们的大小关系。 f(n, weight) = min{f(n-1, weight), v[n]+f(n-1 ,weight-w[n]))} 这里的weight其实指的是背包的容量还有多少。v数组指的是某一样物品的价格，w指的是某一样物品的重量 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using std::cout; using std::endl; using std::vector; using std::max; int memo[10][10]{0}; int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int i, int size){ if (i == 0){ if (weight[0] &gt; size){ return 0; }else { return value[0]; } } if (memo[i][size] != 0){ return memo[i][size]; } if (weight[i] &gt; size){ return func(weight, value, i-1, size); } // 放入第i件物品，再使用剩下的空间放i-1件物品， 这样做到底有没有不放入第i件，只是使用前面的i件好？ // 但是有个问题是，这个我们可能不知道到底把什么放入了背包？？？这个问题很大我感觉。。。 // 不过，似乎用一个数组来表示是否被放入的状态可能可以解决 memo[i][size] = max(func(weight, value, i-1, size), func(weight, value, i-1, size-weight[i])+value[i]); return memo[i][size]; } int func(vector&lt;int&gt; weight, vector&lt;int&gt; value, int size){ return func(weight, value, weight.size()-1, size); } int main(int argc, char const *argv[]) { vector&lt;int&gt; weight = {1,3,5,7,9}; vector&lt;int&gt; value = {1,3,5,7,10}; cout &lt;&lt; func(weight, value, 100) &lt;&lt;endl; system(&quot;pause&quot;); return 0; } 总结上面的几道题目就是动态规划问题的经典问题。从这里我们基本就可以看出动态规划的问题到底该怎么解决。第一寻找子问题到底是什么？然后寻找状态转移方程，注意这个状态转移方程的多样性。其实之前的那个动态规划基本介绍中讲的蛮详细的，不过也蛮啰嗦的。不管了，动态规划就此了结吧，拜拜了您嘞！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串问题]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最长回文子串问题 突然发现已经好久没有写博客了，虽然说最近一直都在补京阿尼的番还有一些猛男番确实是原因之一啦。不过最近确实是在看安卓这方面的东西，之前尝试着写了一点，但是我这个安卓也是小白，啥都不懂，只是在学一点儿基础，这好像也没啥好写的东西吖。于是就上leetcode看看，没想到前面的第五题我竟然都没写，不过通过率是低的真实，不用说，这肯定是一道比较难的题目了，下面就来看看这个题目吧。 题目的基本介绍给定一个字符串s，找到 s 中最长的回文子串。你可以假设s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 这个题目看起来似乎是很简单的，不过说实话难的很。反正我是不会做的。而且这个题目的解法是真的特别的多，有很多的神仙解法，把这些的只适用于这道题目的神仙解法都研究透了，似乎这也没有什么意义，所以这里我要介绍的也就是这道题目的最简单的也是最复杂的解法——使用动态规划来解决。 思路分析动态规划算法之前就已经说过了，不过当时似乎没有写什么例子，也没做做过多的说明。不过，动态规划的基本思路我们还是明白的。找到子问题不同状态之间的关联，也就是那个递推的公式。比如说背包问题，放三样东西和放两样东西之间的关联是如何的。找到了这样的公式，问题也就可以轻松的解决了。 这道题目其实也蛮类似的。我们假定i和j分别指向字符串的头和尾，我们要知道i-j这一块是回文串，那么我们就可以得到i+1-j-1这一块肯定也是字符串，而且i处的字符要等于j处的字符。这时我们就可以得到一个关系表达式： 这个递推的表达式，说实话是蛮简单的了，不过不理解动态规划的算法确实很难想出来，反正我是没有想出来的。不过看懂还是可以看懂的(到头来，做了那么多的动态规划的题目，遇到这种题目根本不知道用动态规划，也不明白如何用动态规划，可悲可悲,明天可以把之前做的那四个动态规划的题目给总结了) 这样动态规划的思路就用了，如何使用代码来实现呢？ 上面的f(i, j)很容易的想到使用二维数组来实现，和背包问题是类似的。f(i, j)表示的意思就是i-j是否是回文串（i和j都是包含的） 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Solution { public: static string longestPalindrome(string s) { int length = s.length(); if(length == 0 || length == 1){ return s; } int max_len=1; int max_start=0; bool** f= new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } // 这个似乎不初始化也是对的 // for (int i=0; i&lt;length; i++){ // for (int j=0; j&lt;length; j++){ // f[i][j] = false; // } // } for(int j=0;j&lt;length;j++){ int i=0; f[j][j]=true; for(;i&lt;j;i++){ f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); if(f[i][j] &amp;&amp; j-i+1 &gt; max_len){ max_len = j-i+1; max_start = i; } } } return s.substr(max_start, max_len); } }; int main(int argc, char const *argv[]) { cout&lt;&lt;Solution::longestPalindrome(&quot;abbbbdsfdsga&quot;)&lt;&lt;endl; system(&quot;pause&quot;); return 0; } 代码说明： 堆上的二维数组 因为这里我使用的C++，不是Java。所以说在堆上new一个二维数组这种玩意的事，我是真的没用过。问了网上，他们都推荐使用vector,不过这个vector还是要resize的要给定vector一个大小才能够那样像数组一样的使用 vector&lt;vector&lt;bool&gt;&gt; f; for (int i=0; i&lt;length; i++){ f.emplace_back(vector&lt;bool&gt;(length, false)); } 这样确实是一个好办法，不过new二维数组也不是难事，我一开始是这样子干的。 bool** f = new bool[length][length]; 不过，很遗憾，报错了，不可以在堆上new出一个二维的数组，这里是C++，这里不是Java。 那怎么办呢？我又尝试了这样子的 bool** f = new bool[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这个方法也确实是够蠢的，new返回的是bool*，我却使用bool**来接收，这是肯定错误的啊。 后来查了资料才知道，原来可以这样子干啊。 bool** f = new bool*[length]; for (int i=0; i&lt;length; i++){ f[i] = new bool[length]; } 这样子就搞定了，第一个new返回的是bool**类型的，第二个new返回的是bool*类型的， 这样子堆上的一个二维数组的问题也就解决了。那为啥不用vector呢？可以用，而且作为使用C++的程序员，最好就别使用这种C类型的数组的。但是为了满足好奇心，这次就使用一下子。(C++11中stl中出现了array，其实说真的我们已经不需要C类型的任何数组和，无论是堆上的还是常量区上的，C++中都有对应的数据结构，stl就是这么强大) for循环内 和背包问题是类似的，我们可以先只是取前面几个字符串，然后每次加一个字符。j就是代表着取的字符串的最后的位置（包含）。每次都将f[j][j]置为true，因为此时字符串长度为1这肯定是回文的。然后然i从0开始到j判断f[i][j]的值，也就是说此时j永远是结束的那个位置。而j又是从0开始的到length-1结束，也就是所有的情况都会被遍历的。而这个算法的时间复杂度从这儿就很容易的得出来是O(n2)，空间复杂度也是O(n2)，算得上是一个比较低效的算法了，就这个题目有O(n), O(n)的算法，不过我也不需要去了解了，看过多的骚算法也不好，反正也用不到，费脑细胞。 f[i][j]=(s[j]==s[i]&amp;&amp;(j-i==1||f[i+1][j-1])); 这个就是使用的上面的那个递推的表达式，不过有点儿不同。我在后面加入了j-i==1，这时也就是说字符串的长度就是2，这是是不能进行后面的那个递推的，所以要单独拎出来。 至于后面的那个判断也就是看看找到的回文字符串的长度有没有最大的大，如果有的话就把他记下来，而且还要把开始的位置记下来，因为函数返回的字符串不是长度。刚好c++中的substr()这个函数就两个参数，第一个参数是开始的索引，第二个位置是字符串的长度。 return s.substr(max_start, max_len); 如果是Java的话就不是这样子了。Java当中的substring()函数（为啥不是subString？这明显不符合Java函数的驼峰式的命名规范啊。。。）的第一个参数是开始的索引，第二个参数的结束的索引（不包含） return s.substring(max_start, max_start+max_len); 总结动态规划算法算是很常见的了，如果理解了这个算法，会发现这个算法其实代码很好写，就是找那个递推的关系。不过我现在也就是停留在能做成做过的动态规划的题目，如果真的是给我一道算法的题目，我真的不知道是否该用动态规划算法，如果要用又是怎么用呢？唉，还是太菜了，对这个算法的理解还不够。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（二）工厂模式]]></title>
    <url>%2F2019%2F07%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本介绍大名鼎鼎的GOF对工厂模式的定义是这样子的。 “Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。) 工厂模式的分类 简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。 工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式； 抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。 为什么要使用工厂模式 解耦 ：把对象的创建和使用的过程分开 降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。 下面将分这三种模式来简单的介绍一下工厂模式。 简单工厂模式简单工厂的基本介绍严格的说，简单工厂模式并不是23种常用的设计模式之一，它只算工厂模式的一个特殊实现。简单工厂模式在实际中的应用相对于其他2个工厂模式用的还是相对少得多，因为它只适应很多简单的情况。 最重要的是它违背了我们在概述中说的 开放-封闭原则 （虽然可以通过反射的机制来避免，后面我们会介绍到） 。因为每次你要新添加一个功能，都需要在生switch-case 语句（或者if-else 语句）中去修改代码，添加分支条件。 简单工厂的适用场景 需要创建的对象较少。 客户端不关心对象的创建过程。 简单工厂模式角色分配 工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。 抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 简单工厂实例public interface IProduct { void print(); // 这是要暴露的方法 } public abstract class AbstractProduct implements IProduct { protected void printBefore(){ System.out.println(&quot;before print&quot;); // 这里所公共的实现 } } public class AProduct extends AbstractProduct { private String name; public AProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print A &gt;&gt;&gt;&quot;+name); } } public class BProduct extends AbstractProduct { private String name; public BProduct(String name){ this.name = name; } @Override public void print() { this.printBefore(); System.out.println(&quot;print B &gt;&gt;&gt;&quot;+name); } } public class SimpleFactory{ public static AProduct sellAProduct(){ return new AProduct(); } public static BProduct sellBProduct(){ return new BProduct; } } 这里我们有两个产品分为是产品A和产品B。还有一个卖产品的简单工厂，里面有卖A产品和卖B产品的地方。现在我们加入这个设计是合理的。现在多了一个C产品，我们要写一个C产品，让他继承那个抽象的产品，然后还有在工厂当中加入买C产品的函数。这显然有点儿烦了。我们可以将工厂进一步的抽象。 public class SimpleFactory { public static IProduct getProduct(String name){ if(&quot;A&quot;.equals(name)){ return new AProduct(name); }else if(&quot;B&quot;.equals(name)){ return new BProduct(name); }else if(&quot;C&quot;.equals(name)){ return new CProduct(name); }else { throw new IllegalArgumentException(); } } } 这样我们就可以只用一个方法就可以完成所有的产品的制作了。但是这个简单工厂并不符合设计模式。每次增加产品的时候都要修改工厂类的方法。我们做产品的一个主要的思路就是尽量不要依赖具体，尽量不要修改而是增加。 为什么要使用工厂模式？ 如果这里要要多了店要来买我们的产品，如果没有工厂的话，所有的店都要依赖我们的产品类。一旦产品有什么修改，比如说增加了什么产品，或者修改了什么产品，所有的店家都要修改代码。所以说这样非常的不好。有了工厂之后，店不用直接依赖什么具体的类，不用使用new来产生产品，而是依赖工厂，通过工厂来获取产品。只是产品有了修改，在简单工厂模式里面来说，只是修改了工厂类而已，店家的类的代码没有必要去修改。 再来一个例子 创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图. （1）创建Shape接口 public interface Shape { void draw(); } （2）创建实现该接口的具体图形类 圆形 public class Circle implements Shape { public Circle() { System.out.println(&quot;Circle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Circle&quot;); } } 长方形 public class Rectangle implements Shape { public Rectangle() { System.out.println(&quot;Rectangle&quot;); } @Override public void draw() { System.out.println(&quot;Draw Rectangle&quot;); } } 正方形 public class Square implements Shape { public Square() { System.out.println(&quot;Square&quot;); } @Override public void draw() { System.out.println(&quot;Draw Square&quot;); } } （3）创建工厂类： public class ShapeFactory { // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) { if (shapeType == null) { return null; } if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) { return new Circle(); } else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) { return new Rectangle(); } else if (shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)) { return new Square(); } return null; } } （4）测试方法： public class Test { public static void main(String[] args) { // 获取 Circle 的对象，并调用它的 draw 方法 Shape circle = ShapeFactory.getShape(&quot;CIRCLE&quot;); circle.draw(); // 获取 Rectangle 的对象，并调用它的 draw 方法 Shape rectangle = ShapeFactory.getShape(&quot;RECTANGLE&quot;); rectangle.draw(); // 获取 Square 的对象，并调用它的 draw 方法 Shape square = ShapeFactory.getShape(&quot;SQUARE&quot;); square.draw(); } } 输出结果： Circle Draw Circle Rectangle Draw Rectangle Square Draw Square这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。 所以说简单工厂模式需要进行改进。 工厂方法模式先来说说上面的AB产品的例子。 public interface IFactory { IProduct getProduct(); } public class AFactory implements IFactory { @Override public IProduct getProduct() { return new AProduct(AProduct.class.getName()); } } public class BFactory implements IFactory { @Override public IProduct getProduct() { return new BProduct(BProduct.class.getName()); } } 这一次我们让客户端不再依赖具体的工厂类，而是依赖一个抽象的工厂类。然后让各个生产对应的产品的工厂继承抽象工厂，实现抽象工厂的方法。这时，我们就满足依赖倒置原则了。我们的客户端不再依赖具体，而是一览抽象。当我们有了一个C产品的时候，我们只有添加C类，和CFactory就行了，我们这时只是增加了代码，没有修改之前的代码，符合设计模式的规则。 突然发现有些糟糕了，因为代码变得很多了，因为功能类似的产品我们进行 3 层抽象，针对每个产品我们还抽象出了 2 层的工厂类。但是我们在某个具体的业务场景中，不单单是只实例化一个类啊。举一个例子，在游戏中，我们要一个战士配装备，首先我们需要配一把枪械（枪械有很多，步枪，狙击枪等，使用问题 1 进行抽象），但是配了枪械之后，我们还需要配子弹啊（继续使用问题 1 的方法进行抽象），好了，现在可以抽象出 2 层的工厂类了，针对现在的情况我们是不是可以让一个工厂既生产枪械，又生产子弹呢？ 这就是抽象工厂模式。简单来说，可以把有一些有联系或者相近的产品，放到一个工厂去生产，没有必要单独再开一个工厂了。 图形的工厂方法的介绍 上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。 (1)增加一个工厂接口： public interface Factory { public Shape getShape(); }（2）增加相关工厂类: 圆形工厂类 public class CircleFactory implements Factory { @Override public Shape getShape() { // TODO Auto-generated method stub return new Circle(); } }长方形工厂类 public class RectangleFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Rectangle(); } }圆形工厂类 public class SquareFactory implements Factory{ @Override public Shape getShape() { // TODO Auto-generated method stub return new Square(); } }（3）测试： public class Test { public static void main(String[] args) { Factory circlefactory = new CircleFactory(); Shape circle = circlefactory.getShape(); circle.draw(); } }输出结果： Circle Draw Circle工厂方法的一些应用我们都知道 Java 的泛型是采用类型擦除来实现的（在 javac 编译过程的中把泛型去掉，加上强制类型转换）。所以我们不能直接 new T()来实例化一个对象。其实可以采用工厂方法模式设计模式来解决。 假设我们有一个类，里面要用到了泛型的实例化。 public class Foo&lt;T&gt;(){ private T t; public Foo(){ t = new T(); // 这个代码是有问题的，我们使用工厂设计模式进行改进 } } 我们给出工厂接口如下： public interface IFactory&lt;T&gt;(){ T create(); } 进而我们可以采用如下的方法进行改进 public class Foo&lt;T&gt;(){ private T t; public &lt;F extends IFactory&lt;T&gt;&gt; Foo(F factory){ // t = new T(); return factory.create(); } } 这个时候，我们可以采用如下的方式实例化 Foo new Foo(new Ifactory&lt;Integer&gt;(){ Integer create(){ return new Integer(0); } }); new Foo(new Ifactory&lt;String&gt;(){ String create(){ return &quot;Hello&quot;; } }); 抽象工厂抽象工厂的基本介绍在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。 抽象工厂应该是比较最难理解的一个工厂模式了。 抽象工厂的适用场景 和工厂方法一样客户端不需要知道它所创建的对象的类。 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品） 系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则） 抽象工厂方法模式角色分配 抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。 具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。 抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。 具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。 不知道大家玩过穿越火线或者吃鸡这类游戏了吗，游戏中存在各种枪。我们假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。（AK工厂生产AK系列产品包括子弹啊，AK枪的类型啊这些，M4A1工厂同理） （1）创建相关接口： 枪 public interface Gun { public void shooting(); } 子弹 public interface Bullet { public void load(); } （2）创建接口对应实现类： AK类 public class AK implements Gun{ @Override public void shooting() { System.out.println(&quot;shooting with AK&quot;); } } M4A1类 public class M4A1 implements Gun { @Override public void shooting() { System.out.println(&quot;shooting with M4A1&quot;); } } AK子弹类 public class AK_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with AK&quot;); } } M4A1子弹类 public class M4A1_Bullet implements Bullet { @Override public void load() { System.out.println(&quot;Load bullets with M4A1&quot;); } } （3）创建工厂接口 public interface Factory { public Gun produceGun(); public Bullet produceBullet(); } （4）创建具体工厂 生产AK和AK子弹的工厂 public class AK_Factory implements Factory{ @Override public Gun produceGun() { return new AK(); } @Override public Bullet produceBullet() { return new AK_Bullet(); } } 生产M4A1和M4A1子弹的工厂 public class M4A1_Factory implements Factory{ @Override public Gun produceGun() { return new M4A1(); } @Override public Bullet produceBullet() { return new M4A1_Bullet(); } } （5）测试 public class Test { public static void main(String[] args) { Factory factory; Gun gun; Bullet bullet; factory =new AK_Factory(); bullet=factory.produceBullet(); bullet.load(); gun=factory.produceGun(); gun.shooting(); } } 输出结果： Load bullets with AK shooting with AK总结意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 主要解决：主要解决接口选择的问题。 何时使用：我们明确地计划不同条件下创建不同实例时。 如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。 关键代码：创建过程在其子类执行。 应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。 注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 参考：深入理解工厂模式 知乎回答 工厂模式|菜鸟教程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图和图的BFS与DFS]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%9B%BE%E5%92%8C%E5%9B%BE%E7%9A%84BFS%E4%B8%8EDFS%2F</url>
    <content type="text"><![CDATA[图和图的BFS与DFS图的基本介绍图和树一样，也是一种数据结构，不过这种数据结构恐怕是来得复杂了那么一点点。图一般由节点(Vertex) 与 边（Edge）来组成， 其中边是否是有方向的又将图分为有向图和无向图。有时边还是带有权值的，这时图被称为带权图。 图的表示的方式也有很多样，这里我们采用的是最简单的邻接矩阵来表示图。不要看到矩阵就嗷嗷嗷的~其实这里就是一个二维的数组而已，和线代没关系的，不要慌嘛。 图的创建看其实图和树还是有一点儿像的，但如果使用树的方式去构建图的话，效率就会变得特别的低下，所以我们要考虑其他的表示图的方案。 表示顶点创建图类的第一步是要创建一个Vertex类保存顶点和边。这个类的作用与链表和二叉搜索树的Node类一样。Vertex类有两个数据成员： 一个用于标识顶点，另一个是表示这个顶点是否被访问过的布尔值。分别命名为label 和 wasVisited.这个类只需要一个函数，那就是为顶点的数据成员设定值的构造函数。 class Vertex&lt;E&gt;{ private E label; private boolean isVisited; public Vertex(E label){ this.label = label; } public E getLabel() { return label; } public void setLabel(E label) { this.label = label; } public boolean isVisited() { return isVisited; } public void setVisited(boolean isVisited) { this.isVisited = isVisited; } } 表示边图的实际信息都保存在边上，因为它们描述了图的结构。我们容易像之前提到的那样用二叉树的方式去表示图，这是不对的。二叉树的表现形式相当固定，一个父节点只能有两个子节点，而图结构却要灵活的多，一个顶点既可以有一条边，也可以有多条边与它相连。 我们是用邻接矩阵的方式来表示顶点是否是相邻的，如果是相邻的权值又是多少。 上图就是一个邻接矩阵，可以看到这个是一个实对称矩阵（求出对应的二次型的标准型，并判断是否正定，跑偏了，和线性代数没有关系的）。第一行的那个2就表示第一个节点和第二个节点是相连的，而且权值为2，这个又是一个无向图，所以一定是对称的。 表示图根据上面的思路就可以轻松的写出图的结构，还有一些简单的函数。 使用集合来存放节点，是用二维数组来存放邻接矩阵。so easy class Graph2&lt;E&gt; { private ArrayList&lt;Vertex&lt;E&gt;&gt; vertexList; private int[][] edges; private int numOfEdges; public Graph2(int n) { this.edges = new int[n][n]; this.vertexList = new ArrayList&lt;Vertex&lt;E&gt;&gt;(n); this.numOfEdges = 0; } public int getNumOfVerter() { return vertexList.size(); } public int getNumOfEdges() { return numOfEdges; } public E getValueByIndex(int index) { return vertexList.get(index).getLabel(); } public int getWeight(int v1, int v2) { return edges[v1][v2]; } public void showGraph() { for (int[] val : edges) { System.out.println(Arrays.toString(val)); } } public void insertVertex(Vertex&lt;E&gt; vertex) { vertexList.add(vertex); } public void insertEdge(int v1, int v2) { insertEdge(v1, v2, 1); } public void insertEdge(int v1, int v2, int weight) { edges[v1][v2] = weight; edges[v2][v1] = weight; ++numOfEdges; } } 下面我们去主方法进行一次测试，看看代码是否存在一些问题。 public static void main(String[] args) { int n = 5; Graph2&lt;String&gt; graph = new Graph2&lt;String&gt;(n); String[] vertexValues = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}; for (int i = 0; i &lt; vertexValues.length; i++) { graph.insertVertex(new Vertex&lt;String&gt;(vertexValues[i])); } graph.insertEdge(0, 1); graph.insertEdge(0, 2); graph.insertEdge(1, 2); graph.insertEdge(1, 3); graph.insertEdge(1, 4); graph.showGraph(); } 输出的结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0] 到此为止，一个图就已经创建完成了。下面我们开始研究图的遍历的问题。 图的遍历图的遍历和树的遍历一样，也有两种。一个广度优先遍历，一个是深度优先遍历。之前在将树的遍历的时候就讲了这个是如何实现的了。不过图的遍历和树的遍历又是不一样的了，图中是没有指针来连接各个节点的。所以说只是遍历的思路是一样的，算法还是完全不同的。树的遍历用到了队列和栈，不过图是不需要的。 深度优先遍历 深度优先遍历的思路 深度优先搜索DFS遍历类似于树的前序遍历。其基本思路是： 假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点v为初始出发点，首先访问出发点v，并将其标记为已访问过。 然后依次从v出发搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点出发，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到。 若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。 简单的来说，深度优先搜索包括从一条路径的起始点开始追溯，直到到达最后一个顶点，然后回溯，继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止 这不是在搜索特定的路径，而是通过搜索来查看在图中有哪些路径可以选择。 如图所示： 深度优先搜索的算法比较简单： 访问一个没有访问过的顶点，将它标记为已访问，再递归地去访问在起始点的邻接表中其他没有访问过的顶点。 代码实现首先我们要写找到临近节点的函数 public int getFirstNeighbor(int index) { for (int j = 0; j &lt; getNumOfVerter(); j++) { if (edges[index][j] &gt; 0) {// 表示两个节点是相通的。 return j; } } return -1; } public int getNextNeighbor(int v1, int v2) { for (int j = v2+1; j &lt; getNumOfVerter(); j++) { if (edges[v1][j] &gt; 0) { return j; } } return -1; } 然后就可以写深度优先遍历的代码了 // 图的深度优先遍历(DFS) private void depthFirstSearch(int i) { System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); int w = getFirstNeighbor(i); while (w != -1) { // 如果第一个邻近顶点w没有被访问过，就直接以他作为开始继续深度优先 if (!vertexList.get(w).isVisited()) { depthFirstSearch(w); }else { // 如果已经被方位过了，就继续寻找下一个w，如果等于-1的话就说明，没有邻近定点了，退出循环即可。 w = getNextNeighbor(i, w); } } } public void depthFirstSearch() { initVisit(); // 图并不一定是连通的，我们要对每一个顶点都作为开始判断一下，是否有没有被访问过的节点。 for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { depthFirstSearch(i); } } } // 初始化visit，防止之前已经进行过什么遍历了，再次遍历就会出问题。 public void initVisit() { for (Vertex&lt;E&gt; val : vertexList) { val.setVisited(false); } } 代码说明： 大部分的内容我都在上面的注释中进行过说明了，而且这个图的深度优先的遍历确实是有一点儿简单，所以没什么说的也是很正常的，看懂我注释基本上的明白了图的深度优先遍历的。 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 广度优先遍历 广度优先遍历的思路 广度优先搜索遍历BFS类似于树的按层次遍历。其基本思路是： 首先访问出发点Vi 接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。 然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。 如图所示： 简单的来说，广度优先搜索从一个顶点开始，尝试访问尽可能靠近它的顶点。本质上这种搜索在图上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的层 广度优先搜索算法使用了抽象的队列而不是数组来对已经访问过的顶点进行排序。算法工作原理如下： 查找与当前顶点相邻的未访问顶点，将其添加到已访问顶点列表及队列中; 从图中取下一个顶点v，添加到已访问的顶点列表 将所有与v相邻的未访问顶点添加到队列。 可见这个图的广度优先遍历和树的广度优先遍历还是有点儿相似的，都是使用队列这个数据结构来实现的。深度优先遍历不一样，树使用的是栈这个数据结构。 代码实现// 广度优先遍历(BFS) private void broadFirstSearch(int i) { int u; // 队列的头节点对应的下标 int w; // LinkedList实现了队列的接口，所以说可以拿来当队列来使用 LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;); vertexList.get(i).setVisited(true); queue.addLast(i);// 入队列 while (!queue.isEmpty()) { u = queue.removeFirst();// 出队列 w = getFirstNeighbor(u); while (w != -1) { if (!vertexList.get(w).isVisited()) { System.out.print(getValueByIndex(w) + &quot;-&gt;&quot;); vertexList.get(w).setVisited(true); queue.addLast(w); }else { w = getNextNeighbor(u, w); } } } } public void broadFirstSearch() { initVisit(); for (int i = 0; i &lt; getNumOfVerter(); i++) { if (!vertexList.get(i).isVisited()) { broadFirstSearch(i); } } } 代码说明： u和w是什么含义？ u表示的是队列中的第一个顶点，也就是说出队列的那个顶点。w和上面的深度优先是一样的，都是表示的是当前顶点的下一个邻接顶点。 两个while循环？ 先看第二个while循环，如果这个邻接顶点w没有被访问过，那么我们就方位，不然我们就找u的下一个邻接顶点。其实这个也是很好理解的。如果这个while循环结束的话，那么也就是以为着u的所有的邻接顶点都被访问过了。那么我们就访问u的邻接顶点的所有的邻接顶点。刚才的u的所有的邻接顶点都已经入队列了。我们只需要按顺序让他们出队列就行了。如果第一个while循环也结束了，那就说明u的所有的可以连通的顶点都通过广度优先遍历访问玩了。但是这并不意味着图就遍历完了。上面也说过了，图可能不是连通的。所以就有了下面的那个函数来做保证 输出结果： [0, 1, 1, 0, 0][1, 0, 1, 1, 1][1, 1, 0, 0, 0][0, 1, 0, 0, 0][0, 1, 0, 0, 0]A-&gt;B-&gt;C-&gt;D-&gt;E-&gt; 和深度优先遍历输出的结果竟然是一样的，不过这个例子是纯属巧合而已 总结上面我表示图是用的邻接矩阵的方式，还可以使用邻接表的方式来表示这个图结构，而且效率也是有点儿小高。不过这里我就不瞎掰了，就先介绍一个邻接矩阵就完事了。感觉图的 BFS和DFS比树的真的是差不多，至少理解其实都不是很难。 参考文章：数据结构与算法：图和图算法(一)扩展文章：数据结构与算法 - 图论]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式（一）单例模式]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式 单例模式基本介绍单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 单例模式的基本思路实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 单例模式的实现饿汉式public class SingletonTest01{ public static void main(String[] args) { // Singleton01 singleton01 = new SingletonTest01(); Singleton01 singleton1 = Singleton01.getInstance(); Singleton01 singleton2 = Singleton01.getInstance(); System.out.println(&quot;singleton1:&quot;+singleton1.hashCode()); System.out.println(&quot;singleton2:&quot;+singleton2.hashCode()); } } class Singleton01 { // 静态变存储唯一的实例化对象 private static final Singleton01 INSTANCE = new Singleton01(); // 构造器私有化 private Singleton01() {} // 提供唯一的实例化对象 public static Singleton01 getInstance() { return INSTANCE; } } 像这样子实现单例模式，似乎是已经足够了。但是这样子做的效率不是非常高，因为当我们创建这个类的时候，无论有没有使用到这个类的实例都会产生这个对象，所以说这样子的单例模式的代码不具有懒加载性，需要改进。不过值得鼓励的是，这样的代码在多线程的模式下，不会产生任何的混乱，这也算是他的一个优点吧。 输出结果： singleton1:1534030866singleton2:1534030866 懒汉式public class SingletonTest02 { public static void main(String[] args) { Singleton02 singleton1 = Singleton02.getInstance(); Singleton02 singleton2 = Singleton02.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton02{ private static volatile Singleton02 INSTANCE; private Singleton02() { } public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } } 代码说明： volatile关键词？ 这个关键词C++中也有使用，但是也是非常的少见，基本上没有人用。 被volatile修饰的共享变量，就具有了以下两点特性： 1.保证了不同线程对该变量操作的内存可见性; 2.禁止指令重排序 volatile这个东西基本上都和多线程有关系，这里就不作深究了。 两个if判断和synchronized(Singleton02.class) 为了实现懒加载，我们要做的是在调用getInstance这个方法的时候才去构建这个对象，不过考虑到多线程的情况下。如果直接是这样子写的话 public static Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 这个代码在单线程的情况下是一点问题都没有的。但如果是多线程的环境下，有多个线程同时进入了if语句就会构建许多的对象，这就不是单例模式了，所以说这样的代码不能够使用。 那是不是加个锁就行了呢？ public static synchronized Singleton02 getInstance(){ if (INSTANCE == null){ INSTANCE = new Singleton02(); } return INSTANCE; } 确实是这样子代码确实就能用了，但是又不出现了一个新的问题。线程的同步是要花很多时间的。你一个线程调用这个函数其他的线程都要等你这个线程，这显然是效率太低了。 那行，咋继续改，不给方法加锁，只是给new语句加锁不就完事了嘛。** public static Singleton02 getInstance(){ if (INSTANCE == null){ synchronized(Singleton02.class){ INSTANCE = new Singleton02(); } } return INSTANCE; } 给整个if语句加锁就相当于是给整个方法加锁，所以说是没有用的。这里给new语句加锁。不能说是效率低的问题了，是直接错误的。事实上，完全有可以多个线程同时进入了if语句内，虽然new加锁了，那几个进入if语句的线程都会执行new语句，破坏了单例模式。 那怎么改呢？这就到了我们代码中的那个双重检查锁了。 public static Singleton02 getInstance() { if (INSTANCE == null) { // 给以下的代码快加上线程锁，只有一个线程可以进入到这个代码块 synchronized (Singleton02.class) { if (INSTANCE == null) { INSTANCE = new Singleton02(); } } } return INSTANCE; } 这时虽然也会有多个线程进入if语句，但是里面还有一个带锁的if，这时第一个线程进入创建对象之后，后面的线程因为if的判断就无法创建对象了，实现了单例模式。 要非常注意的是，前面的INSTANCE要声明为volatile（JDK5以后的版本），不然这个模式使用的失败的。这里我去看了极客班的C++的设计模式的教程，如果没有volatile关键词的话，这个是错误的是不能够使用的。为什么呢？在INSTANCE = new Singleton02()这个语句中，正常我们会想这个应该会先分配内存，然后开始构造函数，再然后把地址赋给INSTANCE。但是由于编译器的优化以及各种其他的情况下，任何语言可能都不是这样子的。大多数情况下，可能是先分配内存，然后直接赋地址，最后再构造函数，也可以是先赋地址，然后再怎么怎么样的。这种情况被称为reorder。这是如果有一个线程进入第一个if，发现你已经赋给地址了，已经不是空了，所以直接就返回，但是构造函数还没有开始启动，这是会发生什么错误是不用说了。加上了volatile之后就是告诉编译器，别给我优化，别给我整这些reorder。C++11当中也引入了这个问题的解决方案，不过确实是有点儿复杂，这里就不多说什么了。 输出结果： singleton1:1534030866singleton2:1534030866 静态内部类使用静态内部类的性质来实现线程的同步。静态内部类中的静态数据只有被类第一次被使用到的时候创建，而且这个还是线程安全的，这都是由JVM来保证的。所以说这种方法也是非常好滴。代码也很易懂，不用做什么说明了。 public class SingletonTest03 { public static void main(String[] args) { Singleton03 singleton1 = Singleton03.getInstance(); Singleton03 singleton2 = Singleton03.getInstance(); System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } class Singleton03{ private Singleton03() {} // 使用静态内部类 private static class SingletonInstance { private static final Singleton03 INSTANCE = new Singleton03(); } public static Singleton03 getInstance() { return SingletonInstance.INSTANCE; } } 输出结果： singleton1:664223387singleton2:664223387 枚举式使用了JDK1.5中添加的枚举来实现单例模式。不仅以及避免多线程同步的问题，而且还可以防止反序列化创建新的对象。而且这种方法也是《Effective Java》中推荐的方法。 public class SingletonTest04 { public static void main(String[] args) { Singleton04 singleton1 = Singleton04.INSTANCE; Singleton04 singleton2 = Singleton04.INSTANCE; System.out.println(&quot;singleton1:&quot; + singleton1.hashCode()); System.out.println(&quot;singleton2:&quot; + singleton2.hashCode()); } } enum Singleton04 { INSTANCE; } 这个方法可谓是简单而又粗暴，而且枚举类也是类，里面也可以有各种方法，也可以有private数据等。这里就不展开对Java中enum的说明了。 输出结果： singleton1:1534030866singleton2:1534030866 C++中的单例模式// ... class lock { public: lock(); lock(lock const &amp; l); ~lock(); lock &amp; operator =(lock const &amp; l); void request(); void release(); // ... }; lock::lock() { // ... } // ... lock::~lock() { // ... } // ... void lock::request() { // ... } void lock::release() { // ... } // ... // assumes _DATA_TYPE_ has a default constructor template&lt;typename _DATA_TYPE_&gt; class singleton { public: static _DATA_TYPE_ * request(); static void release(); private: singleton(); singleton(singleton&lt;_DATA_TYPE_&gt; const &amp; s); ~singleton(); singleton&lt;_DATA_TYPE_&gt; &amp; operator =(singleton&lt;_DATA_TYPE_&gt; const &amp; s); static _DATA_TYPE_ * pointer; static lock mutex; // ... }; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; template&lt;typename _DATA_TYPE_&gt; lock singleton&lt;_DATA_TYPE_&gt;::mutex; template&lt;typename _DATA_TYPE_&gt; _DATA_TYPE_ * singleton&lt;_DATA_TYPE_&gt;::request() { if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer == nullptr) { singleton&lt;_DATA_TYPE_&gt;::pointer = new _DATA_TYPE_; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } return singleton&lt;_DATA_TYPE_&gt;::pointer; } template&lt;typename _DATA_TYPE_&gt; void singleton&lt;_DATA_TYPE_&gt;::release() { if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { singleton&lt;_DATA_TYPE_&gt;::mutex.request(); if(singleton&lt;_DATA_TYPE_&gt;::pointer != nullptr) { delete singleton&lt;_DATA_TYPE_&gt;::pointer; singleton&lt;_DATA_TYPE_&gt;::pointer = nullptr; } singleton&lt;_DATA_TYPE_&gt;::mutex.release(); } } template&lt;typename _DATA_TYPE_&gt; singleton&lt;_DATA_TYPE_&gt;::singleton() { // ... } // ... int main() { int * s; s = singleton&lt;int&gt;::request(); // ... singleton&lt;int&gt;::release(); return 0; } 这个代码着实有点儿难懂，而且我现在还没有接触到C++中的多线程。所以说，代码先放在这儿吧。C++真的是一门高深莫测的语言！ Java库中的单例模式Java.lang.Runtime /** * Every Java application has a single instance of class * {@code Runtime} that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the {@code getRuntime} method. * &lt;p&gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since 1.0 */ public class Runtime { private static final Runtime currentRuntime = new Runtime(); private static Version version; /** * Returns the runtime object associated with the current Java application. * Most of the methods of class {@code Runtime} are instance * methods and must be invoked with respect to the current runtime object. * * @return the {@code Runtime} object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don&#39;t let anyone else instantiate this class */ private Runtime() {} //..... } 可以看到这个使用的第一个，典型的饿汉式的单例模式。因为这个类不需要多线程，所以也没有必要使用懒汉式，这个饿汉式就是perfect的啦~~ 总结 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 当想实例化一个单例类的时候，必须要记住使用对应的获取对象的方法，而不是使用new。 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源，session工厂等）。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AVL Tree]]></title>
    <url>%2F2019%2F07%2F25%2FAVL-Tree%2F</url>
    <content type="text"><![CDATA[AVL TreeAVL Tree的基本介绍AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.来自：GeeksforGeeks 在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。来自：Wikipedia 现在我们看AVL数的中文，自平衡二叉查找树，这个平衡我们从定义中看出来了：任一节点对应的两棵子树的最大高度差为1，那么二叉查找树的概念呢？似乎没有说明，其实二叉查找树(BST)也是一种独立的树结构。那么我们就先来了解一下BST BST的基本介绍二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 比如说上面的这棵树就是一个二叉查找树。 构造BST那么我们该如何构造一颗BST呢？添加节点的时候，当树为空的时候就直接插入节点作为根节点。不然当小于节点且左子树不为空的递归加入左子树，大于节点且右子树不为空的时候加入右子树。左右子树为空的时候就直接插入作为左右子树。 这个思路还是特别的简单的直接按照BST的规则来就完事了。 节点代码实现class Node{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } @Override public String toString() { return &quot;Node [value=&quot; + value + &quot;]&quot;; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } public void add(Node node) { if (node.value &lt; this.value) { if (this.left == null) { this.left = node; return; }else { this.left.add(node); } }else { if (this.right == null) { this.right = node; return; }else { this.right.add(node); } } } //：用于后面的AVT平衡二叉树的操作 public int height() { return Math.max(left == null?0:left.height(), right == null?0:right.height()) +1; } public int leftHeight() { if (left == null) { return 0; } return left.height(); } public int rightHeight() { if (right == null) { return 0; } return right.height(); } public void infixOrder() { if (this.left != null) { this.left.infixOrder(); } System.out.println(this); if (this.right != null) { this.right.infixOrder(); } } public Node search(int value) { if (this.value == value) { return this; } if (value &lt; this.value) { return this.left.search(value); }else { return this.right.search(value); } } public Node searchParent(int value) { if (this.left != null &amp;&amp; this.left.value == value) { return this; } if (this.right != null &amp;&amp; this.right.value == value) { return this; } if (value &lt; this.value) { return this.left.searchParent(value); }else { return this.right.searchParent(value); } } /** * 找到左子树上最大的节点的父节点 * @return 左子树上最大的节点的父节点 没有左子树就返回null */ public Node findLeftMaxParentNode() { if (this.left == null) { return null; } Node temp = this.left; if (temp.getRight() == null) { return this; } if (temp.getRight() != null &amp;&amp; temp.getRight().getRight() != null) { temp = temp.getRight(); } return temp; } /** * 找到右子树上最小的节点的父节点 * @return 右子树上最小的节点的父节点， 没有右子树就返回null */ public Node findRightMinParentNode() { if (this.right == null) { return null; } Node temp = this.right; if (temp.getLeft() == null) { return this; } if (temp.getLeft() != null &amp;&amp; temp.getLeft().getLeft() != null) { temp = temp.getLeft(); } return temp; } } 可见由一个数组构造一个BST还是非常容易的。 BST代码实现class BinarySearchTree { private Node root = null; public BinarySearchTree(Node root) { this.root = root; } public BinarySearchTree() { this.root = null; } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; } public void add(Node node) { if (root == null) { root = node; return; } this.root.add(node); } public int height() { return this.root.height(); } public int leftHeight() { return this.root.leftHeight(); } public int rightHeight() { return this.root.rightHeight(); } public void infixOrder() { if (root == null) { return; } this.root.infixOrder(); } /** * 搜索节点 缺点是重复的值会出现问题，值不能重复 * @param value 要查询的值 * @return 返回找到值的当前节点 找不到就返回null */ public Node search(int value) { if (root == null) { return null; } return this.root.search(value); } /** * 搜索父节点 缺点是值不能重复 * @param value * @return 返回找到值的父节点， 找不到就返回null */ public Node searchParent(int value) { if (root == null) { return null; } if (root.getValue() == value) { return null; } return this.root.searchParent(value); } public Node findLeftMaxParentNode() { return root.findLeftMaxParentNode(); } public Node findRightMinParentNode() { return root.findRightMinParentNode(); } /** * 删除节点 * @param value * @return */ public boolean delNode(int value) { Node node = search(value); Node parent = searchParent(value); if (node == null) { return false; } if (parent == null) { if (root == null) { return true; }else { //：要删除的节点就是根节点 Node leftMaxParentNode = findLeftMaxParentNode(); // System.out.println(leftMaxParentNode.getRight().getValue()); if (leftMaxParentNode == null) { root = root.getRight(); return true; }else { if (leftMaxParentNode == root) { this.root.setValue(this.root.getLeft().getValue()); this.root.setLeft(null); return true; }else { this.root.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } } // 是一个叶子节点 if (node.getLeft() == null &amp;&amp; node.getRight() == null) { if (parent.getLeft() == node) { parent.setLeft(null); }else { parent.setRight(null); } return true; } // 只有一个右子节点 if (node.getLeft() == null) { if (parent.getRight() ==node) { parent.setRight(node.getRight()); return true; }else { parent.setLeft(node.getRight()); return true; } } if (node.getRight() == null) { if (parent.getRight() == node) { parent.setRight(node.getLeft()); return true; }else { parent.setLeft(node.getLeft()); return true; } } // 有两个节点的 Node leftMaxParentNode = node.findLeftMaxParentNode(); if (leftMaxParentNode == node) { node.setValue(node.getLeft().getValue()); node.setLeft(null); return true; }else { node.setValue(leftMaxParentNode.getRight().getValue()); leftMaxParentNode.setRight(leftMaxParentNode.getRight().getLeft()); return true; } } } 可以看到上面的代码还是特别的多的，因为这个代码都是我学习的时候写的，这里就直接复制过来了。里面很多的方法都是为了AVL来写的。其实里面有几个函数还是比较难写的，比如那个删除节点的那个函数我就写了不少的时间，不过，这里这个问题都不是重点了。我们主要说的是AVL树。 从BST到AVL虽然说BST是蛮好的，中序遍历一个BST我们就能得到一个有序的数组，这个是多么的方便。但是BST也存在了一些问题。比如说我给定的数组是1 2 3 4 5 6使用这个数组构造BST的时候，我们发现构造出来一个非常奇怪的树。 1 2 3 4 5 6一个如同单链表的BST，但是效率比单链表还要低。有些人会说，我们可以使用中位数作为节点来构造二叉树，但是这个依然是有问题的。 4 3 5 2 6 1 7这棵树是效率高的吗？童谣也不是，效率和单链表其实也差不多。 是什么导致这些BST的效率很低的？因为这些树不平衡，这就可以联系到上面的AVL中关于平衡的定义了。左右子树的高度差不大于1。而且是所有的子树的左右子树的高度差都不大于1。所以说上面的两棵树都不是AVL。 An Example Tree that is an AVL Tree The above tree is AVL because differences between heights of left and right subtrees for every node is less than or equal to 1. An Example Tree that is NOT an AVL Tree The above tree is not AVL because differences between heights of left and right subtrees for 8 and 18 is greater than 1. Insertion Examples: AVL代码实现class AVLTree extends BinarySearchTree { public AVLTree() { this.setRoot(null); } public AVLTree(Node rootNode) { this.setRoot(rootNode); } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } //：左旋转， 当左子树的高度小于右子树的高度时候可以降低两者之间的差值，使之成为平衡树 public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } //：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } } 旋转 由BST到AVL左旋转public void leftRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setLeft(this.getRoot().getLeft()); newNode.setRight(this.getRoot().getRight().getLeft()); this.getRoot().setLeft(newNode); this.getRoot().setValue(this.getRoot().getRight().getValue()); this.getRoot().setRight(this.getRoot().getRight().getRight()); } 左旋转是非常的形象的。当右子树的高度大于左子树的高度的时候，我们将树进行左旋转这样就可以平衡左右子树之间的高度之差。 如何左旋转： 以当前节点（根节点）值构造一个新的节点。 新节点的左指针指向根节点的左子树 新节点的右指针指向根节点的右子树的左子树。 根节点的左子树指向新节点。 将根节点的右子树的值赋给根节点 根节点的右指针指向根节点的右子树的右子树 这个看起来可能很懵逼，不过看着下面的图基本上就可以理解了。理解之后你也会发现这个这个左旋转会存在一些问题。 右旋转//：右旋转 与上面的左旋转是类似的 旋转不一定是有用的我发现，，，这个1 3 变成了 3 1 可见单旋转并不能将所有的树转换成平衡二叉树 public void rightRotate() { Node newNode = new Node(this.getRoot().getValue()); newNode.setRight(this.getRoot().getRight()); newNode.setLeft(this.getRoot().getLeft().getRight()); this.getRoot().setValue(this.getRoot().getLeft().getValue()); this.getRoot().setRight(newNode); this.getRoot().setLeft(this.getRoot().getLeft().getLeft()); } 右旋转与左旋转类似，这里不再赘述、 恐怕你已经发现了问题，就是原本是1 3的树经过左旋转之后会变成 3 1。 这是如果再使用右旋转又会变成1 3。这个是非常有问题的。那么问题出在了那么了呢？ 我当我们进行右旋转的时候，们将根节点的右子树树指向的是新的节点，新节点的左子树指向的是根节点的左子树的右子树，那么如果根节点的左子树的左子树的高度小于其左子树的右子树的高度上呢？这时就会引发这个问题。此时我们虽然是想右选择的。但是右子树上的新的节点的左子树连接这那个比较大的根节点的左子树的右子树，这时旋转之后右子树就会变得高，不会形成一个AVL。此时需要平衡一下根节点的左子树，使左子树先来一次左旋转 左旋转也是类似的道理。因此需要将左右旋转结合起来写一个新的函数。 左右旋转结合public void createAVLTreeOneTime() { if (leftHeight() - rightHeight() &gt; 1) { //：进行双旋转， 如果这个左子树的右节点的高度大于右子树先对左子树进行左旋转 if (this.getRoot().getLeft().leftHeight() &lt; this.getRoot().getLeft().rightHeight()) { new AVLTree(this.getRoot().getLeft()).leftRotate(); } this.rightRotate(); } else if (rightHeight() - leftHeight() &gt;1) { if (this.getRoot().getRight().rightHeight() &lt; this.getRoot().getRight().leftHeight()) { new AVLTree(this.getRoot().getRight()).rightRotate(); } this.leftRotate(); } else return; } public void createAVLTree() { while ((leftHeight() - rightHeight() !=1 &amp;&amp; leftHeight() -rightHeight() !=0) &amp;&amp; (rightHeight() - leftHeight() != 1 &amp;&amp; rightHeight() - leftHeight() !=0)) { createAVLTreeOneTime(); } } 这样我们的AVL就完成了，上面的代码都已经做了说明，不想说了。而且这种二叉树的问题，说明是真的难说，还是自己拿一个笔多画一画就完事了，画着画着就可以理解其中的大智慧了。 上面的图可能看起来有点儿懵逼，不过我感觉画的特别的形象。主要讲了旋转的事情。要结合上面的代码一起进行消化理解吸收。 总结这个讲的稍微的敷衍，不过也没有办法，我主要想说的就是AVL的旋转而已，但是又是用语言难以理解的，于是上外网盗了一些图片过来辅助理解，不知道下次这些图片会不会么得了，嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sunday字符串匹配算法]]></title>
    <url>%2F2019%2F07%2F25%2FSunday%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Sunday字符串匹配算法Sunday算法的基本介绍字符串匹配的算法其实之前就已经说过一个KMP算法了，不过现在我还是有点儿不理解KMP算法中next数组中的精髓。其实关于字符串匹配的算法基本有以下的四种。BF算法，这个就是我们在说KMP算法中的那个暴力匹配的那个算法。其次就是KMP算法，也就一种比较难以理解的算法。然后是BM算法，据说是KMP算法的优化，不过实在是恐怖，我看着也十分的复杂，根本没有看的兴趣。最后一个就是Sunday算法，且不论这个算法到底怎么样，就凭这个算法的名字也要努力学习吖。Sunday~多暖的名字吖。关键是我听说Sunday算法简单高效易理解！！！ Sunday算法的基本思路Sunday算法和BM算法稍有不同的是，Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1； 否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。 可以说这个思路是非常的亲民了。 下面举个例子来了解一下Sunday算法: 参考文章：字符串匹配之Sunday算法 由此可见在这个例子中，Sunday算法的效率还是非常高的，不过也可以看出来，Sunday算法也是有一点儿不稳定的。如果每次都发现后面的那个元素和最后一个相同，那么这个就变成了BF暴力匹配的算法了。 代码实现这里博主使用的是Java，那我就不使用Java，用C++吧，我还是喜欢我的vscode。。。蛤蛤蛤 /** * Sunday字符串匹配算法 */ #include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; const int ASCII_SIZE = 128; int sunday(string str, string sub) { int strLength = str.size(); int subLength = sub.size(); int move[ASCII_SIZE]{0}; for (size_t i = 0; i &lt; ASCII_SIZE; i++) { move[i] = subLength + 1; } for (size_t i = 0; i &lt; subLength; i++) { move[sub[i]] = subLength - i; } int i = 0; int j = 0; while (i &lt;= strLength - subLength) { j = 0; while (str[i + j] == sub[j]) { j++; if (j &gt;= subLength) { return i; } } i += move[str[i + subLength]]; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABDE&quot;; int index = sunday(str, sub); // cout &lt;&lt; sub &lt;&lt; endl; // cout &lt;&lt; str.substr(index, sub.length()) &lt;&lt; endl; cout &lt;&lt; (sub == str.substr(index, sub.length()) ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; system(&quot;pause&quot;); return 0; } 代码说明： ACSII_SIZE和move是什么意思？ ACSII_SIZE常用的字符有128个（键盘上可以找得到的），还有另外的128个是找不到的，所以这里我们只使用128而不是256。说到Sunday算法规则的时候我们也提到了。每次匹配失败往后移动多少位完全是取决于匹配失败时子串对应的后一个字符。（可以看上面的图进行理解），所以说每个字母都对应了一个移动的位数。我们可以用一个数组来存储移动的位数。比如说字母a要移动六位就是——move[‘a’] = 6 也就是 move[97] = 6（a对应的ascii值是97） 第一个for循环？ 当字母没有出现的时候，移动位数 = 模式串长度 + 1 第二个for循环 当字母出现的时候， 移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。不过上面说的是最右出现的位置，这里没有考虑啊。此言差矣，其实考虑了，i是从左到右进行覆盖的，如果出现了重复的字符，move数组里面存放的肯定是最右面的那个字符对应的移动位数。 i, j与while循环 i表示的指向主串的开始的位置。j表示的指向字符正在匹配的字符的位置。注意：这里i并不是指向当前正在比较的字符的位置。当前主串中正在匹配的字符的位置是i+j。每次匹配失败的时候，i向后面移动相对应的位置。j重置为0重新进行比较。 总结不得不说，这个Sunday算法真的简单易理解，关键代码还很好写，效率也非常高。这特喵的谁还看那个什么KMP算法啊。那个啥BM算法反向比较致敬韦神我是更不可能去看的了。不管了，反正Sunday算法赛高就完事了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归与回溯]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[递归与回溯关于递归与回溯其实之前我们已经遇到了好多的递归的问题了，比如说动态规划里面的就用到了不少的递归，那种递归也可以转换成为递推。但是这里我们讲的是递归与回溯。何为回溯？ 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 可以看出来递归其实是回溯的一个实现条件，一个算法既然和递归联系起来了，那免不了麻烦的事情，回溯法也是如此，需要我们对递归有着深层次的理解，才能够游刃有余的掌握。 看一下网上对回溯法的一些说明： 回溯法一般都用在要给出多个可以实现最终条件的解的最终形式。回溯法要求对解要添加一些约束条件。总的来说，如果要解决一个回溯法的问题，通常要确定三个元素： 选择。对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列。 条件。对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。 结束。当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。 对于回溯法来说，每次递归调用，很重要的一点是把每次递归的不同信息传递给递归调用的函数。而这里最重要的要传递给递归调用函数的信息，就是把上一步做过的某些事情的这个选择排除，避免重复和无限递归。另外还有一个信息必须传递给递归函数，就是进行了每一步选择后，暂时还没构成完整的解，这个时候前面所有选择的汇总也要传递进去。而且一般情况下，都是能从传递给递归函数的参数处，得到结束条件的。 递归函数的参数的选择，要遵循四个原则：1、必须要有一个临时变量(可以就直接传递一个字面量或者常量进去)传递不完整的解，因为每一步选择后，暂时还没构成完整的解，这个时候这个选择的不完整解，也要想办法传递给递归函数。也就是，把每次递归的不同情况传递给递归调用的函数。2、可以有一个全局变量，用来存储完整的每个解，一般是个集合容器（也不一定要有这样一个变量，因为每次符合结束条件，不完整解就是完整解了，直接打印即可）。3、最重要的一点，一定要在参数设计中，可以得到结束条件。一个选择是可以传递一个量n，也许是数组的长度，也许是数量，等等。 4、要保证递归函数返回后，状态可以恢复到递归前，以此达到真正回溯。 递归与回溯的经典案列迷宫问题基本介绍看到之前回溯的概念我们可以非常轻易的想到迷宫问题。走不通就退回再走的技术为回溯法，迷宫不也是走不通就退回再走吗，非常的符合回溯法的使用条件。 至于迷宫问题的题目我就不多说了，就以下面的数组为例，起始点假如规定在左上角的[1][1]处，目标终点在右下角的[10][25]，请走迷宫，并显示程序所走的路径。下图中0表示路，1表示墙。** map = new int[][] { {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}, {1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,1}, {1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1}, {1,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,0,0,0,1}, {1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1}, {1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1}, {1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1}, {1,0,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,1}, {1,1,0,1,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1}, {1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1}, {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1} }; 思路分析我们很容易想到回溯但是到底如何回溯呢？我们要告诉程序如何去走这个迷宫，第一点就是，当四条路都可以走的时候我们怎么走？这是最关键的，我们要给程序设定一个初识的目标，遇到多路口先走什么。 0 0 x 0 0这时我们可以规定一个策略就是先走右面，如果右面不通再走下面，如果再不通就走上面，如果还是不通就走上面。 使用→↓←↑的策略进行这一场的迷宫游戏。 那么有没有可能出现这样一种情况，四条路都不通。——怎么可能四条路都不通，四条路都不通你是怎么进来的？？？ 唉~你错了，还真的有四条路都不通的情况，比如如下的图。 ↓ 1 0 1 1 x 1 1 1 1不对啊，这条路上面不是通的吗？往上走不就完事了吗？但是我们是就是从上面下来的，还能再回到上面去吗？所以我们有必要把我们走过的路进行标记比如标记为2。如果走路的这个路确定是死路了，我们还可以将他标记为3，以和我们走过的路正确的路径进行区分。如果四周都是墙或者走过的路，那么这条路的递归就结束，回到选择这个递归的那个路口，开始下一条路的递归。这就是回溯的过程这样说可能很难听懂，不过看到了代码可就算是柳暗花明了。 代码实现处于路口(迷宫的某一个点)时找路的代码// 递归与回溯 private boolean findWay(int i, int j) { // count++; // 只有走到了目标终点的位置这个函数才会返回true if (map[map.length - 2][map[0].length - 2] == 2) { return true; } else { // == 0 代表这条路还没有走过 if (map[i][j] == 0) { // 设为2 假定这条路可以走了 map[i][j] = 2; // 找路的策略是： // 向下 -》 向右 -》 向上 -》 向左 if (findWay(i + 1, j)) { return true; } else if (findWay(i, j + 1)) { return true; } else if (findWay(i - 1, j)) { return true; } else if (findWay(i, j - 1)) { return true; } else { // 四条路都走不通了 map[i][j] = 3; return false; } } else { // 不是0可能是 1 2 3，反正就是不能走这条路 return false; } } } 代码说明： 这个函数的返回值是什么意思？ 函数的返回值是boolean，他只有在一个情况上返回的 是true，那就是走到了目标终点了。虽然下面也有几个return true，但是那些return true都是依靠if里面为真，而if里面为真只是依靠找到终点了。 下面的if为0是什么意思？ 让我们找路给我们的坐标是i，j如果给定的就是一堵墙，走过了的或者死路，当然要返回false，让它进行下一个路口的探索。也就是下右上左的次序进行走路（其实什么顺序都可以啦，没什么太重要的，都可以走到终点的）。 最后的那个else returnfalse是？ 这说明前面的四个递归返回的都是false，说明什么？四条路都是走不通的，那么就把这个点置为死路点，标记为3。 那这个不是只有一个点是3吗？？死路就这是一个点？ 不是的，当这个点被置为死路3的时候，递归会回溯。比如下面的这个路。 1 2 1 1 3 1 1 1 1（1,1）被标记为3之后，可别忘了(1,1)点是从(0,1)点走过来的。走路的顺序是下右上左。(0,1)点的下面返回false，于是走右面，不通，走上面，走过了，走左面，不通，于是(0,1)也被置为了3。 所以说被置为3的是通往死路的那一整条路啦~~递归就是这么神奇。 这个findWay函数写完了，直接调用findWay(1,1)就可以进行迷宫的探索了。（我们规定的是1,1是起点了） 迷宫的输出结果==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # X X X X # # # # # # # # # X # # # X # # X X X X X # # # # # # # # X # # # # # X # # N # # # X # # # # # # # # X # X X X # X X X # # # # X # # # # # # # # # # X # X # X # X X X N N # # X # # # # # # # X X X # X # X # # # N # # X # # # # # # # # # # # X # X # # # # # X # # # # # X X X X X X X # X # # # # # X # # # # # # # # # X # # # # # # X X # # # # X X X X X X X X X # # # X X X X X X X X # # # # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 这里我们使用#表示墙，X表示正确的路径，N表示走过的死路。空白的区域就是没有走过的路。可见这个下右上左的策略还是蛮不错的，走过的死路是比较上的。如果我们换成左上右下，那么结果又是如何呢？ ==================Maze Result======================== # # # # # # # # # # # # # # # # # # # # # # # # # # # # X X X X # N N N N X X X X X X # # N N N N N # # N # # # # # X # N N # # X # # N N X X X # # N # N # # N # # # N N X # # # # # X # # N # # # X # # N # N N N N # # # # # X # X X X # X # # # # X # # N # # # # # # # N N # X # X # X # X # # X # # N # N # N N # # N N # X X X # X # X # # # # # X X N N # N # # N # # N # # # # # # X # X # # N # # # X X # # # N N N N # # N X X X X X X X # X # # N # # # X X # # # # # # N # # # X # # # # # # X X # # N # # N N X X X X X X X X # # # X X X X X X X X # # # N N N N # # # # # # # # X # # # # # # # # # # # # # # # # # # # # # # # # # # # # 可以看出走过的死路是非常多的，但是无论怎么说都是可以到达终点的。毕竟我们这个题目是从左上角到右上角，我们选定的策略肯定是选右下啊。 在不知道起点终点的时候，我们可以四个策略都使用一下，看看哪个策略走的次数是最少的（有效的路，不算死路)。前面我的代码中也使用了count来计数，就是为了这一点。这样我们基本就可以确定走迷宫的最优路径了。 八皇后问题基本介绍这个题目可以说是非常著名了，我学python的时候就在研究这个问题，但是当时怎么研究都研究不出来到底怎么解决这个问题。递归这种事我们都是不敢想的（递归那该有多难啊），回溯根本不知道回溯是什么玩意。不过现在有个递归和回溯这个武器，八皇后问题可以说只用几行代码就完事了。看一下百度百科对八皇后问题的解释 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。计算机发明后，有多种计算机语言可以解决此问题。 现在有个计算机，什么八皇后，就是八十皇后都么得问题。 思路分析上面也说了，八皇后问题同样是回溯算法的典型案列。那么这个问题该如何回溯呢？迷宫问题是路走不通了我退回去重新走其他的路，那八皇后也很好理解了。皇后放不了了，我换其他地方重新放。 我们可以选择一行一行的放置皇后，这个显然不会对结果产生什么影响，你要是乐意一列一列放也是可以的。 大多数人解决这个问题都喜欢使用二维数组，第一个表示行，第二个表示列，数组的值表示有没有放置过皇后，我承认这样可行。但是真的有必要使用二维数组吗？我们使用一维数组不可以解决这个问题吗？比如使用一个一维数组int[8]。int[0]表示第一行皇后所在的列，我们只要按顺序去放置int[1],int[2]里的值就完事了，这不是很好喵~ 下面就该说说八皇后的回溯了。首先我们也要和迷宫一样确定如何放置皇后，这里其实很容易，直接从第一列开始依次往后尝试呗。（这也是正常人的思想）如果某一列不可以放置皇后(要写个函数进行判断)，就往后放，如果已经是最后一列了。就直接返回false。回到上面的一行(回溯算法)，重新按顺序放置皇后。如果可以放置，就进入下面一行放置皇后，如果第八行的皇后都放置OK了就返回true，这是一种皇后的放置方法已经完成了，不过我们需要循环找到所有的皇后的放置的方法。 代码实现判断是否可以放置皇后private boolean isValid(int n) { ++count2; for (int i = 0; i &lt; n; i++) { // 在同一列或者说是在同一个斜线上 if (map[i] == map[n] || Math.abs(map[n] - map[i]) == Math.abs(n - i)) { return false; } } return true; } 代码说明： count2++ 这个是后面用来统计进行了多少次的皇后判断用的。 map[i] == map[n]? 我们说过了一维数组的值表示的是皇后所在的列，如果map[i] == map[n]那么就说明放置的皇后在同一列，返回的false。 Math.abs(map[n] - map[i]) == Math.abs(n - i)? 这个代表的意义就是列差的绝对值是等于行差的绝对值的。这个我都是使用斜率来理解的。斜率为1或者-1，那么两个 皇后就是在一天斜线上！斜率为其他值的就不算一天直线了吧，国际象棋的规则明白吧老弟~ 这里我们只是和n前面那的皇后进行比较，那么后面呢？ 后面个锤子啊，我们放置皇后的顺序是从第一列一次到第八列，后面的皇后还都没有放呢，当然不用来比较。 在某一行开始放置皇后private void check(int n) { if (n == max) { // 输出解决方案 System.out.printf(&quot;%-3d&quot; + &quot;: &quot; + Arrays.toString(map) + &quot;\n&quot;, ++count); return; } for (int i = 0; i &lt; map.length; i++) { map[n] = i; if (isValid(n)) { check(n + 1); } } } 代码说明： 我只知道System.out.println，那个printf是什么鬼？ 没学过c吗？printf是Java中用于格式化输出的语句，%-3d的意思就是三位数的整数，左对齐。 后面的for循环是？？？ 如果不加上for循环的话我们啥都得不到，而且肯定是前面几个皇后的列值都很小的。比如说没有for循环的时候我们使用check(0)就是放置第一个皇后，第一个皇后置为i(一开始也就是0，因为没有for循环)，然后看在i处放置合不合理。如果合理就开始放置下面一个皇后，但是倘若是不合理呢？？不合理是不是直接就没了，程序也不会尝试其他的路径了。 如果加上这个for循环。合理自然很好，一路往下走。假如遇到了不合理的。（就算是合理的也会往后的）那for循环就会执行给我们尝试后面的列是否可行。如果for循环结束了都是不可行的。那么这一层的递归就结束了。就会返回上一层的递归。（就算这个合理了也是会返回上一层的递归的），在上一层寻找其他的放置皇后合理的地方。就这样一直回溯就可以找到八皇后的所有的解了。递归是真的神奇~~比如之前一直都不理解的归并排序。 测试代码public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;Slove N Queue Problem: &quot;); int num = scanner.nextInt(); Queue8 queue8 = new Queue8(num); System.out.println(&quot;=====THE SOLUTION OF &quot; + num + &quot;QUEUE PROBLEM=====&quot;); long start_time = System.currentTimeMillis(); queue8.check(0); long end_time = System.currentTimeMillis(); System.out.println(); System.out.println(&quot;=====================SUMMARY=====================&quot;); System.out.println(&quot;THE NUMBERS OF &quot; + num + &quot;QUEUE SOLUTIONS IS &quot; + count); System.out.println(&quot;THE NUMBERS OF JUDGES IS &quot; + count2); long time = end_time - start_time; System.out.println(&quot;THE TIME USED IS &quot; + time + &quot;MS&quot;); } 8皇后 =====================SUMMARY===================== THE NUMBERS OF 8QUEUE SOLUTIONS IS 92 THE NUMBERS OF JUDGES IS 15720 THE TIME USED IS 1MS这里的解决方案没有输出，因为太长了，顶不住啊。由此可见是92种，看来天才高斯也有错误的时候啊~~嘤嘤嘤 12皇后 =====================SUMMARY===================== THE NUMBERS OF 12QUEUE SOLUTIONS IS 14200 THE NUMBERS OF JUDGES IS 10103868 THE TIME USED IS 154MS20皇后 ..... 等了好长的时间（20秒）都没有输出，这个判断函数执行的次数我感觉肯定有上百亿次。。。估计我再不退出就可能 会发生栈溢出了。。。还是不等这个输出结果了吧。上面的两个问题都是我亲手完成和研究的问题，不过递归和回溯算法的题目不止如此，下面看几个网上看到的几个题目。 括号排列基本介绍 给出n对括号，求括号排列的所有可能性。 思路分析对于回溯法来说，必须齐备的三要素： 1、选择。在这个例子中，解就是一个合法的括号组合形式，而选择无非是放入左括号，还是放入右括号； 2、条件。在这个例子中，选择是放入左括号，还是放入右括号，是有条件约束的，不是随便放的。而这个约束就是括号的数量。只有剩下的右括号比左括号多，才能放右括号。只有左括号数量大于0才能放入左括号。这里if的顺序会影响输出的顺序，但是不影响最终解； 3、结束。这里的结束条件很显然就是，左右括号都放完了。 回溯法中，参数的设计是一大难点，也是很重要的地方。而递归参数的设计要注意的四个点： 1、用了一个空字符串来作为临时变量存储不完整解； 2、用了一个ArrayList results来存放符合要求的解。在后面可以看到，不一定要这样做，也可以直接打印结果； 3、把leftnum和rightnum传入给递归函数，这样可以用于判断结束条件； 代码实现import java.util.ArrayList; public class BackTracking { public static void main(String[] args) { int n = 3; int leftnum = n, rightnum = n;// 左括号和右括号都各有n个 ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();// 用于存放解空间 parentheses(&quot;&quot;, results, leftnum, rightnum); for (String s : results) System.out.println(s); } public static void parentheses(String sublist, ArrayList&lt;String&gt; results, int leftnum, int rightnum){ if (leftnum == 0 &amp;&amp; rightnum == 0)// 结束 results.add(sublist); if (rightnum &gt; leftnum)// 选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist + &quot;)&quot;, results, leftnum, rightnum - 1); if (leftnum &gt; 0) parentheses(sublist + &quot;(&quot;, results, leftnum - 1, rightnum); } } 代码说明： parentheses函数的参数的说明 @param sublist 尚未完成的括号串 @param results 存放已经完成的括号串的字符串 @param leftnum 左括号的数量 @param rightnum 右括号的数量 回溯算法如何实现的？ 其实这个算法我倒是感觉没有什么回溯的味道，就是单纯的递归而已。当剩下的左括号和右括号的数量都为0的时候，就是一条递归终止，然后将结果放入集合中。 当剩下的右括号的数量比较多的时候（放入的左括号的数量大于放入的右括号的数量）此时就放入右括号。（如何剩下的右括号的数量小于等于左括号的数量放入右括号是非法的） 当还有剩下的左括号，就放入左括号。 这或许有点不好理解，下面的两个条件其实是在同步进行的。比如说 比如要放四个括号，遇到了这样的字符串 (()( 经过第二个条件的判断产生的递归的分支是 (()() 经过第三个条件的判断产生的递归的分支是 (()((通过了上面的说明就可以理解，不存在少了哪一种情形。每一次的递归都是一种结果。不过，这个算法里面是真的没有回溯这个部分，只是递归而已。 不过作者偏说这个有回溯的部分。 4、这个例子不明显。但是事实上也符合这个条件。可以仔细观察代码，可以发现由于使用了两个if，所以当一次递归退出后，例如从第一个if退出，第二个递归直接递归的是leftnum-1和rightnum，这其实是已经恢复状态了（如果没有恢复状态，那就是leftnum, rightnum-1）。因此不需要人为让他恢复状态。但是恢复状态这点是很重要的，因为回溯法，顾名思义要回溯，不恢复状态，怎么回溯呢。 if(rightnum&gt;leftnum)//选择和条件。对于不同的if顺序，输出的结果顺序是不一样的，但是构成一样的解空间 parentheses(sublist+&quot;)&quot;, results, leftnum, rightnum-1); if(leftnum&gt;0) parentheses(sublist+&quot;(&quot;, results, leftnum-1, rightnum); 把这个称为是回溯，确实是有点儿牵强。每一个递归都是这样使用的不是吗？因为每一层递归不在一个栈空间，在同一个栈空间的数据当然是相同的，自然不用人为恢复状态。 数字之和基本介绍 给出一个不重复大于0数字的数组和一个目标，求数组中数的组合的和得到该目标（数字不同组合顺序当做一个解）。 这个和leetcode上的第一题两数之和是有点儿像的，不过这个题目似乎是没有规定这些数的个数是2，那么难度就不是一倍两倍的往上涨了。两数之和可以使用排序双指针轻松解决，不过这个题目使用排序双指针似乎有点儿困难。 思路分析代码实现 public class BackTracking { public static void main(String[] args){ int[] num=new int[]{2,3,7,6，4,9,1}; int target=9; find(num, target, &quot;&quot;); } public static void find(int[] num, int target, String temp){ if(issolution(temp,target)){ System.out.println(temp); return; } for(int i=0;i&lt;num.length;i++){ if(num[i]!=-1){//如果取过这个数字了，就置为-1 int k=num[i]; num[i]=-1; find(num, target, temp+k); num[i]=k; // 恢复取出的数据的值。 } } } public static boolean issolution(String temp, int target){ boolean result=false; int count=0; for(int i=0;i&lt;temp.length();i++){ count=count+Integer.valueOf(temp.charAt(i)+&quot;&quot;); } if(count==target) result=true; return result; } } 代码说明： for循环里面？ 其实这一整块的代码只有for循环的里面是需要说明的。首先先记录一下放入组合中的那个数据，然后将之置为0.然后再次递归，这样在那个递归的find里面数组的num[i]就为-1了。在后面将i再次恢复到-1从而不影响其他的递归空间。下面的那个issolution函数也非常的容易理解。 代码存在的问题首先这个代码不是我写的，但是我再研究了多道递归的题目的时候还是看出了一个代码其实还是有不少的问题的。 首先我们看一下这个问题的输出如何： 234 27 261 243 216 324 36 342 72 621 63 612 423 432 9 126 162不得不说这个结果的输出就是非常乱的，首先没有任何的分隔符告诉我是那些数的组合，其次，全是重复！！！这个算法其实就是暴力破解法，效率是特别的低的。可以改进的空间非常大！ 首先输出得改善，第二得去重复，第三要考虑到效率问题。针对这三个点，我重写了这个代码。 重写代码public class BackTracking2 { public static void main(String[] args) { int[] num = new int[] { 2, 3, 7, 6, 4, 9, 1}; Arrays.sort(num); int target = 9; // find(num, 0, target, &quot;&quot;); find(num, target); } public static void find(int[] num, int loc, int target, String temp) { int result = issolution(temp, target); if (result == 0) { System.out.println(temp); return; } if (result &gt; 0) { // 和都已经大于target了， 再增加已经没有任何的意义了 return; } for (int i = loc; i &lt; num.length; i++) { if (num[i] &lt;= target) {// 如果取过这个数字了，就置为-1 find(num, i + 1, target, (temp + num[i]) + &quot; &quot;); } else { return; } } } // 可以重载一下，是调用更加简洁 public static void find(int[] num, int target){ find(num, 0, target, &quot;&quot;); } public static int issolution(String temp, int target) { int count = 0; for (int i = 0; i &lt; temp.length() / 2; i++) { count = count + Integer.valueOf(temp.charAt(2 * i) + &quot;&quot;); } if (count &gt; target) return 1; if (count &lt; target) return -1; return 0; } } 输出结果： 1 2 62 3 42 73 69 可见这个输出结果就是很舒服的 代码说明： 关于输出 输出添加了空格主要就是修改了上面的23,31,32这几行，这个修改起来相对简单容易理解。 关于重复 其实重复这个问题也蛮好解决的，只要好马不吃回头草就行了。你想想看比如2，3，7，6假如我挑选的是已经把所有的包含2的都挑选完了，那么在我挑选3的时候，为何还要继续挑选前面的2呢？我们只需要给函数加上一个参数loc，告诉他从什么位置开始挑选就可以完美地解决这个问题了。 关于效率 原先的真的是暴力算法，一点效率都没有。首先是作为自以为完美的将num[i]置为-1，然后再还原的操作，虽然说的确是很秀但是真的没有必要。还有issoluation函数的返回值，完美可以返回大于小于和等于，然后利用大于可以直接结束递归。还有就是将num数组进行排序，虽然说不排序也可以做，但是排序之后的效率将变得高的多，而且还可以在函数中利用num[i] &gt; target就直接结束这个函数（num数组是递增的），可以说是提高了效率。 不过说修改之后的函数就没有问题了，这也是不可能的，我认为还是可以继续改进的，不过做到这一块已经可以说是基本上差不多了。 字符串排列基本介绍 给一个字符串，给出他的所有排列 什么叫字符串的所有的排列呢？就比如说给定的字符串是abc，他的所有的排列就是 abc acb bac bca cab cba总共有 A33 = 3! = 3 × 2 × 1= 6 种 思路分析这个其实也是一种放东西类型的题目，和上面的那一个题目倒是有一点儿类似，不对，应该说是有点儿儿完全一样，就是上面的那一个题目改进前的那个算法。毕竟这玩意是需要重复的嘛。 代码实现public class StringArrange { public static void main(String[] args) { String s = &quot;abc&quot;; Arrange(s, &quot;&quot;); } public static void Arrange(String s, String temp) {// 参数设计地尽量地简洁 if (s.length() == 0) { System.out.println(temp); return; } for (int i = 0; i &lt; s.length(); i++) { String news = s.substring(0, i) + s.substring(i + 1, s.length());// 去掉String中的某个字母 Arrange(news, temp + s.charAt(i)); } } } // 既然你要说参数设计要简洁的话为啥不给这个函数一个重载呢？ public static void Arrange(String s){ Arrange(s, &quot;&quot;); } // 然后直接这样子调用不就完事了 String s = &quot;abc&quot;; Arrange(s); 输出结果： abcacbbacbcacabcba 代码说明： 这个其实没有什么要说明的地方，不过要注意的一点是java当中substring的第二个参数是结束的位置（不包括），C++中的substr()的第二个参数是子串的长度。关于这一点，我也算是佛了！ 还有一个与之比较类似的题目。 新字符串给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 这个题目可以直接用前面的回溯算法，而且真的特别的简单，至于效率，应该不是很快吧。不过真的是特别容易理解。 代码实现public class NewStr { public static void main(String[] args) { String a = &quot;ak47A&quot;; // newStr(a, 0, &quot;&quot;); newStr(a); } public static void newStr(String a, int i, String temp) { if (i == a.length()) { System.out.println(temp); return; } if (Character.isAlphabetic(a.charAt(i))) { String temp2 = new String(temp); temp += a.charAt(i); newStr(a, i+1, temp); if (Character.isLowerCase(a.charAt(i))) { temp2 += Character.toUpperCase(a.charAt(i)); }else { temp2 += Character.toLowerCase(a.charAt(i)); } newStr(a, i+1, temp2); }else { temp += a.charAt(i); newStr(a, i+1, temp); } } public static void newStr(String a){ newStr(a, 0, &quot;&quot;); } } 输出结果： ak47Aak47aaK47AaK47aAk47AAk47aAK47AAK47a 代码说明： 这个代码实在是太容易理解了，不用说什么了。里面用到了几个库函数，看函数的名字大概就可以知道函数的意思了。 我看到博主使用的代码有点沙雕，不过思路是完全一样子的（我可没有看这个函数起名都花里胡哨的代码，dfs。。。to784To？？？我佛了）。这里就直接说我上面的那个算法就完事了，至于博主的算法直接贴出来就完事了。 public void dfs(String pre, String S, List&lt;String&gt; res, int index) { if (index == S.length()) res.add(pre); else { char ch = S.charAt(index); if (!Character.isLetter(ch)) dfs(pre + ch, S, res, index + 1); else { // 小写字符分支 ch = Character.toLowerCase(ch); dfs(pre + ch, S, res, index + 1); // 大写字符分支 ch = Character.toUpperCase(ch); dfs(pre + ch, S, res, index + 1); } } } public List&lt;String&gt; letterCasePermutation(String S) { List&lt;String&gt; res = new LinkedList&lt;&gt;(); dfs(&quot;&quot;, S, res, 0); return res; } // 测试 public static void main(String[] args) { String S = &quot;a1b&quot;; To784To to784To = new To784To(); System.out.println(to784To.letterCasePermutation(S)); } 子集问题 给定一个集合，求他的所有的子集 就不上什么思路分析了，直接代码 代码实现public class Subsets { public static List&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public static List&lt;ArrayList&lt;Integer&gt;&gt; subsets(int[] arr) { ArrayList&lt;Integer&gt; curr = new ArrayList&lt;Integer&gt;(); subsets(arr, curr, 0); // System.out.println(res); return res; } public static void subsets(int[] arr, ArrayList&lt;Integer&gt; curr, int start) { res.add(new ArrayList&lt;Integer&gt;(curr)); // 如果不这样放，最后就都是空 if (start == arr.length) { return; } for (int i = start; i &lt; arr.length; i++) { curr.add(arr[i]); subsets(arr, curr, i + 1); curr.remove(curr.size() - 1); } } public static void main(String[] args) { int[] arr = { 1, 2, 3 }; subsets(arr); } } 要注意一点的是，放入res的时候，如果不new的话，放入的就是引用，（Java万物都是引用）最后就都会变成空的集合。这一点上C++和Java的区别要尤其的注意。这两门语言名义上说是很像，但是这点差的真的是特别的大。我也是佛了。 总结递归与回溯确实有点儿难以掌握，刚才去leetcode上面看了一题，还是有点儿懵，虽然有了思路 ，但是并不能完全的写下去，唉，还是要多加的训练才能基本掌握这门高深的“通用解题方法”啊。 参考了一点的文章: 回溯算法超通俗易懂详尽分析和例题]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的广度优先和深度优先遍历]]></title>
    <url>%2F2019%2F07%2F23%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的广度优先和深度优先遍历其实之前我们已经学过了二叉树的先序遍历，中序遍历和后序遍历，这些遍历的方式都是几行代码利用递归的方式来实现的。其实这些遍历方式是不怎么符合我们的逻辑的（至少是不符合我的逻辑），不过他们确实的使用简单的算法就可以遍历二叉树的好办法。这不是说这些遍历方式不好（二叉排序树还就是需要中序遍历呢），只是我们还可以学习其他的遍历二叉树的方式。比如下面的广度优先遍历和深度优先遍历。 广度优先 广度优先的基本介绍广度优先遍历（ Breadth-First Search）一般缩写为BFS。 其过程检验来说是对每一层节点依次访问，访问完一层进入下一层，而且每个节点只能访问一次。对于上面的例子来说，广度优先遍历的 结果是：A,B,C,D,E,F,G,H,I(假设每层节点从左到右访问)。 广度优先的算法实现 先往队列中插入左节点，再插右节点，这样出队就是先左节点后右节点了。 广度优先遍历树，需要用到队列（Queue）来存储节点对象,队列的特点就是先进先出。例如，上面这颗树的访问如下： 首先将A节点插入队列中，队列中有元素（A）; 将A节点弹出，同时将A节点的左、右节点依次插入队列，B在队首，C在队尾，（B，C），此时得到A节点； 继续弹出队首元素，即弹出B，并将B的左、右节点插入队列，C在队首，E在队尾（C,D，E），此时得到B节点； 继续弹出，即弹出C，并将C节点的左、中、右节点依次插入队列，（D,E,F,G,H），此时得到C节点； 将D弹出，此时D没有子节点，队列中元素为（E,F,G,H），得到D节点； 首先构战树节点struct TreeNode { int data; TreeNode* left; TreeNode* right; TreeNode(int val):data(val){ this-&gt;left = nullptr; this-&gt;right = nullptr; } }; 这里就不写二叉树这个类了，就写一个树节点就完事了。 删除树void deleteTree(TreeNode* root){ if (root == nullptr){ return; } if (root-&gt;left != nullptr){ deleteTree(root-&gt;left); } if (root-&gt;right != nullptr){ deleteTree(root-&gt;right); } delete root; } 广度遍历算法vector&lt;TreeNode*&gt; BFSsearch(TreeNode* root) { // 首先将A节点插入队列中，队列中有元素（A） // 队列是先进先出的一种数据结构 queue&lt;TreeNode*&gt; node_queue; // 按广度遍历的算法来保存节点顺序 vector&lt;TreeNode*&gt; result; node_queue.push(root); TreeNode* pop_node; while (!node_queue.empty()) { // 将第一个节点取出，将节点的左右节点放入队列 pop_node = node_queue.front(); result.emplace_back(pop_node); node_queue.pop(); if (pop_node-&gt;left != nullptr) { node_queue.push(pop_node-&gt;left); } if (pop_node-&gt;right != nullptr) { node_queue.push(pop_node-&gt;right); } } return result; } 主方法中的测试代码二叉树的结构： 1 2 3 4 5 6 7 8 int main(int argc, char const* argv[]) { TreeNode* root = new TreeNode(1); root-&gt;left = new TreeNode(2); root-&gt;right = new TreeNode(3); root-&gt;left-&gt;left = new TreeNode(4); root-&gt;left-&gt;right = new TreeNode(5); root-&gt;right-&gt;left = new TreeNode(6); root-&gt;right-&gt;right = new TreeNode(7); root-&gt;right-&gt;right-&gt;right = new TreeNode(8); vector&lt;TreeNode*&gt; bfs = BFSsearch(root); for (auto node : bfs) { cout &lt;&lt; node-&gt;data &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; deleteTree(root); system(&quot;pause&quot;); return 0; } 输出的结果： 1 2 3 4 5 6 7 8 深度优先 深度优先基本介绍深度优先是Depth-First Search（DFS）。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。对于上面的例子来说深度优先遍历的结果就是：A,B,D,E,I,C,F,G,H.(假设先走子节点的的左侧)。 深度优先的算法思路深度优先遍历各个节点，需要使用到栈（Stack）这种数据结构。stack的特点是是先进后出。 先往栈中压入右节点，再压左节点，这样出栈就是先左节点后右节点了。 首先将A节点压入栈中，stack（A）; 将A节点弹出，同时将A的子节点C，B压入栈中，此时B在栈的顶部，stack(B,C)； 将B节点弹出，同时将B的子节点E，D压入栈中，此时D在栈的顶部，stack（D,E,C）； 将D节点弹出，没有子节点压入,此时E在栈的顶部，stack（E，C）； 将E节点弹出，同时将E的子节点I压入，stack（I,C）； …依次往下，最终遍历完成。 可以看到这个深度优先的算法和广度优先的算法是十分的类似的，一个使用的是队列，一个使用的栈。队列的特点是先进先出，队列的特点是先进后出。 深度优先算法代码实现vector&lt;TreeNode*&gt; DFSsearch(TreeNode* root) { vector&lt;TreeNode*&gt; result; stack&lt;TreeNode*&gt; node_stack; TreeNode* pop_node; node_stack.push(root); while (!node_stack.empty()) { pop_node = node_stack.top(); node_stack.pop(); result.push_back(pop_node); if (pop_node-&gt;right) { node_stack.push(pop_node-&gt;right); } if (pop_node-&gt;left) { node_stack.push(pop_node-&gt;left); } } return result; } 测试代码和上面的基本都是一样的： 二叉树的结构： 1 2 3 4 5 6 7 8 *输出结果: * 1 2 4 5 3 6 7 8 总结二叉树的深度优先及广度优先遍历算法算是二叉树中比较重要的两个算法了。但是深度优先和广度优先这个并不是二叉树中的概念，其实还有其他很多的数据结构及算法都有深度优先和广度优先算法。比如说图的遍历，也有广度优先和深度优先。总之，一点一点去学吧，么得多大的问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法简介]]></title>
    <url>%2F2019%2F07%2F23%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[贪心算法简介 ​ 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。 贪心算法的基本介绍贪心算法的一般流程Greedy(C) //C是问题的输入集合即候选集合 { S={ }; //初始解集合为空集 while (not solution(S)) //集合S没有构成问题的一个解 { x=select(C); //在候选集合C中做贪心选择 if feasible(S, x) //判断集合S中加入x后的解是否可行 S=S+{x}; C=C-{x}; } return S;贪心算法其实没有一个固定的流程，这点和KMP算法不一样，KMP算法是解决那种特定的问题，但是这个贪心算法是解决那一种问题，适合做出贪心选择的问题： 贪心选择的性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 对于那些不满足贪心选择的问题，我们不可以使用贪心算法来解决。 贪心算法存在的问题 不能保证求得的最后解是最佳的； 不能用来求最大或最小解问题； 只能求满足某些约束条件的可行解的范围。 贪心算法的例题找零钱问题假如老板要找给我99分钱，他有上面的面值分别为25，10，5，1的硬币数，为了找给我最少的硬币数，那么他是不是该这样找呢，先看看该找多少个25分的，诶99／25＝3，好像是3个，要是4个的话，我们还得再给老板一个1分的，我不干，那么老板只能给我3个25分的拉，由于还少给我24，所以还得给我2个10分的和4个1分。 思路分析这个题目其实非常的简单，估计不学这个贪心算法都是非常容易搞定的，我们想要最少的硬币数，这里存不存在贪心选择呢？其实是很容易看出来的，我们的贪心选择就是尽量找大面额的硬币，能有多少找多少，毕竟有1元的硬币无需担心有早不开这种情况。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; giveMoney(vector&lt;int&gt; m, int target) { int size = m.size(); vector&lt;int&gt; num(size, 0); for (size_t i = 0; i &lt; size; i++) { num[i] = target / m[i]; target = target % m[i]; } return num; } int main(int argc, char const *argv[]) { vector&lt;int&gt; num = {25, 10, 5, 1}; int target = 99; vector&lt;int&gt; result = giveMoney(num, target); std::cout &lt;&lt; target &lt;&lt; &quot;的找钱方案为：&quot; &lt;&lt; std::endl; for (size_t i = 0; i &lt; result.size(); i++) { std::cout &lt;&lt; result[i] &lt;&lt; &quot;枚面值为&quot; &lt;&lt; num[i] &lt;&lt; &quot;的硬币&quot; &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 运行结果99的找钱方案为： 3枚面值为25的硬币 2枚面值为10的硬币 0枚面值为 5的硬币 4枚面值为 1的硬币这个是贪心算法的一个简单的例子，也无需做什么代码说明啦。 活动安排问题设有n个活动的集合e={1，2，…，n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si&lt; fi。如果选择了活动i，则它在半开时间区间[si，fi]内占用资源。若区间[si，fi]与区间[sj，fj]不相交，则称活动i与活动j是相容的。也就是说，当si≥fi或sj≥fj时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。 思路分析其实我有点儿不想认为这个是贪心算法，但是你非要说这个是，我也没办法啦~ 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::vector; vector&lt;int&gt; arrangeActivity(vector&lt;int&gt; start, vector&lt;int&gt; end) { int total = start.size(); int endFlag = end[0]; vector&lt;int&gt; result; result.push_back(0); for (size_t i = 0; i &lt; total; i++) { if (start[i] &gt; endFlag) { result.push_back(i); endFlag = end[i]; } } return result; } int main(int argc, char const *argv[]) { vector&lt;int&gt; start = {1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12}; // end数组是有序的 vector&lt;int&gt; end = {4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}; vector&lt;int&gt; result = arrangeActivity(start, end); for (size_t i = 0; i &lt; result.size(); i++) { int index = result[i]; std::cout &lt;&lt; &quot;开始时间：&quot; &lt;&lt; start[index] &lt;&lt; &quot; 结束时间：&quot; &lt;&lt; end[index] &lt;&lt; std::endl; } system(&quot;pause&quot;); return 0; } 我简直不忍心说这个是。。。贪心算法啦~ 背包问题这个问题之前在动态规划的时候说过好像，不过那篇文章中好像没有谈及这个问题，不过我已经写完了好几道背包问题的例题了，下次可以再次写一个动态规划的文章。这里就使用动态规划里面的那个背包问题的题目吧。 0/1背包问题：给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。 那么问题来了，这个题目可以使用贪心算法来做吗？也就是说这个题目存在贪心选择吗？ 贪心选择1 ： 和找零钱一样，选择最贵的往里面放。 但是这个得到的是最优解吗？很容易得到反例，放入了贵的东西之后，剩余的空间可以会得不到利用。 贪心选择2： 选择轻的往背包里面放。 和上面的选择一样，这个也不能确保是最优解。 由此可见，使用贪心算法无法解决这个问题，还是安心的去选择动态规划吧。。。蛤蛤蛤 均分纸牌有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④ 再从③区3张放到②然后从②去1张放到①。 思路分析设a[i]为第I堆纸牌的张数（0&lt;=I&lt;=n），v为均分后每堆纸牌的张数，s为最小移动次数。我们用贪心算法，按照从左到右的顺序移动纸牌。如第I堆的纸牌数不等于平均值，则移动一次（即s加1），分两种情况移动： 若a[i]&gt;v，则将a[i]-v张从第I堆移动到第I+1堆； 若a[i]&lt; v，则将v-a[i]张从第I+1堆移动到第I堆。为了设计的方便，我们把这两种情况统一看作是将a[i]-v从第I堆移动到第I+1堆，移动后有a[i]=v; a[I+1]=a[I+1]+a[i]-v. 在从第I+1堆取出纸牌补充第I堆的过程中可能回出现第I+1堆的纸牌小于零的情况。如n=3，三堆指派数为1 2 27 ，这时v=10，为了使第一堆为10，要从第二堆移9张到第一堆，而第二堆只有2张可以移，这是不是意味着刚才使用贪心法是错误的呢？ 我们继续按规则分析移牌过程，从第二堆移出9张到第一堆后，第一堆有10张，第二堆剩下-7张，在从第三堆移动17张到第二堆，刚好三堆纸牌都是10，最后结果是对的，我们在移动过程中，只是改变了移动的顺序，而移动次数不变，因此此题使用贪心法可行的。 代码实现#include &lt;iostream&gt; #include &lt;vector&gt; using std::cout; using std::endl; using std::vector; int moveCards(vector&lt;int&gt;&amp; cards) { int sum = 0; int count = 0; for (size_t i = 0; i &lt; cards.size(); i++) { sum += cards[i]; } int average = sum / cards.size(); for (size_t i = 0; i &lt; cards.size(); i++) { if (cards[i] != average) { cards[i] += average - cards[i]; cards[i + 1] -= average - cards[i]; count++; } } return count; } int main(int argc, char const* argv[]) { vector&lt;int&gt; cards = {2, 10, 18}; int count = moveCards(cards); cout &lt;&lt; &quot;移动次数：&quot; &lt;&lt; count &lt;&lt; endl; for (size_t i = 0; i &lt; cards.size(); i++) { cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;堆牌：&quot; &lt;&lt; cards[i] &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 代码说明： 乍一看以为这个题目是很难的题目，但是定睛一看，这不是一个沙雕题目吗？特别是有个这个贪心算法的思路之后，这个题目就变得尤为的弱智。 不过，关于这个题目，以及贪心算法还有特别多要注意的地方 一是问题是否适合用贪心法求解。我们看一个找币的例子，如果一个货币系统有三种币值，面值分别为一角、五分和一分，求最小找币数时，可以用贪心法求解；如果将这三种币值改为一角一分、五分和一分，就不能使用贪心法求解。用贪心法解题很方便，但它的适用范围很小，判断一个问题是否适合用贪心法求解，目前还没有一个通用的方法，在信息学竞赛中，需要凭个人的经验来判断。 二是确定了可以用贪心算法之后，如何选择一个贪心标准，才能保证得到问题的最优解。在选择贪心标准时，我们要对所选的贪心标准进行验证才能使用，不要被表面上看似正确的贪心标准所迷惑，如下面的例子。 这个题目找到了合理的贪心选择：如果不等于平均值的话就利用右面的牌堆变成平均值，即使出现了负数问题也不是很大。这个选择很好像，不过要说明这个就可以得到最优解，还是有一点难度的。 加入说这个移动不是限制在相邻的牌堆之间了，这个选择就肯定是一个错误的选择了。所以说贪心算法难，但是代码不是特别的难写，主要就贪心选择有没有选择正确。 最大整数设有n个正整数，将它们连接成一排，组成一个最大的多位整数。例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 思路分析这个题目我们想要使用贪心算法来做，那么我们就要选择一个正确的贪心选择，那么关于这个题目怎么做贪心选择呢？把大的数放在前面？ 78 123 -&gt; 12378明显不对，把小的数放在前面？这同样都是不对的。对于两个整数 a和b我们要是ab &gt; ba(这里不是乘法)，这样做其实有一个很简单的实现方式，就是利用字符串。和求整数的最大的位数相似(将整数转为字符串然后求得字符串的长度就是整数的长度)我们可以将整数a和b转为字符串然后比较a+b和b+a的大小。 代码实现/** * 设有n个正整数，将它们连接成一排，组成一个最大的多位整数。 * 例如：n=3时，3个整数13，312，343，连成的最大整数为34331213。 * 又如：n=4时，4个整数7，13，4，246，连成的最大整数为7424613。 */ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using std::string; using std::to_string; using std::vector; #include &lt;sstream&gt; using std::stringstream; // 也可以使用stringstream来将nums转为string // 将int转为string可以使用stoi， long转为string可以使用stol 转为char* // 就以atoi和atol吧 string maxNum(vector&lt;int&gt;&amp; nums) { // string result = to_string(nums[0]); string result = &quot;&quot;; stringstream ss; ss &lt;&lt; nums[0]; ss &gt;&gt; result; for (size_t i = 1; i &lt; nums.size(); i++) { string plusNum = to_string(nums[i]); if (result + plusNum &gt; plusNum + result) { result += plusNum; } else { result = plusNum + result; } } return result; } int main(int argc, char const* argv[]) { vector&lt;int&gt; nums = {78, 123, 93}; for (auto val : nums) { std::cout &lt;&lt; val &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &quot;可以组成的最大的整数为：&quot;; std::cout &lt;&lt; maxNum(nums) &lt;&lt; std::endl; system(&quot;pause&quot;); return 0; } 也是非常简单的代码不用做什么说明了。 总结贪心算法所作的选择可以依赖于以往所作过的选择，但决不依赖于将来的选择，也不依赖于子问题的解，(动态规划依赖于子问题的解) 因此贪心算法与其他算法相比具有一定的速度优势。如果一个问题可以同时用几种方法解决，贪心算法应该是最好的选择之一。但是不是所有的问题都可以使用贪心算法来解决的，要注意贪心选择是否是正确的，不然太贪心了之后搞得自己人莫得了。贪心算法学了感觉还是有点儿懵，这个算法拓展性真的是太强了，完全就只是一个思路，怎么搞都依赖于你自己的想法。嘤嘤嘤~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-1>0x7fffffff???(黑人问号脸)]]></title>
    <url>%2F2019%2F07%2F22%2F-1%E5%A4%A7%E4%BA%8E0x7fffffff%2F</url>
    <content type="text"><![CDATA[-1 &gt; 0x7fffffff ??? 今天在研究KMP算法的时候，KMP算法研究的一窍不通，完全看不懂这个神仙算法的思路。那想着先照葫芦画瓢，先不管三七二十一，知道KMP要干啥，至于为啥要那样做咋先不管，咋先把这个算法写一遍，然后再去理解，但是这个就出问题了，出了一个莫名其妙的bug，这是怎么找都找不到啊，找的我头大啊！！！ 我先确定了出问题的函数，这个很简单。 然后我又确定了出问题的部分是什么，这不确定不得了，发现是while循环出错了，while循环只是循环了一次就退出了。。。 代码如下： int KMPsearch(string str, string sub, int* next) { int i = 0, j = 0; while (i &lt; str.length() &amp;&amp; j &lt; sub.length()) { if (j == -1 || str[i] == sub[j]) { i++; j++; } else { j = next[j]; } } if (j == subLen) { return i - j; } else { return -1; } } 这个代码看着是十分的没有问题，但是我就是定位到这个函数有问题了而且是while循环一次就退出while循环一次之后i是1，j是-1，str.length()和sub.length()肯定是一直都不会变的啊？那么究竟是1&gt;=26还是-1&gt;=6? 这搞得我非常的懵逼。。。我的编译器出问题了，开始跟我瞎搞了？ // 原因是这样子的 str.length()返回类型是size_t是无符号类型的 // j 是int是有符号类型的，一般情况下还真的没问题，但是问题就在与这里的j可以为-1 // 有符号值与无符号的值进行比较的时候，有符号值会转换成无符号的值 // -1 是 0xffffffff 变成有符号的数还是 0xffffffff 可怕。。。这个比0x7fffffff(MAX_INT)还大！！数据在电脑中的存储和计算都是以补码的形式. -1的原码是 1000 0000 0000 0000 0000 0000 0000 0001 -1的反码是 1111 1111 1111 1111 1111 1111 1111 1110 -1的补码是 1111 1111 1111 1111 1111 1111 1111 1111反码是除了符号位其余的位取反 正整数的补码是就是原码 负整数的补码是反码加1 size_t i = 0x7fffffff; int j = -1; if (j &gt; i){ cout &lt;&lt; &quot;-1 &gt; 0x7fffffff&quot;&lt;&lt;endl; } 当一个有符号数和无符号数进行比较的时候，就不会把-1这个符号位1当成符号位. 也就是说-1 == (unsigned int)0xffffffff &gt; (unsigned int)0x7fffffff 0x7fffffff是啥玩意？是MAX_INT（定义在limits.h中) 0x80000000是MIN_INT，咦这个不是-0的原码嘛？ 0x80000000 -1 = 0x7fffffff 取反就是 0x00000000，这不是0嘛？蛤蛤蛤这也就是为嘛最大的负数的绝对值要比最大的正数大上1. -0的原码是0x80000000 反码是0xfffffff 补码是0x00000000，咦为啥呢？ 因为溢出了1 0000 0000，这个只是取后八位，所以说-0和0的补码都是0。 #include &lt;stdio.h&gt; #include &lt;limits.h&gt; int main(){ if (INT_MIN == 0x80000000 &amp;&amp; INT_MAX == 0x7fffffff){ printf(&quot;INT_MIN: 0x80000000\nINT_MAX: 0x7fffffff\n&quot;); }else{ printf(&quot;No&quot;); } return 0; } 有符号的数和无符号的数时要注意：有符号的数会变成无符号的数。 这不禁又让我想起来我之前遇到的一个大体相同bug for (size_t i = 10; i&gt;=value; i--){ // ... } 这个value是-1，导致这个循环死的了，当时找bug找的我也是头发昏，找到了的原因也是如此 无符号与有符号的数进行比较！！！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 有符号的数会变成无符号的数！ 我被坑的已经不止这一次了，嘤嘤嘤~，继续看KMP算法去了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法简介]]></title>
    <url>%2F2019%2F07%2F22%2FKMP%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[KMP 算法 KMP算法是关于字符串匹配的一个算法。 比如说有一个字符串是 “acbabcdabdbacdd” 我们要在这个字符串中寻找是否有子串 “acbdacd”，有就返回下标，没有就返回-1 暴力匹配暴力匹配的思路这个题目我们的思路其实是非常明确的。那就是暴力匹配呗。 如果匹配了我们就返回，如果不匹配我们就重新开始匹配下一个字符。 上面的那个题目，匹配到第四个个字符不匹配了，那么我们把子串往后移后一位，用a和c再比较。。。 这个暴力匹配就是一旦遇到了不匹配的字符，就把子串移后一位，如果都到了主串的末尾了还没有匹配成功，那么就说明这个主串中没有子串，返回-1即可。 代码实现的其实也蛮简单的。 暴力匹配代码实现#include &lt;iostream&gt; #include &lt;string&gt; using std::cout; using std::endl; using std::string; /** * 使用暴力算法，就是这么的暴力！！ */ int KMP(string str, string sub) { // 使用i来指向主串，使用j来指向子串 int i = 0, j = 0; // 主串还没有被比较结束 while (i &lt; str.length()) { // 匹配了 继续比较下一位 while (str[i] == sub[j]) { i++; j++; // 匹配成功，在主串中发现了子串 if (j == sub.length()) { return i - j; } } // 匹配失败，将i移动到本次匹配的后一位 i = i - j + 1; // 重置子串， j重新指向子串的开头 j = 0; } return -1; } int main(int argc, char const *argv[]) { string str = &quot;BBC ABCDAB ABCDABCDABDE&quot;; string sub = &quot;ABCDABCDE&quot;; int index = KMP(str, sub); if (index == -1) { cout &lt;&lt; &quot;Not Found!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Found!\nT/F: &quot; &lt;&lt; (str.substr(index, sub.length()) == sub ? &quot;True&quot; : &quot;False&quot;) &lt;&lt; endl; } system(&quot;pause&quot;); return 0; } 这个暴力匹配的算法，就算是个小学生也能一眼看懂吧，不需要做什么代码说明了，重点戏是后面的KMP算法。 暴力匹配：时间复杂度是O(mn) 其中m是子串的长度，n是主串的长度. KMP 算法关于暴力匹配的思考及KMP的思路暴力匹配的算法每次都是后移一位。比如下面 主串: abcdxxxx 子串: abcde我们发现第五位不匹配，暴力匹配的思路是这样子的，移动到下一位 主串：abcdxxxx 子串： abcde但是这个不是很脑残的行为吗？既然第五位是不匹配的，那么主串和子串的前四位不就都是相等的吗？我们再次观察这个子串的前面的四位都是不相同的字符，那么我们完全没有必要让子串a再次和后面bcd比了。我们完全可以直接跳到这一步 主串: abcdxxxx 子串: abcdei直接往前跳了四步，极大的节省了时间。 但是问题就在，你是怎么知道前面的四位都是不相等的? 主串: ababxxxx 子串: ababe这次也是第五位不匹配的，这次我们还是跳四位？？？ 这时有人要抢答了：同学，这里有两个相同的字符，这傻子都可以看出来是跳两位啊！！ 那么这个也是跳两位？ 主串: abbaxxxx 子串: abbae很明显这个是跳三位。我们看起来非常的容易，一看就知道跳几位，但是如何用逻辑描述这个到底应该跳几位了？ 我们到第5位不匹配要跳几位，其实和第五位没有关系，这完全取决与前面的四位。我们来观察一下： abcd -&gt; 4 = 4-0 abab -&gt; 2 = 4-2 abba -&gt; 3 = 4-1或许也许可能观察不出来什么，不过观察一下他们的前缀和后缀。 比如 impossible 前缀就有im 后缀就有ible 但是他们的前缀和后缀不能是他们的本身 字符串 前缀 后缀 前缀后缀共有字符串的最大长度 abcd a, ab, abc d, cd, bcd 0 abab a, ab, aba b, ab, bab 2 abba a, ab, abb a, ba, bba 1 这样就明白了吧，我们往后移动的多少取决于前缀后缀共有字符串的最大的长度。 我们可以来验证一下 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第一步：（找到第一个匹配的位置） 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD第二步：(C和空格不匹配) ABCDAB的前缀后缀的共有字符串是2，那么应该向后移动6-2=4位 主串: BBC ABCDAB ABCDABCDABDE 子串: ABCDABD发现找到了 我们可以发现KMP的思路其实还是蛮清晰的。就是这个简答，利用匹配失败已经前面匹配成功的字符的前缀后缀共有字符串的最大的长度来尽可能多的往后移动位置，反观暴力破解，每次就只是往后面移动一位d，效率低下。 KMP寻找的时候的时间复杂度是O(n) 构造部分匹配表上面的那个由前几位前缀后缀共有字符串的最大长度构成的表被称为部分匹配表。那么如果用代码去构造这个部分匹配表呢？ 比如如下的字符串，部分匹配表如下(第三行)，但是如何去构造呢 0 1 2 3 4 5 6 ---(序号) a b c d a b d ---(字符串) 0 0 0 0 1 2 0 ---(部分匹配表) 1 1 2 3 4 4 4 ---(到这一位不匹配的时候向后移动的位数)思路 a b c d a b d 1 j i -&gt;0 2 j i -&gt;0 3 j i -&gt;0 4 j i -&gt;1 5 j i -&gt;2 6 j i 这个第六步发现i位和j位不相等，那么i是肯定不能动的，动的肯定是j那么j怎么变？j变成0？？？ 此时j-1的字符肯定是等于i-1处的字符的。此时我们想要知道是否j还有别的值的前一位是等于i-1的然后跳到这个j 这个例子中没有下面再举一个例子 a b c d a b d a b c d a b d ... a b c d a d b a b c d a b d 0 0 0 0 1 2 此时我们发现d和c不匹配，我们想从a b中找到可能和b相等的值 d处的最大前缀后缀共有的最大长度有可能超过2吗？不可能 假如如下的字符串 x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] x y d x y c z z z z x y d x y d j i -&gt; [i-1] == [j-1] 此时又回到了j前面的值和i前面的值再次都相等的情况，再次比较,如果不相等回到 x y d x y c z z z z x y d x y d j i -&gt; x y这个串的前后缀最大已经是0了上面或许讲的有点乱，因为当时我也是有点乱，但是现在我明白了 我们发现当部分匹配表没有1这个值，没有前缀也没有后缀，就给它一个0吧 int* calNext(string sub){ int length = sub.length(); int* next = new int[length]; next[0] = 0; int i=1, j=0; while(i &lt; sub.length){ if (j &gt; 0 &amp;&amp; sub[i] != sub[j]){ j = next[j-1]; } if (sub[i] == sub[j]){ j++; } next[i++] = j; } } 代码说明： 这里面最难以理解的估计就是那一句话，就是j = next[j-1]到底是什么含义 比如 0 1 2 3 4 a b a b c j i 0 0 1 2 0j = next[j-1]之后就是 j =0; j = next[j-1]的含义就是回到上一个时刻 sub[j-1] == sub[i-1]不仅如此，他们前面的值都是相等的！ 这个例子中这样的数不存在 x d x y x d x d j i 这时 j = next[j-1] x d x y x d x d j i 此时j前面的数和d前面的数又都是相等的了，再次进行比较！如果还是不相等 j = next[j-1]这样应该很好理解了吧。 这样我们的next数组也就构造好了，KMP算法也就好实现了 KMP 代码int KMPsearch(string str, string sub, int* next){ int strLength = str.length(); int subLength = sub.length(); int i=0, j=0; while (i &lt; strLength &amp;&amp; j &lt; subLength){ // KMP核心，不匹配向后移动 if (j &gt; 0 &amp;&amp; str[i] != str[j]){ j = next[j-1]; } if (str[i] == sub[j]){ i++; j++; } if (j == 0 &amp;&amp; str[i] != str[j]){ i++; } } // 找到了子串 if (j == subLength){ return i-j; }else { return -1; } } 代码说明： 其实需要说明的就只是KMP的核心那一块代码。我们一直说什么往后移动，其实这也不是往后移动啊？ 其实这只是我们想象中的往后移动，实际上是这样子的 abcdabcde abcde -&gt; 上面的a匹配失败 -&gt; abcdabcde abcde -&gt; 让下面a和上面a进行比较当匹配到第五位的时候，i其实没有变，变的只是j而已我们直接让sub[next[j-1]]和str[i]进行比较 上面那个next[j-1]就是a abacabab abab -&gt; 上面的c匹配失败 -&gt; abacabab abab -&gt; 让下面b和上面c进行比较再次重申一下，i没有变，变的只是j而已。 总结写到了这儿KMP算法基本上就写完了，写完了之后我对KMP算法的理解算是有涨了一个层次，至少能基本理解这个算法该如何用了而不是单纯的被代码。其实网上关于KMP算法的博客特别多，每个人使用的方法都是不一样的，我看了很多人的next[0] = -1，还有构造了其他各种各样的数组，我基本上都没怎么看，我看的不是代码是怎么写的，主要是KMP的思路是如何的，理解了这个思路之后，什么样的实现KMP算法的代码基本上都能看懂了。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划算法简介]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[动态规划算法简介动态规划基本介绍动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 适用情况 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤，如下图所示： 初始状态→│决策1│→│决策2│→…→│决策n│→结束状态 划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。实际应用中可以按以下几个简化的步骤进行设计： 分析最优解的性质，并刻画其结构特征。 递归的定义最优解。 以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 根据计算最优值时得到的信息，构造问题的最优解 算法实现动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素： 问题的阶段 每个阶段的状态 从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 上面的这些内容都是从百度百科中抄来的，虽然是百度百科讲的也不是很烂，我感觉除了不是很形象，其他讲的还是不错的。现在还是直接从leetcode动态规划算法的题目开始吧！ leetcode 动态规划爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶这个题目我之前就已经是做过了的，不过似乎是没有使用到动态规划的算法。 class Solution { public: map&lt;int, int&gt; result; int climbStairs(int n) { if (n == 1 || n == 2) return n; if (result.find(n) != result.end()) return result[n]; int res = climbStairs(n-1)+climbStairs(n-2); result[n] = res; return res; } }; 执行结果：通过 显示详情 执行用时 : 0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 : 8.7 MB, 在所有 C++ 提交中击败了10.62%的用户 由此可见，程序运行的速度是飞快的，但是因为使用了map进行记忆，程序消耗了太大的内存，所以说算法值得优化。这是一个典型的动态规划型的题目，和斐波那契数列有点儿相似，那么如何使用动态规划算法呢？ 其实我上面用的map已经是一种动态规划算法了，就是记住原来算过的结果，极大的提高了效率，不过int， int类型的map如果是使用数组的话，还是更好一些。 class Solution { public static int memo[]; public int climbStairs(int n) { memo = new int[n+1]; return climbStairs(n, memo); } public static int climbStairs(int n, int memo[]){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户 内存消耗 :33 MB, 在所有 Java 提交中击败了73.01%的用户 内存消耗反而变大了，，这个是语言的原因，你懂得~ 改成C++代码 int climbStairs(int n){ int* memo = new int[n+1]{0}; return climbStairs(n, memo); } int climbStairs(int n, int* memo){ if (memo[n] != 0){ return memo[n]; } if (n == 1 || n == 2){ memo[n] = n; } else { memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo); } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.6 MB, 在所有 C++ 提交中击败了19.38%的用户 内存的消耗还是特别多，这。。。只能求助于题解了。可以不使用递归的方式，不过说实话，时间复杂度都是一样的，空间复杂度感觉也没多少改善啊。。。 int climbStairs(int n){ if (n &lt;= 2) return n; int* memo = new int[n+1]{0}; memo[1] = 1; memo[2] = 2; for (int i=3; i&lt;=n; ++i){ memo[i] = memo[i-1] + memo[i-2]; } return memo[n]; } 执行结果：通过 显示详情 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗 :8.4 MB, 在所有 C++ 提交中击败了43.73%的用户 算了，不纠结这题了，这只是一个简单题罢了，请看下一题。 最大子序和给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int sum = 0; int max_sum = nums[0]; for (auto i : nums){ if (sum &gt; 0){ sum += i; }else { sum = i; } max_sum = max(sum, max_sum); } return max_sum; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了92.04%的用户 内存消耗 :9.2 MB, 在所有 C++ 提交中击败了80.50%的用户 代码说明： ​ 别看着这个代码好像很简单似的，但是其中动态规划的算法还是不好理解的。 sum max_sum的含义是什么？ sum表示的当前选定的序列的和，max_sum值的是遇到的最大的序列的和。 sum &gt;0 -&gt; sum += i ? 这其实很好理解，前面的sum是正的，而且最大值已经被记录过了，加上前面正的序列对i有促进的作用，所以说新的序列就是前面的正的那一块加上当前的i. else sum = i? 前面的序列是负的，加上i无论i正负也好都不会有前面的序列大，所以直接从i开始一条新的序列就好了。 那万一i前面的那个值是正的，为什么不从i前面的那个正数开始呢？ 不可能的，i前面的那个值既然被加入了序列中就说明，i前面的前面的序列的和是正数，而i前面的序列和是一个负数，这就可以肯定i前面的数是一个负数。所以从i开始新的序列的最对的。 max_sum = max(sum, max_sum); 每次我们生成新的序列的，和都要和之前获取到的最大的数列的和进行比较以确保我们保存的的确是最大的子序列的和。 买卖股票的最佳时机给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。我一开始是这样子写的(纯暴力破解法，时间用的差不多是一千多ms吧，能AC我也是佛了) int maxProfit(vector&lt;int&gt;&amp; prices) { int profit = 0; int size = prices.size(); for (int i=0; i&lt;size-1; ++i){ for (int j=i+1; j&lt;size; ++j){ if (prices.at(j) - prices.at(i) &gt; profit) profit = prices.at(j) - prices.at(i); } } return profit; } 其实这个题目一眼看过去就知道是动态规划的算法，和前面的那个题目是类似的 int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size &lt;= 1) return 0; if (size == 2) return max(prices.at(1) - prices.at(0), 0); vector&lt;int&gt; buy(size, 0); vector&lt;int&gt; sell(size, 0); buy.at(0) = -prices.at(0); for (int i=1; i&lt;size; ++i){ buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); } return *max_element(sell.begin(), sell.end()); } 执行结果：通过 显示详情 执行用时 :20 ms, 在所有 C++ 提交中击败了25.61%的用户 内存消耗 :9.8 MB, 在所有 C++ 提交中击败了5.10%的用户 这个问题的解决方案是动态规划当中比较经典的填表的方法。之前的那个百度百科中也都已经介绍了这个公式。 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)} 与之比较类似的还有背包问题，待会可以一并解决。 代码说明： 上面的代码主要就是两行比较重要： buy[i] = max(buy.at(i-1), -prices.at(i)); sell[i] = max(sell.at(i-1), buy.at(i-1) + prices.at(i)); 第一个就是我在第i天买，比不比我在昨天买上算，如果今天比昨天还要贵那么我今天肯定是不买的。 第二个就是我在第i天卖有没有我在第i-1天卖上算，如果昨天卖比较好那还不如昨天卖。 但是光凭以上两点能解决什么问题呢？ 仔细看的话，你会发现，其实你每一天买的都是相对来说最优的。而每天卖的也是最好的。 我们可以这样想，如何只有三天的话，我们是不是就可以获得在第三天卖的最高的价格？ 假如是 1 2 5 只有buy[1] = 1 sell[1] = 2 第三天的价格是5，那buy[2] = 1，肯定还是延续在只有两天时的买法 sell[2] = max(sell[1], -1 + 5) ，这个卖就是sell[1]肯定是只有i两天的时候最优的利润，buy[1]也是最优的买法，现在加入就在第三天的时候，我们在第三天卖一下，我们看一看这个利润有没有之前的高。然后存入数组。 加上第四天的话还是这样子考虑。就这样其实sell数组里面放的就是有第n天的最大利润，sell数组后面值肯定也都是一样的。 于是取得最大值就行了。 return *max_element(sell.begin(), sell.end()); 注意：max_element返回的是迭代器，所以要加上*取值。 leetcode给出的官方题解是这样子的 public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i &lt; prices.length; i++) { if (prices[i] &lt; minprice) minprice = prices[i]; else if (prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; } return maxprofit; } 使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。 这两个算法的思路其实都是一样的，不过官方的题解更加的清晰明了。不过我上面的那个更像是一个动态规划算法，把一个问题拆分成他的子问题。要取得第七天的最大的利润，我们需要利用第六天的数据，这就是一步一步往后推的过程。 买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。额~这个好像有点儿复杂，不过如果想到转换的话，一步头就完事了。 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int size = prices.size(); if (size == 1 || size == 0){ return 0; } int profit = 0; for (int i= 1; i&lt;size; ++i){ if (prices[i] &gt; prices[i-1]){ profit += prices[i] - prices[i-1]; } } return profit; } }; 执行结果：通过 显示详情 执行用时 :8 ms, 在所有 C++ 提交中击败了89.37%的用户 内存消耗 :9.5 MB, 在所有 C++ 提交中击败了48.29%的用户 感觉这个和动态规划已经扯不上边了，算了叭说了，反正我也不会。。。。 转载两篇文章，这个动态规划有点儿难，我特喵现在也有点儿懵逼了，算了不研究了，下次研究透彻了再说吧。 文章阅读教你彻底学会动态规划——入门篇 算法-动态规划 Dynamic Programming–从菜鸟到老鸟]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本的增删改查操作]]></title>
    <url>%2F2019%2F07%2F19%2FMySQL%E5%9F%BA%E6%9C%AC%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[MySQL基本的增删改查 JDBC MySQL的连接 使用工具：Eclipse and Visual Studio 2019 这里其实无论是使用Java还是C++，使用的都是jdBC的操作。当然这里的Java相对来说更加的正宗一点，C++中的jdBC库我用了关于string那一块还有bug，兼容性还不行。所以这里就使用eclipse Java来举例吧。至于如何连接MySQL，这个倒是简单的很，也是不必再说了。 Driver的初始化try { //Class.forName是把这个类加载到JVM中，加载的时候，就会执行其中的静态初始化块，完成驱动的初始化的相关工作。 // 首先加载驱动包 com.mysql.cj.jdbc.Driver Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } mysql::MySQL_Driver* driver; driver = sql::mysql::get_mysql_driver_instance(); Connection连接数据库, 初始化 Statement// 连接的地址 localhost就是127.0.0.1就是本机的地址 world 代表的是要使用的数据库的名字 String url = &quot;jdbc:mysql://localhost:3306/sher?useUnicode=true&amp;characterEncoding=UTF8&amp;useSSL=false&amp;serverTimezone=UTC&quot;; // 建立和数据库的连接 url account password try { con = DriverManager.getConnection(url,&quot;root&quot;,&quot;root&quot;); stmt = con.createStatement(); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); } 其实上面的变量的声明都在类中的静态变量中，为了方便以后数据库的关闭 static ResultSet rs = null; static Statement stmt = null; static Connection con = null; static PreparedStatement pstmt = null; Connection* con; Statement* state; ResultSet* result; const char* accout = &quot;root&quot;; const char* passwd = &quot;root&quot;; con = driver-&gt;connect(&quot;tcp://127.0.0.1:3306&quot;, accout, passwd); state = con-&gt;createStatement(); 这里C++代码中要注意一个问题，account和passwd不能直接写driver-&gt;connect中，而且也不可以使用string类，不然会出现莫名其妙的bug，我也是求助了好长时间才知道这个地方出了问题，我也是醉了。 数据库的关闭private static void close() { try { if (rs!=null) { rs.close(); } if (stmt!=null) { stmt.close(); } if (con!=null) { con.close(); } if (pstmt!=null) { pstmt.close(); } } catch (SQLException e) { e.printStackTrace(); } } C++代码当中没有使用异常处理的机制，而且C++代码中异常处理也不是很好，反正使用体验极差。不过C++11中对于异常机制的改良，我也没学过不知道怎么样。 数据库的增删改查数据库增加数据private static void addData(int id, String username, String passwd) throws SQLException { String sql = String.format(&quot;insert into shertable(id, username, passwd) values(&#39;%d&#39;, &#39;%s&#39;, &#39;%s&#39;)&quot;, id, username,passwd); stmt.execute(sql); } 上面定义的时候我们使用了两种Statement。Statement和 PreparedStatement，这两种之间有什么区别呢？其实是建议使用PreparedStatement的，Statement容易被SQL注入，是不怎么安全的，不过为了介绍这里就都使用了。 stmt.execute(sql) 一般这种insert语句还有用的就是executeUpdate()。还有一个是executeQuery().这三者是有区别的 ResultSet executeQuery(String sql); 执行SQL查询，并返回ResultSet 对象。 int executeUpdate(String sql); 可执行增，删，改，返回执行受到影响的行数。 boolean execute(String sql); 可执行任何SQL语句，返回一个布尔值，表示是否返回ResultSet 。 不过这个execute也不是万能的。 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 至于这个？占位符是PreparedStatement中使用的，等到下面再说。 数据库查询数据private static void queryData(String sql) throws SQLException { rs = stmt.executeQuery(sql); while (rs.next()){ System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot; Username: &quot;+rs.getString(&quot;username&quot;)+&quot; Password: &quot;+rs.getString(&quot;passwd&quot;)); } System.out.println(); } state-&gt;execute(&quot;use world&quot;); // 查询 result = state-&gt;executeQuery(&quot;select * from city order by id desc limit 10&quot;); // 输出查询 cout &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot;; cout &lt;&lt; left &lt;&lt; setw(15) &lt;&lt; &quot;Id&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Name&quot; &lt;&lt; setw(15) &lt;&lt; &quot;CounryCode&quot; &lt;&lt; setw(15) &lt;&lt; &quot;District&quot; &lt;&lt; setw(15) &lt;&lt; &quot;Population&quot; &lt;&lt; endl; cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; while (result-&gt;next()) { int id = result-&gt;getInt(&quot;id&quot;); // 关于getString()这一块这个写的真的是全都是bug， 不过现在好像已经可以运行了。 string name = result-&gt;getString(&quot;name&quot;).c_str(); string countrycode = result-&gt;getString(&quot;countrycode&quot;).c_str(); string district = result-&gt;getString(&quot;district&quot;).c_str(); int population = result-&gt;getInt(&quot;population&quot;); cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; setw(15) &lt;&lt; id &lt;&lt; setw(15) &lt;&lt; name &lt;&lt; setw(15) &lt;&lt; countrycode &lt;&lt; setw(15) &lt;&lt; district &lt;&lt; setw(15) &lt;&lt; population &lt;&lt; endl; } cout &lt;&lt; setw(15) &lt;&lt; &quot;&quot; &lt;&lt; &quot;======================================================================&quot; &lt;&lt; endl; delete state; delete con; 看这个Java和C++中jdBC的操作基本上都是一样的。不过这里C++代码需要注意一下，我又被坑惨了。在使用result-&gt;getString()之后要加上.c_str()使其变成C风格的字符串。都说了string类在jdBC for C++中真的全是bug。C++其实也有C风格的MySQL数据库连接的库，不过那个已经不在这次介绍的范围之内了。 PreparedStatement 添加数据private static void setPstmtSql(int id, String username, String passwd) throws SQLException { pstmt = con.prepareStatement(&quot;insert into shertable(id, username, passwd) values(?,?,?)&quot;); pstmt.setInt(1, id); pstmt.setString(2, username); pstmt.setString(3, passwd); pstmt.executeUpdate(); } 这里就是pstmt的代码的使用。我们先使用占位符来创建一个SQL语句，然后使用setInt()，setString()的方法，来填入占位符中的内容，这是既简便了stmt字符串连接的操作，也可以防止SQL注入，很安全~ 注意上面说的： 如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。 数据库删除数据private static void delData(int id) throws SQLException{ pstmt = con.prepareStatement(&quot;delete from shertable where id=?&quot;); pstmt.setInt(1, id); pstmt.executeUpdate(); } 数据库修改数据private static void modifyPasswd(String username, String old_passwd, String new_passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;update shertable set passwd = ? where username = ? and passwd = ?&quot;); pstmt.setString(1, new_passwd); pstmt.setString(2, username); pstmt.setString(3, old_passwd); int flag = pstmt.executeUpdate(); if (flag!=0) { System.out.println(&quot;Successfully!&quot;); }else { System.out.println(&quot;Unsuccessfully, please try again!&quot;); } } 本列中其他的操作根据名字查询 private static void queryByName(String name) throws SQLException { pstmt = con.prepareStatement(&quot;select * from shertable where username = ?&quot;); pstmt.setString(1, name); rs = pstmt.executeQuery(); if (rs.next()) System.out.println(&quot;Id: &quot;+rs.getInt(&quot;id&quot;)+&quot;\nUsername: &quot;+rs.getString(&quot;username&quot;)+&quot;\nPassword: &quot;+rs.getString(&quot;passwd&quot;)); else System.out.println(&quot;Not Found!&quot;); } 登陆系统 private static void sign(String name, String passwd) throws SQLException{ pstmt = con.prepareStatement(&quot;select * from shertable where username = ? and passwd = ?&quot;); pstmt.setString(1, name); pstmt.setString(2, passwd); rs = pstmt.executeQuery(); if (rs.next()) { System.out.println(&quot;Sign Up Successfully!&quot;); }else { System.out.println(&quot;Worng UserName or Password!&quot;); } } 总结上面都只是MySQL中的基础中的基础中的基础的操作，作为从来没有学过MySQL的看看基本就行了。对于MySQL中进阶一点的操作，SQL命令的更加高阶的使用可以下次写写看，现在暂时MySQL用得还是比较少滴，不急着学。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数]]></title>
    <url>%2F2019%2F07%2F19%2F0.1%2B0.2%20%3D%3D%200.3%20%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0.1+0.2 == 0.3? 浅谈计算机中的浮点数0.1 + 0.2 == ？ 0.1 +0.2 是等于0.3的吗？这个问题似乎有点儿弱智，但是估计大多数人回答的都是错误的。在我们的认知当中，即使是在计算机当中，0.1+0.2也应该是等于0.3的啊，不然那不就乱套了嘛。不过现在你可以打开你的编译器来测试一下。 System.out.println((0.1+0.2 == 0.3)); // false 确实是不等的。。。那是不是Java的原因？我们可以使用C++，python测试一下. std::cout&lt;&lt;(0.1+0.2 == 0.3)&lt;&lt;std::endl; // 0 print( (0.1+0.2 == 0.3)) // False 我们发现无论是哪一种语言来说0.1+0.2都是不等于0.3的，这说明了这不是语言的问题了。那么0.1+0.2到底是多少呢？ std::cout&lt;&lt;std::setprecision(20)&lt;&lt;std::setiosflags(std::ios::fixed)&lt;&lt;0.1+0.2&lt;&lt;std::endl; 我们取了小数点二十位。输出的结果是0.30000000000000004441。这个结果果然不是0.3，后面为什么带了几个4呢？这是为什么呢？ 计算机中浮点数的储存众所周知计算机当中数据的存储都是二进制的。比如说2就是10,8就是100。如果有一个数带有小数的话，在计算中是如何存储的呢? 我们可以先来想想看如何把一个十进制小数表示成二进制。这个其实是和整数是一样的。二进制的小数点后的第一位是2-1=0.5，小数点后的第二位是2-2=0.25…以此类推。那么如何把0.1用二进制表示？和把一个整数转为二进制有点相似，小数转为二进制是使用乘以2的方式。 整数转为二进制：（除以2取余） 100/2 = 50 ……0 50/2 = 25 ……0 25/2 = 12 ……1 12 /2 = 6 ……0 6/2 = 3 ……0 3/2 = 1 ……1 1/2 = 0 ……1 然后将这些余数倒着写出来。100(10) = 1100100(2) 小数转为二进制：(乘以二取整) 0.1 * 2 = 0.2 ——0 0.2 * 2 = 0.4 ——0 0.4 * 2 = 0.8 ——0 0.8 * 2 = 1.6 ——1 0.6 * 2 = 1.2 ——1 0.2 * 2 = 0.4 ——0(开始重复了) 这次是将这些小数正写出来。0.1(10) = 0.0 0011 0011 0011 …… 可见二进制表示0.1是一个无限循环的数，可以float就占4个字节，double就占用8个字节。计算机是不可能使用这种方式来储存浮点数的。其实0.1~0.9999这9999个数中只有15个数可以用二进制精确的表示。 我们可以看一下Java当中基本类型表示的数的范围是多少 Java中基本类型的表示范围 数据类型 字节数 二进制位数 范围 规律 byte 1 8 -128～127 -27～27-1 short 2 16 -32768～32767 -215～215-1 int 4 32 -2147483648～2147483647 -231～231-1 long 8 64 -9223372036854775808 ~ 9223372036854775807 -263～263-1 float 4 32 1.4E-45~3.4028235E38 double 8 64 4.9E-324~1.7976931348623157E308 char 2 16 0～65535 0~216-1 boolean 1 8 true或false true或false float的大小是和int一样的，但是float表示的范围和int表示的范围比起来那可是一个天文数字。这就肯定说明了浮点数的储存是异于整型变量的。而且也必定说明浮点数是不精确的，不然如果float是绝对精确的，int还有存在的意义吗？这浮点数不也太能干了吗？ 其实浮点数为什么叫浮点数就是因为浮点数是浮动的，是不确定的。(量子力学？？)为什么浮动就要剖析一下浮点数存储的原理了。 浮点数的存储浮点数的存储分为一下四个部分。Java中浮点数的存储符合IEEE754标准。浮点数使用符号位、指数域和有效位数域来存储。 类型 符号位 指数域 有效位数域 float 1位（第31位） 8位（第23~30位） 23位（第0~22位） double 1位（第63位） 11位（第52~62位） 52位（第0~51位） 作用 表示浮点值的正负 存储指数位 存储小数值 浮点数的符号位和整型变量是一样的。0表示正数，1表示负数。 指数使用了偏移量的方式来表示。偏移量为2x-1(比实际值大2x-1)，x表示的是指数域的位数。 任何一个非0且非无穷大的浮点数都可以表示为 v = s × m × 2e的形式。 s为-1或1，m为有效位数(小数)，e为指数。 根据m和e的不同，我们可以将浮点数分为三类： 正规化浮点数 ——指数域不全为0且不全为1. 如99.5f在计算机中存储为：0 10000101 10001110000000000000000 有效位数是0.1000111，加上1为1.1000111转为十进制为1.5546875. 指数部分减去偏移量(01111111)就是110也就是6. 符号位为0，表示这是一个正浮点数。 99.5f = 1 × 1.5546875 × 2 6 = 99.5（就是这么完美） 16进制表示为 0x1.8ep6 (1.8e-&gt;1.10001110) p:代表指数位，因为e在16进制中已经被使用了。 6代表26 非正规化浮点数 ——指数域全为0且有效位数域不全为0 如5.877472E-39f在计算机中存储为：0 00000000 1000000000000000000000 有效位数为0.1此时不再加上1，转为十进制为0.5 指数位为 1-127为-126 符号位为0，表示这是一个正浮点数。 5.877472E-39f= 1 × 0.1 × 2-126 = 2-127(误差有点打好像。。。) 16进制表示为0x1.0p-127 特殊浮点数 浮点数 符号位 指数域 有效位数域 0 0 全是0 全是0 负0 1 全是0 全是0 正无穷大 0 全是1 全是0 负无穷大 1 全是1 全是0 NaN 任意 全是1 不全为0 所谓NaN就是 Not a Number 上面我们就基本了解了浮点数在计算机中是如何存储的了。 我们也可以使用Float和Double类中的中如下两个方法来查看对应浮点数在计算机中的存储情况。 public static int floatToIntBits(float value); // Float类中 public static long doubleToLongBits(double value); // Double类中 // 不过以上的两个方法输出的都是十进制的值我们可以使用 Integer (Long)类中的转为二进制 public static String toBinaryString(int i); public static String toBinaryString(long i); // 不过还是有问题，就是前面如果有0的话，0是不会输出的，我们可以根据输出的长度进行补0 浮点数比较需要注意的地方扯了那么多有点没的，其实还是要回到之前的那个问题上——浮点数之间的比较。0.1 + 0.2 == 0.3怎么才能让他返回true呢？ 设置绝对误差public static int compareFloat(float a, float b, double realError){ if (Math.abs(a-b) &lt;= realError){ return true; }else { return false; } } 不过这样真的合理吗？设置realError为 10-6 10-6好2 × 10-6返回的也是true。不过，平心而论他们的确不应该返回true。 而1000000000和1000000000.1应该返回true的却返回了false 设置相对误差public static int compareFloat(float a, float b， double absError){ if (Math.abs(a-b)/(a+b)*2 &lt;= absError){ return true; } return false; } 不过这种相对误差其实也是有点儿问题的。 其实对于浮点值精度的丢失的解决方法是非常复杂的，而且是没有一个固定的方法的。我们只能考虑到我们 自己的需求，设置合理的误差的范围进行合理的比较。 设置绝对误差和相对误差public static compareFloat(float a, float b, double realError, double absError){ if (a == b){ return true; } if (Math.abs(b-a) &lt;= realError){ return true; } if (Math.abs(b-a)/a+b*2 &lt;= absError){ return true; } return false; } 设置好合理的realError和absError就可以确保0.1+0.2 == 0.3啦 其实关于浮点数的转换也有很多的问题，不过这里就不多说啦。。。 总结浮点数是条蛇，别有事没事就玩它！尤其是这种代码就別写出来丢人了。。。蛤蛤蛤 for (double i = 0.1 ; i != 1.0; i += 0.1){ // ... } 之前看到没啥的，现在看到总是想笑~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的equals与==陷阱]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84equals%E4%B8%8E%3D%3D%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[浅谈Java中的equals与==陷阱 Java当中最常用的一个类便是String，对于C++程序员来说这个string也是非常熟悉的。到了Java这一块，咦，仅仅是变了一个大小写一样，还不是一样的用。不过用着用着就发现了一个天大的问题。这也是我实际写Java的时候发生的问题，程序莫名其妙死了，就是因为使用了Java的== std::string a = &quot;abc&quot;; std::string b = &quot;abc&quot;; if (a == b){ std::cout&lt;&lt;&quot;a is equal to b&quot;&lt;&lt;std::endl; } else { std::cout&lt;&lt;&quot;a is not equal to b&quot;&lt;&lt;std::endl; } String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } 对于一个C++程序员来说上面的代码输出什么估计想都不用想都知道是输出a is equal to b，但是如果是一个Java程序员他肯定会说肯定输入a is not equal to b。C++程序员在想：Java程序员这么弱智的嘛，这个a和b明显相等的啊！Java程序员在想：C++程序员这么智障的吗，这个明显不相等的啊！先不管这两个程序员骂来骂去的了，先看看为什么会发生这种情况。 这时候一般就会有一个大神跳出来说，你们这群蠢蛋，Java当中==比较的是地址，equals()方法才是比较的内容。C++程序员其实是在做这样的事 String a = &quot;abc&quot;; String b = &quot;abc&quot;; if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b); } C++程序员一测验，果然输出了a is equal to b。哇这个人果然是大神，晓得了晓得了，又学到了一个知识点，==比较地址，equals比较内容。不过C++程序员转念一想1 + 1 == 2难道在Java中都不对吗？于是反问大神，大神说：你是沙雕吗？这个肯定是true啊。那我加个限制吧，对于非基础类型而言，==是比较地址, equals()方法是比较内容。 但是C++程序员都是比较喜欢test瞎测验的。这一侧不得了了。 StringBulider a = new StringBulider(&quot;abc&quot;); StringBulider b = new StringBulider(&quot;abc&quot;); if (a.equals(b)){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } if (a == b){ System.out.println(&quot;a is equal to b&quot;); } else { System.out.println(&quot;a is not equal to b&quot;); } C++程序员发现这两个输出的都是a is not equal to b。鬼鬼，这还得了啊。问了一下大神，大神也是哑口无言了。说起什么，你这个类不算，肯定是你的类出了问题。 那么问题到底出在了哪儿呢？ 首先我们要清楚为什么为什么每个类都会有一个equals方法。比如如下写了一个类 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } // 这里省略了setter public int getId(){ return this.id; } public String getName(){ return this.name; } } 我们发现这个类中没有写equals方法，但是我们仍然是可以调用的。原因就在于Java中的每个类都是默认继承Object的，也就是说equals是从Object中继承过来的方法。那就好办了，直接看看Object中equals()方法是怎么写的不就行了。 public boolean equals(Object obj){ return (this == obj); } 我靠！这个equals和==不就是一样的嘛。有个屁的区别啊。这大神不是在耍我完的吗？那为什么上面的String类中==和equals呈现的结果不同呢？那是因为String中是Override(覆盖)了equals方法的。 以上面的这个Student举例，判断两个人是不是相等，肯定不能用name(光是我听到的名字叫张旭的就至少五个，据说有一次考试按姓名分班，全校的张旭都坐一排，到了张旭，有来了两个张旭，感觉张旭这个名字比张伟还强，至少张伟这个一个都不认识)。所以我们应该用id来重载一下equals()方法。 class Student{ private int id; private String name; public Student(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == obj.id; } return false; } } 哈，现在已经都完事了吧。这样这个类也算是完美了。 至于重写equals方法是有五个规定的，不过那五个规定估计傻子都不会违反的，这里就叭说了。 重写了这个equals难道这就完美了吗？不尽然。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Student){ Student s = (Student)obj; return s.getId() == this.id; } return false; } } 你说此时，难道作为人的小明和作为学生的小明不是一个人吗？所以说这个equals还是有不足，没有考虑到可能有的父类。或者说这个equals可以直接在父类中重载，而不用在子类中重载。 把这一点也考虑到了，哇哈哈，这个equals已经完美了，不是么？ 嗯。。还真的不是，你以为你又能了，其实不然。尤其是在HashMap的使用上。 Student a = new Student(123, &quot;sher&quot;); Student b = new Student(123, &quot;sher&quot;); System.out.println(a.equals(b)); // true Map&lt;Student, Integer&gt; scoreMap = new HashMap&lt;Student, Integer&gt;(); scoreMap.put(a, 99); System.out.println(scoreMap.get(a)); // 99 System.out.println(scoreMap.get(b)); // null 你看，又出问题了。即使你a和b是完全一样的。但是放入HashMap中之后你却只能通过a来获取成绩了。这是因为HashMap使用的是哈希表。HashMap在判断你是否相等的时候是这样子的. if (a.equals(b) &amp;&amp; a.hashCode() == b.hashCode()){ .... } 前面虽然是相等的，但是后面是不相等的。那么后面那玩意是啥啊？其实他也是所有类都从Object继承的方法。当我们重写equals而不重载hashCode的话，就会在这些使用哈希表的集合中出现问题。所以api文档规定我们: 如果两个对象调用equals()是true，那么他们的hashCode必须是相等的。(hashCode返回一个int) 如果两个对象调用equals()是false，我们建议他们的hashCode不要相等。 所以我们还要Override一下hashCode方法。 class Person{ protected int id; protected String name; public Person(int id, String name){ this.id = id; this.name = name; } public int getId(){ return this.id; } public String getName(){ return this.name; } } class Student extends Person{ @Override public boolean equals(Object obj){ if (obj instanceof Person){ Person p = (Person)obj; return p.getId() == this.id; } if (obj instanceof Student){ Student s = (Student)obj; return s.id == obj.id; } return false; } @Override public int hashCode(){ // int类型的hashCode系统已经替我们写好了 return Integer.hashCode(this.id);// 其实就写return id;好像也没什么问题，毕竟是整型变量。 } } 至此，是不是就没有问题了呢？其实，可能还有问题，不过还有什么问题，我也是不晓得的了，等学到了更多的知识，有了丰富的经验之后看这一小段代码，还是会有很多的问题。不过，这个问题，现在就叭说了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（八）堆排序]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（八）堆排序 堆排序算是里面最比较难懂的算法了，因为堆排序需要二叉树的基础。不过虽然说靠的是二叉树但是实际上并没有生成一个二叉树而是利用了顺序存储二叉树，来构造大顶堆和小顶堆来实现的。 堆排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 是 我感觉这个算法牛不牛逼已经是不言而喻的了。时间复杂度是交换法的巅峰，空间复杂度还是O(1)，这个算法实在是神奇。赶紧如果是学会了这个算法就可以去装逼了。别人排个序是 好几秒，你排个序是几毫秒。关键是你们用的还是同样的内存，这谁能顶得住啊！不过，要说明的是，堆排序是一种不稳定的算法。 堆排序的基本思路 上面也提到了，堆排序是用顺序存储二叉树来实现的。那什么是顺序存储二叉树呢？ 且看下图 我们大多数时候所了解到的二叉树都是上面的链式结构的二叉树，直观而且容易理解和操作。但是二叉树也可以用数组来表示。可以说一个数组就对应了一个二叉树。右面的图展示的是非完全二叉树的顺序存储，这里是我们不需要的。因为堆排序的时候要构造大顶堆(从小到大排序)。如果要是从小到大排序的话就要构造小顶堆。大/小顶堆就是一种完全二叉树。所谓完全二叉树所有的叶子节点(也就是没儿子的节点)都必须出现在最后两层，而且叶子节点在左面要连续。 按照上面的顺序存储的关系，上面的大顶堆可以转换成为一个数组来表示。 观察这个数组和二叉树，我们可以得出如下的结论。arr[n]的左子结点是arr[2n+1]，右子节点是arr[2n+2]，父节点是arr[(n-1/2)] 大顶堆的每个一个节点的值都大于他的左子结点和右子节点。但是左右节点之间的大小是不用限制的。 根据大顶堆的定义我们就可以知道大顶堆的根节点的值一定是所有节点当中最大的。如果我们把根节点去掉，然后利用剩下的节点再构造一个大顶堆。我们又可以找到第二大的节点，如此循环。我们就可以让数组变得有序。但是，如何构造大顶堆呢？ 看到上面的动图其实是有一点儿傻眼的，这不是数组排序吗？为什么搞这个一个二叉树在这？其实我们实际上并没有构造这个一个二叉树，只是把数组想象为一个完全二叉树罢了。要想把一个二叉树变成大顶堆，首先我们要看他的非叶子节点，因为叶子节点没有子节点，对于构造大顶堆是没有意义的。对于一个顺序存储二叉树，他的叶子节点是哪几个呢？答案是从0到arr.length/2-1。蛤？为什么是这几个节点啊？如果你仔细观察的话，叶子节点的个数永远是比非叶子节点多一个的，一棵树要么是叶子节点，要么是非叶子节点，所以非叶子节点个数 arr.length/2个。而非叶子节点都是存储在数组的前面的，所以说非叶子节点的下标是0到arr.length-1。 对于一个非叶子节点来说，要满足大顶堆的条件，就要使他大于他的子节点。而所有的非叶子节点都大于他们的子节点的话，这棵树就是一个二叉树了。 堆排序的代码实现 将数组调整为大顶堆代码实现 /** * 将一个数组（二叉树）调整成一个大顶堆 * @param arr 待排序数组 * @param i 非叶子节点在数组中的索引 * @param length 数组的大小(逐渐减小的) */ private static void adjustHeap(int[] arr, int i, int length) { int temp = arr[i]; //：2*i+1 左子节点的索引 2*i+2 右子节点的索引 for (int k = 2*i+1; k &lt; length; k=2*k+1) { if (k+1&lt;length &amp;&amp; arr[k] &lt; arr[k+1]) { k++; } if (arr[k] &gt; temp) { //：子节点大于父节点， 两者交换位置 arr[i] = arr[k]; i = k; // 继续循环比较 }else { break; //：为什么break？ 以i为父节点的下面的都已经排序过了，都是大顶堆了 } } arr[i] = temp; } 代码说明： for循环里面的k, temp是干什么的 ? k的初始值是给定的非叶子节点的左子结点。每次循环都要到下一个左子结点。arr[k] &lt; arr[k+1]就是比较左右子节点哪个大。k++就是定位到右子节点，因为一开始k是指向左子结点的，右子节点的下标比左子结点大1。 temp保存的是给定的非叶子节点中的值。 arr[k] &gt; temp 说明左右子节点中较大的那个要比他要大，那么就把他赋给当前给定的非子节点。 为什么 i = k。为什么要循环比较？ 非叶子节点不是只有叶子节点，他们的子节点也会有子节点。假定我们让子节点的值变成非叶子节点的那个值，而非叶子节点的值又是很小的。那么那个子节点构成的岂不是大顶堆了？所以还是要递归下去继续构造大顶堆。 为什么else break？ 其实这个问题应该在第二个问题的前面的。我们构造大顶堆其实是从下往上构造的。也就是说从arr.length/2-1到0这个顺序来构造的。也就是说我们在构造非叶子节点i的过程中就知道他的左子树和右子树其实都是大顶堆。如果我们没有进行交换也就没有破坏左子树和右子树的大顶堆结构，如果进行交换了就有可能破环了他们的大顶堆结构了。毕竟如果交换了，说明非叶子节点的值要小一点嘛。你不能确保他比子节点的子节点的值要大。 arr[i] = temp 是什么意思？ 你或许发现了，我们始终没有说交换，这就有点像移位法的味道了。我们只是给i找到合适的位置，（第二个问题中的i = k 就是在做这个事情）当for循环退出了，意味着i的位置就找到了，这时给之前保存好的temp安上去就行了。 堆排序代码public static void heapSort(int[] arr) { int temp = 0; // 将其变成大顶堆 for (int i = arr.length/2-1; i &gt;=0; i--) { adjustHeap(arr, i, arr.length); } // ：将大顶堆上面的元素交换到末尾，然后对大顶堆最上面的元素排序 for (int j = arr.length-1; j &gt; 0; j--) { temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); } } 代码说明： 第一个for循环? 其实第一个for循环就是我们上面说过的，大顶堆是从下往上构造的。只有这样我们才能确保要构造的非叶子节点的左子树和右子树都是大顶堆。 第二个for循环？ 将构造好的大顶堆的根的值(arr[0])放到数组的最后面，然后把数组最后面的元素移动到根处。并且还要将要进行构造大顶堆的 length-1，因为已经最大的那个数已经不用再去构造大顶堆了，安心在数组后面躺着吧。 adjustHeap(arr, 0, j)，这次构造大顶堆为什么没有循环了，而一开始需要循环？ 因为一开始的数组对应的二叉树的根节点的子树不是大顶堆。而此时，将一个大顶堆的根节点移走，然后取他的一个叶子节点作为新的根，这个新的二叉树虽然不再是大顶堆，但是根节点的左右子树依然是大顶堆。所以说不用再循环了。 堆排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); heapSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 9ms Time : 0ms Time : 15ms 8,000,000数据时： Time : 1686ms Time : 1703ms Time : 1672ms 总结 什么这个0ms你是认真的吗？我测试了几次，有好几次0ms，但是全写0ms有点太高调了，所以还是让你大一点，防止你骄傲。不过说实话处理八百万个数据的时候，堆排序处理的并不快。毕竟是空间复杂度O(1)的算法，对于海量数据的处理还是略显疲软。不过这并不然掩盖这个算法的光辉之处，能想到这样的排序算法，图灵奖获得者——弗洛伊德是真的牛逼。这个人好像写了不少有名的算法。QwQ]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（七）基数排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（七）基数排序 这里说的是基数排序(Radix Sort)而不是计数排序(Counting Sort)，计数排序也是另外的一种比较高效的排序算法，但是这个算法不在我近阶段要讲的算法之列。说起和基数排序类似的算法，桶排序(Bucket Sort)其实就是和基数排序是有点儿相似的，不过桶排序也不在近阶段介绍之列，蛤蛤蛤~~(⊙o⊙)… 基数排序的的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 一般 我们发现这个基数排序的时间复杂度似乎是比O(nlogn)要低的，但是这个O(nlogn)是比较类的排序算法的下限，基数排序是一种典型的使用空间来换取时间的算法，不属于比较类排序算法。另外要说的是，基数排序是一个稳定的算法。 基数排序的基本思路 基数排序的基本思路是准备十个桶。从0号桶到9号桶。第一次我们使用个位数进行排序，然后把数据从桶中依次取出来。第二次使用百位数进行排序。。。以此类推就这样这个数组就是有序的了。这个思路还是比较容易理解的。 下面直接上图吧。 再来一个图片看一下子 这个算法算是一般流弊算法吧。因为特别容易理解，没啥需要理解的，搞得我都不知道要说什么啦。。。 直接来上代码看代码的实现吧。 基数排序的代码实现 public static void radixSort(int[] arr) { int[][] backet = new int[10][arr.length]; int[] backetElementsCounts = new int[10]; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } // 下面两种方法都可以选择 转为字符串求数字的长度 int maxLength = (max+&quot;&quot;).length(); // int maxLength = Integer.toString(max).length(); for (int i = 0, t=1; i &lt; maxLength; i++, t*=10) { // 数据放入桶中 for (int j = 0; j &lt; arr.length; j++) { int which_backet = arr[j]/t%10; backet[which_backet][backetElementsCounts[which_backet]++] = arr[j]; } // 把数据从桶中取出 for (int j = 0, k=0, m=0; j &lt; 10; j++) { while (backetElementsCounts[j] != 0) { arr[k] = backet[j][m]; backetElementsCounts[j]--; k++; m++; } m=0; } } } 代码说明： 第三行代表的含义是什么？ 第二行代码其实就是在造桶子，十个桶子，每个桶子的大小的都是arr.length，因为万一所有的数的某一位都是相同的，那个桶子不就爆了喵？？而第三行的数组是存放每个桶子中的元素的个数。因为下面还是要取出元素的，不知道放了几个元素，怎么取，玩蛇皮的嘛。 为什么要求最大的数字的长度？ 这个把数字转为字符串来求长度还是非常的妙的。不过你问为啥要求最大的数字的长度？？因为后面我们要从个位数开始根据每个位置开始排序啊。 t的作用是什么？ 第一次取到个位数就是 num/1%10。取百位数就是 num/10%10。我们通过每次t /= t就可以依次取到各个位数了。每次放入一个元素之后，对应的用来计数的数组中的值也要增加1. 如何取出数据的？ 这恐怕是更容易理解的。找到桶里有数据的桶，看看桶中有几个数据取出来放到原来的数组中不就完事了。 唉~，这个算法是实在简单，搞得我是真的没话说了。我也是醉了吖。。。 基数排序的测试 测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); radixSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 12ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 423ms Time : 397ms Time : 404ms 总结 可以清楚的看到排八万个这种小数据的时候，几种高效的算法几乎没有区别。不过排八百万个数据的时候，基数排序就发挥出了他的优势。快啊！不过要说明的是，基数排序极其占用内存，如果是排序八千万个数耗费的就是4个G左右的内存，所以说在内存不足的情况下，这个算法是不适合考虑的。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（六）归并排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（六）归并排序 归并排序算法是分治算法的一个典型。所谓分治算法就是把一个复杂的问题分成多个子问题。这些子问题如果都解决了，这个复杂的问题也就解决了，这是典型的先分后治的思路。归并排序也算得上是一个比较复杂的算法了，说实话原理容易看懂，但到底是如何解决的可要大费脑筋了。 归并排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 是 你或许看到了，是否牛逼那一块我写的是是，那这个算法也就是我们第一个接触到的，流弊的排序算法，因为速度是很快的。同时你也可以看到空间复杂度是O(n)，要知道很多复杂的算法以及各种各样的缓存机制，数据库等等都是使用空间来换取时间的，不过这样也并不意味着排序算法的时间复杂度可以变成O(1)，算法导论中有证明，排序算法的最低时间复杂度是O(nlogn)。 归并排序的基本思路归并排序的思路很难将明白，但是举个列子就很好说了。假如有待排序的数组4 1 2 5 8 7 6 0.我们找到mid((left+right)/2)先将其分为两个数组4 1 2 5和8 7 6 0（实际上我们并没有真的的分为两个数组，操作的始终是原来的那个数组）,然后再分为 4 1，2 5,8 7,6 0，然后继续分成 4,1,2,5,8,6,7,0.到这儿你或许会说，卧槽你这不是玩我的嘛，分了半天就是把数组之间加上逗号？玩蛇皮？其实我们的目的不在于分，而在于治。将 4 和 1 排成一个有序的数组简单不？就是 1 4 同理第一轮治理数组就变成了1 4 2 5 7 8 0 6然后再将1 4 和 2 5排序 7 8 和0 6排序。数组变成了1 2 4 5 0 6 7 8最后对1 2 4 5 和0 6 7 8 排序。数组变成了0 1 2 4 5 6 7 8，这样就变得有序了。 你或许在想，卧槽！这什么垃圾算法？这个速度也能快？这能叫流弊算法？ 但是人家是真的快啊，而且你没有注意到的是，我们始终在做一件事情，把两个有序的数组合并为一个有序的数组。这就是这个问题的子问题，我们只有解决了这个问题也就解决了排序这个复杂的问题了。把两个有序的数组合并为一个有序的数组真的是一件简单的事情，只需要一个额外的临时的数组的帮助就可以轻松的解决。 看了下面的这个图，应该就很容易理解了。把数组中的元素往下放就是下面有一个临时数组。 归并排序的代码实现首先我们先来完成治的过程，两个有序数组的合并 “治”的代码实现public static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left;// 左边有序序列的初识索引 int j = mid+1;// 右边有序序列的初识索引 int t = 0;// 指向temp临时数组当前的序列 // 将左面和右面的值按照大小放入到临时的数组当中去 while (i &lt;= mid &amp;&amp; j&lt;=right) { if (arr[i] &lt;= arr[j]) { temp[t] = arr[i]; ++t; ++i; }else { temp[t] = arr[j]; ++t; ++j; } } // 如果左面还剩下数据的话，直接放入临时数组中，此时右面的已经都放入了临时数组中。（上面while退出就是一个已经放完了） while(i &lt;= mid) { temp[t] = arr[i]; ++t; ++i; } // 同理，左面为空，右面还有数据，直接放入临时数组当中 while (j &lt;= right) { temp[t] = arr[j]; ++t; ++j; } // 将temp拷贝到原始的数组当中去。注意放入临时数组的范围是从left到right t = 0; int tempLeft = left; while (tempLeft &lt;= right) { arr[tempLeft] = temp[t]; ++t; ++tempLeft; } } 代码说明： 函数的参数是？？ 首先需要说明的是，数组其实是没有分的，只是逻辑上分为了几个数组，待合并的数组也还都是相邻的。 left是左边有序数组的开始 mid是中间的那个数，也就是(left+right)/2，需要注意的是，mid这个位置的值是属于前面的那个数组的，所以说右边有序数组的开始是mid+1。right是待合并的数组的结束。也就是说这个函数操作的只是数组的arr[left]到arr[right]而已。 temp 是用来辅助排序的临时数组 第一个while循环在干啥？ 很好理解第一个while循环是不停的把两个有序数组中的元素放入临时数组中去，直到有一个数组为空了，就退出while循环。这时，我们就可以直接把不为空的那个数组放入到临时数组的后面。于是便有了后面的两个while循环。 最后一个while循环是? 把临时数组中的元素拷贝到待排序数组的left到right上。我前面说过，数组其实并没有真正分为两个，只是逻辑上分为两块而这一个函数操作的就只是数组的left到right。也就是说一个函数只是解决了一个子问题。 “分”的代码实现public static void mergeSortHelper(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right)/2; // 找到中间值，开始分治 mergeSortHelper(arr, left, mid, temp); mergeSortHelper(arr, mid+1, right, temp); merge(arr, left, mid, right, temp); } } public static void mergeSort(int[] arr) { int[] temp = new int[arr.length]; mergeSortHelper(arr, 0, arr.length-1, temp); } 代码说明： 这我咋有点看不懂？ 虽然治才是分治法的核心但是这里的分确实是有点不好理解。不好理解的主要原因是你对递归的了解还不够透彻。上面将数组分为了两个部分，然后合并。 一开始左右不是无序的吗？怎么能合并呢？ 这就是我所说的递归的理解了。执行到第一个mergeSortHelper时会一直递归，递归到left == right退出递归。执行下面的第二个mergeSortHelper，需要注意的是此时位于的是退出的那个栈的前一个栈，也就是right - left == 1的那个栈。回到那个栈之后又是一直递归。又到了left == right又退出了递归。那么执行到第三个合并的时候位于那个栈呢？此时第一个mergeSortHelper的栈都位于底部。最上面的那个栈是left = 0，mid =0， right=1。为什么呢？因为退出的那个栈是left == right而这个right就是上一层的mid 也就是说mid = (left + right)/2是为0的。而这个栈是没有退出的也就是说left &lt; right。所以right =1；。。。。我特喵的再将什么。算了不说这个递归过程是如何的了。直接通俗的将一下吧。 我听不懂你乱七八糟的说辞，可以讲的简单一点吗？ 双递归函数本来就有点乱，况且后面还带了一个函数，我理解的也不是很透彻。简单的将就是mergeSortHelper的作用是left到right变得有序，第一个mergeSortHelper因此就是使左面有序，第二个是使右面有序，第三个是使左右两个有序的合并。 这也行？讲的也太敷衍了吧。。。 其实一点都不敷衍，你看看其他的两次递归算法。比如斐波那契数列，汉罗塔问题。不都是这样解决的吗？ 斐波那契数列代码public static int fibonacci(int n){ return (n==1 || n==2)?1:fibonacci(n-1)+fibonacci(n-2); } 汉罗塔问题代码public static void hanoi(int n,char a, char b, char c){ if (n == 1){ System.out.println(a+&quot;-&gt;&quot;+c); } hanoi(n-1, a, c, b); System.out.println(a+&quot;-&gt;&quot;+c); hanoi(n-1, b, a, c); } 上面的两串代码都是即兴瞎写的不保证对，但是思路是一样的。你说这些递归问题都是如何解决的呢？如果说斐波那契数列比较容易理解，这个肯定是可以算出的啊。那么汉罗塔问题呢？？这个问题够复杂了吧。将n个盘借助b从a移动到c，我们只需要分析子问题是什么——子问题是将n-1个盘借助c移动到b，然后将最大的那个盘从a移动到c，然后再借助a把n-1盘从b移动到c。这里我们只需要知道1个盘怎么移动，那么2个盘，3个盘就是999999个盘我们都可以知道。（如果有64个盘，有一个人知道如何移盘，假设他一秒移动一个盘子，那么移动到太阳系没了也不会移完的。）归并排序也是如此。当right只比left大一的话(此时不用多次递归)就可以合并这个数组，那么当right比left大得多的时候呢？不就是根据先把左右有序然后合并一样的道理吗？这就是递归解决问题的神奇之处。 归并排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个和8,000,000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Randon.nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); mergeSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 80,000数据时： Time : 11ms Time : 12ms Time : 16ms 8,000,000数据时： Time : 1029ms Time : 1024ms Time : 1007ms 总结可能是测试的时候电脑的问题，为啥归并排序排8,000,000还比快速排序慢啊，这个其实很意外，按照时间复杂度来说应该是归并排序快一点啊。不过再我多次测量了之后，速度稳定在1000ms，放弃了。唉~，只能说一句，快速排序牛逼！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（五）快速排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（五）快速排序 希尔排序是插入排序的升华，这里说的快速排序其实就是冒泡排序的升华？（啥？冒泡排序终于有了出人头地的机会了。。）不过我反正是很难看出来快速排序和冒泡排序之间的关系多的。冒泡排序是相邻的两个值之间进行比较然后进行交换，而快速排序是一种递归的过程。。真心发现不了其中的关系。 快速排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 快速排序 O(nlogn) O(nlogn) O(n2) O(logn) 一般 之前也已经说过了，快速排序是一种不稳定的排序算法，是冒泡排序的一种优化，至于是如何优化的，后面一起看一下子吧。 快速排序的基本思路希尔排序是将数据分组进行插入排序，那莫非快速排序就是把数据分组进行冒泡排序？其实并不是。 快速排序的思路是： 以当前的数组中的一个元素(一般取第一个元素也就是arr[0])作为基准值，然后将数组变换为左面的数都比基准值小，右值的值都比基准值大，然后对左面的那一块和右面的那一块进行同样方式的快速排序。直到发现待排序的数组的大小只有1的时候就退出。此时数组也就变得有序起来了。 下图中是将数组的最后一个作为基准值的，其实都是一样滴~ 这张图是以最左面的值作为基准值的，讲解的也蛮不错的，就是画质太渣了。 可以清楚的看到上面两个快速排序的实现思路是有一点不同的。第一张采用的是移位法，第二张采用的是交换法。所以说，和插入排序，希尔排序一样，快速排序也有两个实现的思路。 快速排序——交换法代码实现public static void quickSort(int[] arr, int left, int right){ // 这个是后面的递归的退出的条件 if (left &gt;= right){ return; } int temp = arr[left];// 最左面的值作为基准值 int l = left; int r = right; int t;// 用于下面的数据的交换 // 其实交换用不着额外的变量可以使用异或的操作来进行 a^=b^=a^=b 就可以对整型变量的值进行交换 while(l &lt; r){ // 从右面找到比基准值小的下标 while(l &lt; r &amp;&amp; arr[r] &gt;= temp){ --r; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; // 从左面找比基准值大的下标 while(l &lt; r &amp;&amp; arr[l] &lt;= temp){ ++l; } t = arr[r]; arr[r] = arr[l]; arr[l] = t; } // 退出的时候 l == r 这是肯定的毕竟每次都是只走一步l和r必定会相遇。相遇的时候arr[l] == temp! // 对数组的左面和右面进行同样操作，也就是递归.其实两个if是多余的，上面已经有了退出递归的条件了。不过加上if就可以减少一次递归的次数，何乐而不为呢？ if (left &lt; l-1){ quickSort(arr, left, l-1); } if (l+1 &lt; right){ quickSort(arr, l+1, right); } } public static void quickSort(int[] arr){ quickSort(arr, 0, arr.length-1); } 代码说明： 基准值为什么选第一个数？ 其实你要是乐意的话，left到right之间的任意一个值都是可以取的。只要你有本事写出对应的算法就完事了。一般情况下我们是取第一个值(arr[left])或者最后一个值(arr[right])的。 基准值的选择会影响后面的代码？ 这肯定的啊。要不然选个锤子的基准值的。后面我们做的事情就是不停的交换使得基准值位于这样一个位置——左面的值都比他小，右面的值都比他大 这个到底是如何做到的，我看只是只是l和r不停的交换的啊？ 如果你仔细留意我上面的倒数第一张图的话，你会发现虽然是l和r的交换，实际上每次都有基准值的参与。一开始基准值位于arr[l]，我们从右面找到了第一个小于基准值的数，经过第一次的交换我们就可以确定当时r右面的值都是比基准值大的。此时基准值位于arr[r]。我们又从左面找到第一个比基准值大的数，进行第二次交换，基准值的位置又到了arr[l]，此时我们依然可以确定l左面的值都是比基准值小的。如此一来循环往复。我们始终可以确信的是，left到l-1上的值都是比基准值小的，r+1到right上的值都是比基准值大的。直到l和r相遇，基准值位于arr[l]处，他左面的值都比他小，右面的值都比他大。 为什么一开始先从右面开始，也就是说为什么先从右面找第一个小于基准值的数？ 因为一开始选定的基准值是位于arr[left]的吖，如果你选定的是arr[right]作为基准值的话，你就要先从左面开始找大于基准值的数了。如果你选定的是其他位置的话。。你为什么要那么欠呢？如果你不嫌麻烦的话，当我没说。。。 快速排序——移位法代码实现public static void quickSortPlus(int[] arr, int left, int right) { if (left &gt;= right) return; // 此时不用排序 int temp = arr[left];// 记录基准值。 左面的数都比基准值小，右面的都比基准值大 int l = left; int r = right; while (l &lt; r) { // 从右面找到比基准值小的数 while (l &lt; r &amp;&amp; arr[r] &gt;= temp) { --r; } // 移动到左面， 此时第一轮的时候基准值被覆盖 arr[l] = arr[r]; // 从左面找到比基准值大的数 while(l &lt; r &amp;&amp; arr[l] &lt;= temp) { ++l; } // 将大的数移动到后面，此时后面的那个比基准值小的数被覆盖了 arr[r] = arr[l]; } // 退出循环的时候l==r 此时这个位置就是temp这个基准值应该插入的位置 arr[l] = temp; // 递归下去对左右两边进行排序 if (left &lt; l-1){ quickSortPlus(arr, left, l-1); } if (l+1 &lt; right){ quickSortPlus(arr, l+1, right); } } public static void quickSortPlus(int[] arr){ quickSortPlus(arr, 0, arr.length-1); } 移位法其实说的已经蛮多的了，这里就不再赘述了。其实代码也就改了几行而已。也么得什么好说的。 快速排序的测试public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); quickSortPlus(arr); // quickSort2(arr, 0, arr.length-1); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 80,000数据时： Time : 14ms Time : 23ms Time : 25ms 8,000,000数据时： Time : 836ms Time : 804ms Time : 772ms 移位法 80,000数据时： Time : 14ms Time : 13ms Time : 15ms 8000000数据时： Time : 734ms Time : 848ms *Time : 832ms 总结 感觉也没啥好说的，这个快速排序是真的蛮快的了。不过这还并不是最快的，虽然他名字是快速排序。。。至于我一开始提到的那个快速排序是冒泡排序的改进，我是真的没怎么发现这两个算法之前的联系有多么的紧密。你说希尔排序是插入排序的改进，这个我能看出来，快速排序和冒泡排序。。。额，还是我太蠢了吗？看不粗来啊！至少速度上，是看不出来，，，蛤蛤蛤，冒泡排序哭死~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（四）希尔排序]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序算法（四）希尔排序 之前说的是插入排序，虽然插入排序的效率嘛已经说是可以的了，但是插入排序有一个明显的漏动。比如说给定的数组如果是 1 2 3 4 5 6 7 8 9 0使用插入排序要将这个0移动到数组的最前面还是非常费力的。也就说是如果有很多小数据位于数组的末端，插入排序的效率就会极大的降低。而这次要说的希尔排序就是插入排序的一种，也就死来解决这个问题的。 希尔排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 希尔排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 一般 希尔排序虽然是插入排序的一种优化，但是希尔排序是不稳定的，插入排序是稳定的。于此类似的是快速排序是冒泡排序的优化，但是快速排序不稳定，冒泡排序稳定。不过。。稳定性这个玩意我到现在还没有用到过。 希尔排序的基本思路希尔排序的基本思路就是分组进行插入排序。就还比如说上面的那个数组 1 2 3 4 5 6 7 8 9 0，我们将其分为五组，1 6 ，2 7.3 8.4 9.5 0。对这五组数据进行插入排序，那么清晰的可以看见0到前面却。然后将数据分为两组，继续插入排序。再将数据分为一组(此时就是插入排序了)进行排序就完事了。既然希尔排序中包含这插入排序那为啥希尔排序的速度还比插入排序快啊，希尔排序的前面的几次分组将小的数据往前面进行了移动，最后的那次插入排序移动的次数是很少的。所以说希尔排序是一种较为高效的算法。 下面的图片基本上就讲的比较清楚了。 再来一个图片演示一下 希尔排序和插入排序一样，都有交换法和移动法的实现，我们就分别都用代码演示一下。 希尔排序——交换法代码实现//这也是插入排序的一种 ,因为插入排序是 ,如果小的数在后面的话 插入排序的效率特别的低,所以出现了希尔排序，是插入排序的一种改进 public static void shellSort(int[] arr) { int temp = 0; // System.out.println(&quot;原来的数组：&quot;+Arrays.toString(arr)); // 这里的gap指的是不同的组数据之间的距离。 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; arr.length; i++) { for (int j = i; j &gt;= gap; j -= gap) { // 交换的次数太多了 太浪费时间 if (arr[j] &lt; arr[j - gap]) { temp = arr[j]; arr[j] = arr[j - gap]; arr[j - gap] = temp; }else break; // 分组进行插入排序，如果上面的条件不成立就说明已经插入到了指定的位置。 } } // System.out.println(&quot;第x次排序：&quot; + Arrays.toString(arr)); } } 代码说明： gap是什么？ gap指的是同一组当中相邻的元素之前的距离。初始值是arr.length/2，以后每次都除以2，这就是为什么我在一开始的那个数组中先分为五组再分为两组最后再分为一组。等到gap等于1也排序完成了之后，gap/2变成了0，此时排序完成，就可以退出循环了。 i和j代表着什么含义？ i从gap开始是为什么？ i代表的是每组元素的后面无序元素，从每组第二个元素开始。这就好比插入排序，每一组的第一个元素是有序的，而后面的元素是无序的，我们要将后面的无序的数据插入到前面的有序的数据中。其实我们完全可以写了个函数insertSort(int arr[], int gap)。gap等于1的时候就是上面篇博客当中的插入排序的算法。 j就是要插入的元素所在的位置，只不过这一次他前面的那个元素不再是j-1，而是j-gap， 如果理解了上篇博客的插入排序的思路的话，这个希尔排序也是非常容易理解的。 有三层for循环，效率为什么高？ 有三层for循环并不代表这时间复杂度就是O(n^3^)，第一层for循环每次都除以2，时间复杂度是O(log2n)。第二层的for循环每次都加1，时间复杂度是O(n)，第三层for循环的每次都减去gap，复杂度也在O(logn)左右。所以这个算法的时间复杂度是O(nlog^2^n)。数据量越大，越是比O(n^2^)的排序算法来的优越。 希尔排序——移位法代码实现 // 和插入排序法相似，希尔排序也有两种实现的方式，一个是上面的那个交换法，另一个就是下面的移动法。 // 采用移动法 对交换式的希尔排序进行改进 思路与之前的插入排序是相似的 public static void shellSortPlus(int[] arr) { for (int gap = arr.length/2; gap &gt; 0; gap/=2) { for (int i = gap; i &lt; arr.length; i++) { int insertIndex = i; int insertVal = arr[i]; while (insertIndex-gap &gt;=0 &amp;&amp; insertVal &lt; arr[insertIndex-gap]) { arr[insertIndex] = arr[insertIndex-gap]; insertIndex -= gap; } arr[insertIndex] = insertVal; } } } 代码说明： 其实这个代码也没有什么要说明的，这就是插入排序的套了个gap嘛。不懂的可以去看看插入排序的那个算法去。嘤嘤嘤~ 希尔排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80,000个和8,000,000个[0, 800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random() * 800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); shellSort(arr); // shellSortPlus(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot; + (end_time - start_time) + &quot;ms&quot;); } 交换法 80,000数据时： Time : 14ms Time : 16ms Time : 17ms 8,000,000数据时： Time : 2008ms Time : 2018ms Time : 1973ms 移位法 80,000数据时： Time : 17ms Time : 17ms Time : 15ms 8000000数据时： Time : 1868ms Time : 1824ms Time : 1873ms 总结希尔排序虽然只是对冒泡排序的一个小小的改进，但是看到了这个希尔排序的速度后，这肯定是要惊呆了！！什么！！！排序八百万个数据也就和插入排序法排序八万个差不多！什么！！冒泡排序法，，它。。要寻短见？ 这不能喽，程序员需要冒泡排序法！你排七八个数据难道还要写归并排序，堆排序嘛，还不是一个冒泡排序写的舒服~~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（三）插入排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法(三) 插入排序法插入排序算法，冒泡排序算法，和选择排序算法三个合称三大基本排序算法，因为都是相对比较简单易懂的算法，相对来说算法的效率也是比较低的。但是这个插入排序算法比起冒泡选择来说难度还是高一点的，而且在学校中教授的也只有冒泡排序和选择排序，插入排序是没有教授的。 插入排序的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 插入排序法 O(n^2) O(n) O(n^2) O(1) 否 插入排序算法是一种稳定的算法，和冒泡排序是一样的，相同的数据经过插入排序之后相对位置是不变的。 插入排序的基本思路插入排序的思路是将待排序的数组分为两个数组，左面是有序的数组，右面是无序的数组，（一开始左边的第一个元素就自成一个有序数组，毕竟只有一个元素，怎么说都是有序的）然后将无序数组的第一个数据插入到有序的数组当中去。于是有序的数组越来越大，等到无序的数组中的所有的元素都插入到了有序的数组中的时候，排序就完成了。 对于无序的数据如何插入到有序的数组当中去有两个实现的办法。一个是交换法，另一个是移位法。上面的动图实现的就是交换法。让我们先从简单的交换法讲起。 插入排序——交换法的代码实现感觉这个算法看一下上面的那个动图就能清楚的明白。就是如同冒泡排序法一样，如果要插入的数据被前面的数据小的话，两者交换数据，然后继续比较，直到插入的数据大于前面的那个数据(此时便插入到了合适的位置了)退出循环即可。 // 插入排序， 使用直接交换的方法，这样交换的次数就非常多了，效率就变低了 public static void insertSort(int[] arr) { int temp;// temp用于下面的交换 // 左面有一个数据是有序的，无序的数据是从第二个开始的，所以i的初始值为1 for (int i = 1; i &lt; arr.length; i++) { for (int j = i; j &gt; 0; j--) {// 使用交换的方式来插入当前的数据 if (arr[j] &lt; arr[j-1]) { temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; }else { // 如果上面的if不成立就说明这个数已经到达了指定的位置，因为左面的数组是有序的。 break; } } } } 代码说明： i 为什么从一开始？ ​ 因为插入的值是从无序开始的，而一开始arr[0]就是有序的，无序的从arr[1]开始，所以i是从1开始的。 j。。。好像没啥好说明的。这个代码还是非常容易理解的。还是叭说了QwQ 插入排序——移位法的实现移位法不是交换数据来实现数据的插入，而是先把待插入的数据保存起来。然后依次与前面的有序的值进行比较。如果前面的值比待插入的值大的话，直接将前面的值赋给后面的值(就好像移动位置一样，前面的值将后面的值覆盖了)。然后继续比较。如果小于的话，直接将当前的位置赋予之前保存的那个待插入的值，然后退出本次循环。 // 采用的是移位法不是交换法，极大的提高了插入排序的效率 public static void insertSortSgg(int[] arr) { for (int i = 1; i &lt; arr.length; i++) { int insertVal = arr[i];// 保存要插入的值 int insertIndex = i; // 要插入的位置。。。 // while循环找到了当前值应该插入的位置 while (insertIndex &gt; 0 &amp;&amp; insertVal &lt; arr[insertIndex-1]) { arr[insertIndex] = arr[insertIndex-1];// 将大的数据后移 insertIndex--; } arr[insertIndex] = insertVal; // 插入数据 } } 代码说明： insertVal和insertIndex是干什么用的？ insertVal用于保存当前要插入的值，也就是后面的无序的数组的第一个元素。如果不保存的话，根据移位法，要插入的值将可能被前面的值覆盖，那还玩个蛇皮！ insertIndex是保存要插入的位置，初识值就是要插入的值的原本的位置（即没有发生移位）。 while循环写的是什么玩意，我为啥看不懂？？ while循环里面的第一个条件是保存你不能插到数组的外面去（咋滴，你是想飞还是干啥，想插入到数组的外面去？），第二个条件是要插入的位置的前面的位置的值要比要插入的值大。刚才也分析过了，如果比要插入值小的话，就说明要插入值放在这个位置是正确的。（前面的位置比他小，后面的位置比他大）注意：此时要插入的值后面的那个值是和当前位置的值相同的。insertIndex是因为满足了insertVal &lt; arr[insertIndex-1]（上一层循环的条件,因为insertIndex–同时由于数据右移了，所以，在本层循环应该是 insertVal&lt; arr[insertIndex+1]）这个条件才来到这个位置的。所以说，如果不满足这个条件，insertVal就应该放在insertIndex上。 while循环里面是干啥？ 进入while循环就意味着满足 insertVal &lt; arr[insertIndex-1]这个条件也就是说如果insertVal放在insertIndex这个位置是 arr[insertIndex] &lt; arr[insertIndex-1]，后面比前面小，这不满足条件啊，所以说要移动位置继续向前探索！ 插入排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*80000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); insertSort(arr); // insertSortPlus(arr); // insertSortPlusPlus(arr); // insertSortSgg(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 交换法 Time: 2531ms Time: 2340ms Time: 2376ms 移位法 Time: 1580ms Time: 1580ms Time: 1540ms 总结和冒泡排序，选择排序比起来插入排序有一定的优势，毕竟是基本算法中既有稳定性，速度还可以的算法啦。移位法的速度比选择排序快一点，交换法虽然慢一点但是容易理解。这个移位法其实蛮容易理解的，可能是我没有画图，所以讲的不清楚吧，下次我把图补上(网上没找到合适的图)，应该就好多了吧。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（二）选择排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（二）选择排序法选择排序算法和冒泡排序算法算是难兄难弟了，都是以其简单而闻名，也是在学校中我们主要学习的排序算法。但是不是不说，这个选择排序算法除了不稳定，其他都可以吊打冒泡排序算法。那现在难兄没了，只剩下这个难弟冒泡排序算法了。 选择排序法的基本介绍 名字 平均时间复杂度 最好时间复杂度 最差时间复杂度 空间复杂度 是否流弊 选择排序法 O(n^2) O(n^2) O(n^2) O(1) 否 选择排序法是一种不稳定的算法，也就是说相同的数据经过选择排序法之后不一定会保持原来的顺序。 选择排序法的基本思路每次使用第一个位置的（不一定是arr[0]）和之后的数据比较，找到最小的那个数据然后两者交换。如此一来，小的数据就往数组的前面去了，数组也就变得有序了。不是我说，这个排序一看就比冒泡排序法好，因为每一轮排序只需要进行一次的交换。当然比较节省时间了。 从上图可以看出来，选择排序似乎和冒泡排序有点相似，一个是把大的数据往后边沉，一个是把小的数据往前面搬。 代码实现 public static void selectSort(int[] arr) { int temp; for (int i = 0; i &lt; arr.length-1; i++) { int minIndex = i; for (int j = i+1; j &lt; arr.length; j++) { if (arr[minIndex] &gt; arr[j]) { minIndex = j; } } if (minIndex != i) { temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } } } 代码的几点说明： i，j的作用： i变量指的是数组开始排序的位置，因为每排一个序，前面就多一个数字变得有序，所以我们就没有必要动那些已经变得有序的数组了。所以说需要排序的范围就是 i 到 arr.length -1 j变量值的是i后面的那些数据，所以从i+1开始一直到数组的结束。i的结束的数组的倒数第二数，如果i到最后一个数的话后面已经没有数据，一个数怎么说都是有序的，所以说i没有必要到最后一个数。每次arr[i]也就是当前循环的第一个数都会与后面的arr[j]进行比较，一轮之后和最小的数进行交换然后i移动到下一个数 为什么只有一次交换？ 因为minIndex变量的存在（minIndex被初始化为了i），我们可以存储找到的最小的值的下标，而不是一味的交换i与j的数据。当我们发现arr[j] &lt; arr[minIndex]时，就把minIndex = j；因为他的值更小嘛，如此一来，我们就可以得到后面的最小值的下标了。一轮循环结束之后再进行交换（i != minIndex 如果i == minIndex那就说明if语句一直都是假的，arr[i]处的值就是最小的，没有必要和谁交换啦)。 选择排序的测试测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); selectSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); } 测试结果： Time: 1629ms Time: 1417ms Time: 1606ms 总结选择排序法虽然和冒泡排序深处基本排序算法之列，但是选择排序的速度比冒泡排序法快的不是一点半点。虽然说冒泡排序法有稳定性上面的优势，但是同处基本排序算法的插入排序法也是稳定的，而且插入排序法的效率也蛮高的。冒泡排序。。。很危险吖~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(一） 冒泡排序法]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法（一） 冒泡排序法冒泡排序法可谓是我们学到的第一个排序算法了，以其简单易懂而闻名，但是这个算法又是特别的垃圾，因为效率及其的低下。 下面是一些经典的排序算法的时间复杂度： 别看这个冒泡排序法的时间复杂度和选择，插入是一样的，但是效率却远远比选择，插入低，尤其是数据量很大的时候。 冒泡排序的思路冒泡排序的思路就是每次把最大的数挑出来放到数组的最后面(排序皆是从小到大)。如下图所示 每一次将最大的元素移动到数组的后面，移动了5次，这个数组就是从大到小有序的了。 代码的实现冒泡排序比较容易理解，代码也是比较好写的。 public static void bubbleSort(int[] arr) { boolean flag = false; int temp; for (int i = 0; i &lt; arr.length-1; i++) { for (int j = 0; j &lt; arr.length-i-1; j++) { if (arr[j] &gt; arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = true; } } if (!flag) { break; }else { flag = false; } } } 代码的几点说明： i和j的含义 可以清除的看到在两个for循环的循环体中是没有i变量的，也就是说i变量只是用来计量有几个大数被移动到了数组的末尾。 j变量是用于交换. j &lt; arr.length - 1-i的作用是后面的几个变量已经排过序了，他们就是最大的那几个数，j变量可以不用对他们进行比较交换啦。j从0开始每次和j+1进行比较，如果arr[j]大，也就是前面的数大，就把他往后面移动。如此一来，前面的几个数中最大的那个数就被移动到当前j所比较的末尾arr.lenght-1-i处。 flag的作用是什么？ flag这个是对冒泡排序法的一个优化，虽然优化过后这个算法还是一样的垃圾。。。flag所代表的含义是该次循环中有没有发生过交换。一开始我们将其置为flag(不初始化也是可以的，boolean型的变量的初始值就是false).当本次循环进行过交换的时候，将flag置为true。然后再将循环置为false。当有某次的循环中没有进行过交换，这个也就是意味着此时数组前面的那几个数已经是有序的了，而数组后面的数同样也是有序的，所以退出循环排序结束。 冒泡排序的测试：测试环境及工具：我的电脑 Huawei MateBook 13+JDK1.8+Eclipse 测试手段：随机生成80000个[0,800000）的整数的数组进行排序，观察所花费的时间 测试代码： public static void main(String[] args) { int[] arr = new int[80000]; for (int i = 0; i &lt; arr.length; i++) { // arr[i] = (int) (Math.random()*800000); arr[i] = new Random().nextInt(800000); } // System.out.println(Arrays.toString(arr)); long start_time = System.currentTimeMillis(); bubbleSort(arr); long end_time = System.currentTimeMillis(); // System.out.println(Arrays.toString(arr)); System.out.println(&quot;Time :&quot;+(end_time-start_time)+&quot;ms&quot;); 测试结果： Time： 8786ms Time： 8706ms Time： 8661ms 总结哇！！！八万个数据的排序才花了八秒，这个算法好厉害啊！！！我是不会告诉你后面的堆排序，归并排序排序八万个数只是用了10ms，排序八百万个也用不了一秒的。。 冒泡排序算法中有着大量的数据的交换，这就注定了这是一个低效的算法。但是还好的是，冒泡排序算法是一个稳定的算法。所谓稳定的算法就是拥有相同的值的数据在排序完之后的顺序保持不变. 比如说 8 3 4 5 3 6 排序后是 3 3 4 5 6 8，排序完的第一3仍然是原来数组中的第一个3]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用赫夫曼编码来压缩数据]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%88%A9%E7%94%A8%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[利用赫夫曼算法来压缩数据压缩文件是我们经常碰到的文件类型，一般在windows上 rar zip 7z这几种格式是最常见的。因为格式的不同他们的原理也同样不同。这里介绍的是使用赫夫曼算法进行简单的压缩数据。 首先要来了解一下赫夫曼树是什么。 赫夫曼树 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 简单的来说赫夫曼树就是WPL最小的树。 WPL计算WPL首先要知道这个树的权值，然后还要知道这个树的高度(所谓高度就是到根节点的经过的节点的个数)。 想要一个树是最优二叉树(WPL最小的树)，我们就要尽量把权值较大的数据放在靠近跟节点的地方，把权值较小的数据放在远离根节点的地方。 如何构造赫夫曼树首先我们要新建一个节点，因为赫夫曼树要比较权值的大小，所以这个节点类还要实现Comparable接口. // ：让Node是实现Comparable接口，使之可以排序 class Node implements Comparable&lt;Node&gt;{ private int value; private Node left; private Node right; public Node(int value) { this.value = value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getLeft() { return left; } public void setLeft(Node left) { this.left = left; } public Node getRight() { return right; } public void setRight(Node right) { this.right = right; } @Override public String toString() { return &quot;[value=&quot; + value + &quot;]&quot;; } //：返回 -1 0 1 @Override public int compareTo(Node o) { //： 表示从小到大排序 return this.value - o.value; //： 表示从大到小的排序是 return o.value - this.value } } 这样一个节点就创建好了。 接下来就可以来生成一个赫夫曼树了 class HuffmanTree { public static Node createHuffmanTree(int[] arr) { List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(); for (int val : arr) { nodes.add(new Node(val)); } while(nodes.size() &gt; 1) { Collections.sort(nodes); Node leftNode = nodes.get(0); // ：最小的那个节点 Node rightNode = nodes.get(1); //：第二小的那个节点 Node parentNode = new Node(leftNode.getValue() + rightNode.getValue()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } //：实现了Comparable，可以进行排序 return nodes.get(0); } } 由代码可见，上面的算法的步骤是： 1. 先将所有的节点放入到一个ArrayList中。 2. 先将这个ArrayList排序，找到最小两个节点，同时new一个新的节点，使其左节点指向稍微小的那个节点，右节点指向稍微大的那个节点。 3. 从ArrayList中去除刚才取出的两个节点，放入新的节点。 4. 循环第二步和第三步，知道ArrayList中就剩下最后一个节点。这个节点就是赫夫曼树的根节点这个算法还是蛮容易理解的，刚才所有的节点都是赫夫曼树的叶子节点，所有的非叶子节点都是我们新生成的。通过上面的这个算法，我们就能轻松的得到一个赫夫曼树。 赫夫曼编码计算机中的文件都是以二进制的格式存放的。我们先以字符串来举例。 java java java is good good but cpp cpp is best best 上面的这段话，在计算机中储存也是以二进制的文件进行储存的。我们知道一个字符对应了一个八位的byte，也就是一个ascii。那上面的数据在计算机中储存就是n*8bit。 这就是最直接的编码，每8位对应一个字符。 但是不难发现上面的字符串中存在不少的重复的字符。 j出现了3次，a出现了六次，空格出现了11次。 如果我们按照这些字符出现的顺序对其重新进行编码，不是就节省了不少的内存了吗？ 空格编为0，a编为1， o编为10， p编为11.。。。 但是这样也带来了更大的问题，比如说计算机中的11解码成aa还是p呢？？也就是说这样的编码会代码混乱，这样的编码不是一个前缀编码。前缀编码需要满足这样的条件，任何一个码不能是另外的码的前缀。 这些字符出现的顺序对其重新进行编码这种思路是对的，但是如何采取最优的措施呢？ 这不难想到上面说的赫夫曼树，字符出现的顺序就是字符的权重，构造一颗赫夫曼树或许能够解决我们的问题。 利用字符串来构造赫夫曼树首先我们要构造一个新的节点 class NewNode implements Comparable&lt;NewNode&gt;{ private Byte data;// 字母 private int weight;// 出现了多少次 private NewNode left; private NewNode right; public NewNode(Byte data, int weight) { this.data = data; this.weight = weight; } public Byte getData() { return data; } public void setData(Byte data) { this.data = data; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } public NewNode getLeft() { return left; } public void setLeft(NewNode left) { this.left = left; } public NewNode getRight() { return right; } public void setRight(NewNode right) { this.right = right; } @Override public String toString() { return &quot;[data=&quot; + data + &quot;, weight=&quot; + weight + &quot;]&quot;; } @Override public int compareTo(NewNode o) { return this.weight - o.weight; } public void preOrder() { System.out.println(this); if (this.left != null) { this.left.preOrder(); } if (this.right != null) { this.right.preOrder(); } } } 然后我们还需要统计每个字符出现的次数，将结果放入一个ArrayList中 /** * 由原始字节数组生成对应的集合 * @param bytes 原始字节数组 * @return 数值加权重的对应集合 */ public static ArrayList&lt;NewNode&gt; getNodes(byte[] bytes){ ArrayList&lt;NewNode&gt; nodes = new ArrayList&lt;NewNode&gt;(); //：使用map[key, value]遍历统计每个字符出现的次数 HashMap&lt;Byte, Integer&gt; counts = new HashMap&lt;Byte, Integer&gt;(); for (byte b : bytes) { Integer count = counts.get(b); if (count == null) { counts.put(b, 1); }else { counts.put(b, count+1); } } //：把键值对转为NewNode对象，并放入ArrayList中 for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) { nodes.add(new NewNode(entry.getKey(), entry.getValue())); } return nodes; } 这样这个ArrayList中就存放了字符和他的权重了。 然后我们可以利用上面的方法来构造一颗胡夫曼树。 /** * 生成一个赫夫曼树 * @param nodes 由原始字节数组形成的集合 * @return 赫夫曼数的根节点 */ public static NewNode createHuffmanTree(ArrayList&lt;NewNode&gt; nodes) { while (nodes.size() &gt; 1) { Collections.sort(nodes); NewNode leftNode = nodes.get(0); NewNode rightNode = nodes.get(1); NewNode parentNode = new NewNode(null, leftNode.getWeight() + rightNode.getWeight()); parentNode.setLeft(leftNode); parentNode.setRight(rightNode); nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parentNode); } return nodes.get(0); } 这样一颗赫夫曼树就构建好了，但是如何得到我们之前说的那个最优的前缀编码呢？？？ 很简单当我们从一个节点走向他的左节点的时候，我们为编码加上0，向右走的时候加上1，因为赫夫曼树中的所有的非叶子节点都是null，有意义的仅仅是叶子节点。叶子节点是没有子节点的，所有这样生成的赫夫曼编码就是一种前缀编码。而且他也是最优的前缀编码。 获取赫夫曼编码/** * 获取赫夫曼编码表 * @param node 赫夫曼树的根节点 * @param huffmanCodes 用来储存赫夫曼编码的map * @param code 左走是0 右走是1 * @param stringBuilder 用来连接0和1 */ public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes, String code, StringBuilder stringBuilder) { StringBuilder stringBuilder2 = new StringBuilder(stringBuilder); stringBuilder2.append(code); if (node != null) { if (node.getData() == null) { getCodes(node.getLeft(), huffmanCodes, &quot;0&quot;, stringBuilder2); getCodes(node.getRight(), huffmanCodes, &quot;1&quot;, stringBuilder2); }else { huffmanCodes.put(node.getData(), stringBuilder2.toString()); } } } 可以给这个方法一些默认的参数 public static void getCodes(NewNode node, HashMap&lt;Byte, String&gt; huffmanCodes){ getCodes(node, huffmanCodes, &quot;&quot;, new StringBuilder()); } 这样我们就得到了赫夫曼编码表。得到了赫夫曼编码我们就可以对数据进行压缩了。 压缩字符串/** * 使用赫夫曼编码压缩字符数组的长度 * @param contentBytes 要进行压缩的字符数组 * @param huffmanCodes 传入一个哈希Map，传出的就是 对应的赫夫曼表Map。可用于之后的解压！ * @return 返回压缩后的字节数组 */ public static byte[] zip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { ArrayList&lt;NewNode&gt; nodes = HuffmanTree.getNodes(contentBytes); NewNode root = HuffmanTree.createHuffmanTree(nodes); HuffmanTree.getCodes(root, huffmanCodes); String codes = HuffmanTree.huffmanCodes(contentBytes, huffmanCodes); // System.out.println(codes); int len = (codes.length() + 7)/8; byte[] by = new byte[len]; for (int i = 0, index=0; i &lt; codes.length(); i+=8) { String strBytes; if (i+8 &gt; codes.length()) { strBytes = codes.substring(i); }else { strBytes = codes.substring(i, i+8); } by[index] = (byte) Integer.parseInt(strBytes, 2); index++; } return by; } 上面的代码需要注意的是code（10100010011….)的长度不一定是8的倍数，最后的一个字符串可能是没有8位的，所以我们要进行一次判断。 至此，我们已经完成了压缩的所有的工作。进入主方法进行一次测试。 压缩前的长度：52 压缩后的长度：24 压缩率：53.84615384615385% 解压数据： java java java is good good but cpp cpp is best best 是否解压成功：true 赫夫曼编码表如下所示，可见确实是前缀编码。 {32=00, 97=010, 98=0110, 99=10101, 100=11100, 101=11101, 103=11110, 105=11111, 106=0111, 111=1011, 112=1100, 115=1101, 116=1000, 117=10100, 118=1001}生成的二进制补码如下所示，这个一看就比原来的少多了，毕竟这个字符中我估计加入了不少重复的字符。 01110101001010000111010100101000011101010010100011111110100111101011101111100001111010111011111000001101010010000010101110011000010101110011000011111110100011011101110110000001101110111011000解压字符串首先我们需要将一个byte转为一个二进制补码类型的字符串 /** * 将一个byte转为一个二进制的字符串 * @param flag 是不是最后一个不满8位的byte 看是否需要按位与来补位 true代表需要补高位， false代表不需要补高位 * @param b * @return 按补码返回的 正数的补码就是原码，负数的补码是反码+1 */ private static String byteToBitString(boolean flag, byte b) { int temp = b; if (flag) { temp |= 256;// 256: 1 0000 0000 } String str = Integer.toBinaryString(temp);//:返回二进制的补码 if(flag) { return str.substring(str.length()-8);//：只是取得后面的八位 }else { return str; } } 同样的，我们要考虑到最后几位的问题。还有补码的有关的操作我也在上面注释清楚了。 下面就可以来解压了 /** * 解压之前使用赫夫曼编码的数据 * @param contentBytes 压缩之后的字节流 * @param huffmanCodes 之前压缩的时候使用的赫夫曼编码map * @return 解压之后的字节数组 */ public static byte[] unzip(byte[] contentBytes, HashMap&lt;Byte, String&gt; huffmanCodes) { StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; contentBytes.length; i++) { byte b = contentBytes[i]; boolean flag = (i != contentBytes.length-1); stringBuilder.append(byteToBitString(flag, b)); } // System.out.println(stringBuilder.toString()); HashMap&lt;String, Byte&gt; reverseMap = new HashMap&lt;String, Byte&gt;(); for (Map.Entry&lt;Byte, String&gt; val : huffmanCodes.entrySet()) { reverseMap.put(val.getValue(), val.getKey()); } int i=0; int count = 1; ArrayList&lt;Byte&gt; arrayList = new ArrayList&lt;Byte&gt;(); while (i &lt; stringBuilder.length() &amp;&amp; i+count&lt;=stringBuilder.length()) { Byte b = null ; while (i+count &lt;= stringBuilder.length()) { String str = stringBuilder.substring(i, i+count); b = reverseMap.get(str); if (b == null) { count++; }else { i += count; count = 1; break; } } arrayList.add(b); } byte[] resultBytes = new byte[arrayList.size()]; for (int j = 0; j &lt; resultBytes.length; j++) { if (arrayList.get(j) == null) { break; } resultBytes[j] = arrayList.get(j); } return resultBytes; } 上面将赫夫曼编码进行了对调键值，这样更有利于后面的解压。通过扫描的方式逐个进行配对。 至此，压缩和解压字符串的操作就都已经完成了。。。 等等，，不是将压缩和解压文件的吗，怎么只讲了字符串？？？ 其实刚才我们处理时并不是字符串，而是一个byte[]数组，我们只是把字符串转为了一个byte[]数组进行处理了。而任何文件都是以字节进行储存的，所以说这个解压和压缩的方法不仅适用于这个字符串还适用于各种各样的文件。如文本文件，视频，图片等，不过压缩的效率怎么样就不能保证了。只能说重复的越多，压缩的效率越高。对于文件的处理就是简单的加上Java当中IO流罢了。 直接上代码吧。 /** * 使用赫夫曼编码来压缩文件 * @param srcFile 要压缩的文件的原地址 * @param dstFile 压缩后的文件的地址 */ public static void zipFile(String srcFile, String dstFile) { FileInputStream is = null; FileOutputStream os = null; ObjectOutputStream oos = null; try { is = new FileInputStream(srcFile); byte[] b = new byte[is.available()]; is.read(b); HashMap&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); byte[] zipcontent = zip(b, huffmanCodes); // System.out.println(huffmanCodes); // System.out.println(new String(zipcontent).substring(1,10)); os = new FileOutputStream(dstFile); oos = new ObjectOutputStream(os); //：以对象流的形式写入， 方便之后的解码 oos.writeObject(zipcontent); oos.writeObject(huffmanCodes); } catch (Exception e) { System.out.println(e.getMessage()); } finally { try { is.close(); os.close(); oos.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 需要注意的是：使用ObjecOutpuStream使用对象流的方式将对象写入文件中,利于后面解压的时候提取数据。注意：赫夫曼编码表需要写入到文件中,不然就没办法解压了！ /** * 使用赫夫曼编码来解压文件 * @param srcFile 需要解压的文件地址 * @param dstFile 解压后的文件地址 */ @SuppressWarnings(&quot;unchecked&quot;) public static void unzipFile(String srcFile, String dstFile) { FileInputStream is = null; ObjectInputStream ois = null; FileOutputStream os = null; try { is = new FileInputStream(srcFile); ois = new ObjectInputStream(is); byte[] zipBytes = (byte[]) ois.readObject(); HashMap&lt;Byte, String&gt; huffmanCodes = (HashMap&lt;Byte, String&gt;) ois.readObject(); // System.out.println(huffmanCodes); // System.out.println(new String(zipBytes).substring(1,10)); byte[] unzipBytes = unzip(zipBytes, huffmanCodes); os = new FileOutputStream(dstFile); os.write(unzipBytes); } catch (Exception e) { System.out.println(e.getMessage()); e.printStackTrace(); // System.out.println(e.getStackTrace()); } finally { try { if (is!=null) { is.close(); } if (ois!=null) { ois.close(); } if (os!=null) { os.close(); } } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 小结总的来说，上面所提供的压缩和解压文件的方式还是非常简陋的，不过还是足以让我们来了解压缩文件的本质是什么。所谓的zip 7z rar无损压缩都是采用的这个思路，利用重复！如果没用大量的重复，而是杂乱无规则的话，就是神仙来了都压缩不了1kb… ​ ———— Hony Sher 7/17/2019]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MarkDown的基本使用]]></title>
    <url>%2F2019%2F07%2F17%2FMarkDown%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MarkDown的基本语法MarkDown的基本介绍之前写笔记什么的基本上用的都是win10电脑上自带的oneNote 来写笔记的，总有点感觉写的没用那种程序员味，比起用 word 来说也好像差不了多少。 之后通过一个Up主了解到了 markdown这种语言，才明白原来程序员也用自己写笔记的专门的语言，hiahiahia。 *Markdown和HTML** 是兼容的，但是*markdown 要html的语法简单的多。下面就花几分钟的时间来熟悉一下Markdown这门语言。这里我使用的markdown编辑器是 vscode和typora，这两个编辑器都蛮好用的。 标题感觉这个标题就是最简单的了。标题和html一样分为7个大小 h1标题就是#， h2就是##，以此类催，没多加一个#标题就会变小一号。但是有要注意的是 打完#之后需要打一个空格才行，不然不会被markdown解析为标题。 # 这是一级标题 ## 这是二级标题 ... 上面我的那个标题用的是 ### 标题字体加粗语法：**加粗**; 我被加粗啦！ 斜体语法：*斜体* 我怎么斜了？？？ 删除线语法：~~删除线~~ 我不要被划线!，嘤嘤嘤 斜体加粗语法： ***斜体加粗** 就是这么强大的我！ 引用语法：&gt; &gt;&gt; &gt;&gt;&gt; 引用&gt; 再来一个&gt; 直接两个&gt; 这玩意好像真的没什么用。。 分割线语法：--- *** 三个或者三个以上的-和*都可以代表一个分割线，效果是一样的 图片语法：![图片的说明](图片的地址 &quot;移动到图片处显示&quot;) 这个图片着实令我有些头疼， 因为好像本地的图片不能弄到博客上面去。这里就去找一些网络图片吧。 ![来自我github上的一张图片](https://raw.githubusercontent.com/sheriby/cdn/master/img/custom/head.jpg ”我的头像“)超链接语法[超链接的文字](超链接的地址 &quot;超链接的说明&quot;) [我的博客](https://sheriby.github.io) 我的博客 列表无序列表语法：- + * 任意一种都可以, 注意都要有空格 - 列表内容 + 列表内容 * 列表内容 列表内容 列表内容 列表内容 有序列表语法：1. 2. 3. 数字加上点就行了 1. 列表内容 2. 列表内容 3. 列表内容 列表内容 列表内容 列表内容 多重的列表进行嵌套的时候加上三个空格就行了 内容 内容 内容 内容 内容 内容 内容 内容 表格表格的语法比较复杂一点，但是也容易理解和记忆 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略姓名|技能|排行 --|:--:|--: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码这个应该是最有用的了，虽然上面一直都在用但是现在才说。 语法 用``引入的内容就是代码。。。虽然可能并不是代码使用三个成对的```可以引入多行的代码，也可以在代码块中规定语言，有对应的语法高亮。 template &lt;typename T, typename U&gt; auto add(const T&amp; t, const U&amp; u) -&gt;decltype(t+u){ return t+u; } 结语基本上就上面的这些内容了，所以说蛮简单的，似乎五分钟都不需要就可以上手了。 参考文章：Markdown基本语法]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个博客 HelloWorld]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2HelloWorld%2F</url>
    <content type="text"><![CDATA[第一个博客 HelloWordpythonprint(&quot;Hello World!&quot;) c++#include &lt;iostream&gt; int main(){ std::cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;std::endl; return 0; } javapublic class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;Hello World!&quot;)； } } 友情链接Learn from codeSheep]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>悦读</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
